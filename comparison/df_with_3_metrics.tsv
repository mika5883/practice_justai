question	contexts	answer	ground_truths	answer_relevancy	context_precision	faithfulness
Как создать пользовательский справочник в Aimylogic?	"['Как добавить ChatGPT в бота из конструктора'
 'Пользовательские справочники Наряду с системными сущностями и справочниками, Aimylogic предоставляет возможность создавать пользовательские справочники, чтобы бот мог извлекать из фразы клиента сущности, которые в них добавлены. Сущности Каждая сущность — это некий идентификатор записи в вашем справочнике. Для каждой записи нужно указать хотя бы один синоним на естественном языке, чтобы бот понимал, какие именно слова клиента относятся к этой сущности. Синонимы нужно указывать в словарной форме слова, то есть в именительном падеже единственного числа. Бот будет распознавать эти синонимы в других формах во время работы. Как создать справочник Управлять пользовательскими справочниками можно на странице Сущности в редакторе бота. Здесь находится список системных справочников и кнопка Создать справочник синонимов. Нажатие на кнопку открывает окно создания справочника. Здесь нужно придумать имя для справочника. В качестве имени справочника можно использовать только латинские буквы в нижнем регистре, цифры и знак подчеркивания. После создания справочника вы попадете на его страницу, где можно управлять его сущностями. Как использовать справочники В примере на видео мы создали справочник с именем $product и добавили в него несколько сущностей. Например, сущность iphone с синонимами айфон и ай фон. Теперь можно добавить в сценарий бота блок Интенты и указать Хочу заказать $product в качестве примера фразы.'
 'Подробнее о пользовательских справочниках и о том, как загрузить сразу много сущностей'
 'Релиз Aimylogic 1.11.0 Удаление данных из Google Таблиц. Пользовательские справочники с вложенными сущностями. Удаление данных из Google Таблиц Мы доработали функциональность блока Интеграция с Google Таблицами. Теперь вы можете: удалять содержимое конкретных ячеек или их диапазонов; удалять строки, столбцы или диапазоны строк либо столбцов. Подробнее об удалении данных из Google Таблиц Пользовательские справочники с вложенными сущностями Теперь при загрузке пользовательского справочника вы можете активировать опцию Добавлять значения сущностей в формате JSON и загружать справочники, содержащие не только синонимы сущностей, но и их значения в формате JSON. Благодаря этой опции вы сможете извлекать данные из значения сущности — например, характеристики вашего товара, которые будут храниться в полях объекта JSON. Эти поля можно использовать в сценарии. Подробнее об использовании вложенных сущностей'
 'name Модуль предоставляет справочники более 2 000 русских и 5 000 английских личных имен. Подключение Для подключения справочника импортируйте его с помощью тега require: После подключения в сценарии станут доступны: справочник именованных сущностей $Names; именованная сущность $Name для распознавания имен при помощи паттернов. Формат значений На русском языке: На английском языке: Примеры строк На русском языке: На английском языке:'
 'Бот-лидогенератор для онлайн-школы В данном уроке вы создадите бота, который будет предлагать клиентам записаться на пробный урок в онлайн-школу английского языка. Если клиент согласится, бот уточнит его данные и время записи, а затем отправит полученную информацию в Google Таблицу. Приветствие Перейдите на главную страницу Aimylogic и нажмите Создать бота. В первую очередь бот должен поздороваться с клиентом. Для этого добавьте новый экран с блоком Текст и укажите приветственную реплику, например: Добро пожаловать в школу английского языка “High Five”! Я могу рассказать вам о часах работы и расписании уроков, а также записать на первое занятие. Чем я могу вам помочь? Приветственная реплика Прием реакции клиента Чтобы клиент мог отреагировать на сообщение бота, нужно добавить в сценарий кнопки и интенты. Интент определяет, чего хочет клиент, и направляет его по нужной ветке сценария. Кнопки Кнопки позволяют связать два экрана. Вам потребуется добавить несколько кнопок: Нажмите Кнопка и введите текст для кнопки — например, Часы работы. Таким же образом добавьте другие кнопки — Запись и Расписание. К кнопке Расписание добавьте ссылку на сайт с информацией о расписании. Прикрепить ссылку можно к любой кнопке. Для этого наведите курсор на кнопку, нажмите и укажите URL. Добавление кнопок Интенты Интенты позволяют боту распознавать определенные фразы клиента. Чтобы добавить интент, нажмите Блок → Сделать свой интент. Вы можете заполнить интент примерами и шаблонами фраз.'
 'Создадим сущности Чтобы бот понимал синонимы или другие варианты написания названий товаров, а также склонение по падежам, добавим сущности. Сохраните сценарий Затем, перейдите на вкладку Сущности. Нажмите Создать справочник. Назовем справочник: products Теперь будем создавать сами сущности и синонимы к ним. Здесь важно понимать один момент - в сценарии бот будет принимать товары, используя эти сущности, то есть, он будет проверять, есть такая сущность или нет. Это первый этап проверки. Далее, если такая сущность есть, он будет сравнивать название сущности с названием товара в таблице. Поэтому очень важно, чтобы название самой сущности точно соответствовало названию товара в таблице. В синонимы же вы можете поместить другие формы названий. Итак, создадим сущность пицца и добавим синоним: пица Склонение слов наш NLU будет понимать, так что разные падежи добавлять не нужно, можно добавить только уменьшительно-ласкательные и разные необычные варианты написания. Создадим сущность морс из облепихи с синонимом морс Создадим сущность фалафель в лаваше с синонимом фалафель и фаляфель Еще раз проверьте, что названия сущностей соответствуют названиям товаров у вас в таблице. Затем нажмите Сохранить изменения и вернитесь в сценарий. Добавим проверку сущностей На экран ""Что бы вы хотели заказать?"" добавьте блок Интенты. В него скопируйте и вставьте следующее: \\* $products::choice \\* Что это означает? С помощью интентов мы можем принимать ввод сущностей.'
 'Управление списками клиентов Чтобы запустить рассылку или обзвон, необходимо создать список клиентов. Вы можете создать неограниченное количество списков и использовать их в любом проекте. Создание любого списка клиентов доступно пользователю с ролью OUTBOUND_MANAGER. Создать список клиентов можно двумя способами: загрузить файл со списком клиентов на странице Списки клиентов; добавить существующих клиентов бота в список на вкладке Аналитика > Клиенты в проекте. Загрузка файла со списком клиентов Авторизуйтесь на платформе JAICP. Нажмите на верхней панели > Списки клиентов > Создать список клиентов. В открывшемся диалоговом окне выберите тип канала: Телефония, если хотите создать список клиентов для обзвонов. Любой другой канал из перечня, если хотите создать список клиентов для текстовых рассылок. Загрузите файл со списком клиентов. Здесь вы также можете скачать примеры таблиц для обзвонов и для рассылок. Дождитесь результата валидации списка. Подтвердите, что номера или ID получены с согласия клиентов. Нажмите Создать. Список для обзвонов В списке для обзвонов номера телефонов должны быть указаны в первом столбце вместе с кодом страны и без знака +, например: 79111234567. Вы можете создать список с дополнительными полями, например: Имя, Фамилия, Город. Также вы можете указать часовой пояс и приоритет номера телефона. Подробнее об использовании дополнительных полей Список для рассылки В списке для рассылок в первом столбце должны быть указаны ID клиентов в выбранном канале.'
 'Уроки В этом разделе мы постараемся показать вам самые разнообразные способы использования ботов Aimylogic. Как запросить имя клиента Сбор контактных данных Печеньки с предсказаниями Как определять рабочее время с помощью бота Бот-секретарь Бот-лидогенератор для онлайн-школы Обзвон для возврата клиентов Авторизация Как сохранять информацию о пользователе Угадай число Бот-записная книжка Новостной бот Навык для поиска навыков Как посмотреть статистику самого популярного запроса от пользователя Как показать новости по запросу пользователя Валидация кодов для разных заданий Валидация кода Использование вебхуков для вычислений в сценарии Как выводить кликабельный список Вывод случайных данных Бронирование Запись в CRM Как обрабатывать запросы клиентов в Aimylogic Как оживить речь бота?'
 'Релиз Aimylogic 1.11.11 Возможность оплаты тарифа и пакетов по счету. Обновленный раздел Часто задаваемые вопросы. Новый урок Бот-лидогенератор для онлайн-школы. Возможность оплаты тарифа и пакетов по счету Юридические лица, зарегистрированные в Российской Федерации, теперь могут самостоятельно выставлять себе счет на оплату тарифов и крупных пакетов. Чтобы сформировать счет, на странице Управление тарифом напротив нужного тарифа выберите По счету и заполните данные о юридическом лице. Сформированный счет будет отправлен вам на email. Подробнее о способах оплаты Обновленный раздел Часто задаваемые вопросы Мы обновили раздел Часто задаваемые вопросы — теперь вопросы сгруппированы по темам. Раздел также пополнился новыми статьями: Вопросы о звонках Вопросы о каналах публикации ботов Как поменять данные аккаунта Новый урок Бот-лидогенератор для онлайн-школы Мы написали новый урок Бот-лидогенератор для онлайн-школы. Вы сможете создать бота для онлайн-школы английского языка, который будет записывать клиентов на пробное занятие. Вы узнаете, как с помощью бота: Приветствовать клиентов и распознавать их ответы. Отправлять клиентам информацию о часах работы и расписании занятий школы. Получать данные клиентов — имя, номер телефона, уровень владения английским языком. Узнавать у клиентов желаемую дату занятия. Отправлять полученные данные в Google Таблицы.']"	"Чтобы создать пользовательский справочник в Aimylogic, вам нужно перейти на страницу ""Сущности"" в редакторе бота. Здесь вы найдете список системных справочников и кнопку ""Создать справочник синонимов"". Нажмите на эту кнопку, чтобы открыть окно создания справочника. Введите имя для справочника, используя только латинские буквы в нижнем регистре, цифры и знак подчеркивания. После создания справочника вы попадете на его страницу, где сможете управлять его сущностями."	['- Aimylogic предоставляет возможность создавать пользовательские справочники, чтобы бот мог извлекать из фразы клиента сущности, которые в них добавлены.\n- Для каждой записи нужно указать хотя бы один синоним на естественном языке, чтобы бот понимал, какие именно слова клиента относятся к этой сущности.\n- Управлять пользовательскими справочниками можно на странице Сущности в редакторе бота.\n- Здесь находится список системных справочников и кнопка Создать справочник синонимов.\n- В примере на видео мы создали справочник с именем $product и добавили в него несколько сущностей.\n- Теперь можно добавить в сценарий бота блок Интенты и указать Хочу заказать $product в качестве примера фразы.\n- Эту переменную можно использовать так же, как и любую другую — например, запросить цену товара со своего сервера с помощью HTTP-запроса и вывести ее клиенту.\n- Вы можете добавлять сущности по одной или загрузить файл со списком сущностей и их синонимов.\n- Чтобы загрузить файл с сущностями, нажмите кнопку Загрузить справочник.\n- Все сущности, которые вы загрузите с помощью файла, отобразятся прямо в интерфейсе.']	1.0	0.4761904761746032	1.0
"Какие фразы и состояния активируются у бота при получении сообщений ""Привет"" и ""Пока""?"	"['От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.'
 'С их помощью вы можете просматривать статусы сообщений, которые бот отправил в канале Chat API: GET /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message-statuses GET /chatapi/{token}/client/{clientId}/message-not-read-count Подробнее о статусах сообщений Строковые подстановки в YAML-справочниках В JAICP DSL всегда была поддержка шаблонных строк после тегов тегов реакций и действий. Например, вы можете написать: Внутри скобок {{}} может находиться любое допустимое выражение на JavaScript: например, ссылка на переменную. Во время работы бота оно будет вычислено и подставлено в строку. Часть пользователей предпочитает хранить ответы бота в отдельном YAML-справочнике. Однако если вы раньше пытались хранить в них шаблонные строки, то их вложенные JavaScript-выражения не вычислялись: Мы исправили это поведение: теперь строковые подстановки правильно вычисляются и в YAML-справочниках.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.'
 'Длительность — длительность диалога с момента его начала и до последней фразы клиента. Статусы сообщений Если бот подключен в Telegram, Viber или ВКонтакте, в детализации диалога вы увидите статусы сообщений. Возможные значения: Отправлено Не отправлено Доставлено Не доставлено Прочитано Статус Отправлено доступен только в каналах Telegram и ВКонтакте, а статус Прочитано — в Viber и ВКонтакте. Фразы Для того чтобы отобразить поля Ответ и Разметка, переведите переключатели Выводить ответы и Выводить форму в активное положение. Отфильтрованные фразы отображаются в формате таблицы со следующими колонками: Вопрос — фраза клиента. Класс — название стейта, в котором была обработана фраза клиента. Стейт — название стейта, в котором бот сгенерировал ответ. Ответ — ответ бота. Разметка: Метки — проставьте метки для выбранной фразы. Комментарий — оставьте комментарий к выбранной фразе. Задача — создайте задачу на доработку проекта. Интенты — добавьте выбранную фразу в новый или уже существующий интент. Графики Здесь отфильтрованные фразы и сессии отображаются в виде графиков. Статистические графики помогут вам наглядно оценить динамику использования бота. Маршруты На вкладке Маршруты отображаются все последовательности стейтов, которые прошел клиент в рамках одной сессии. Информация о пройденных маршрутах позволяет понять, на каком этапе клиент прекращает взаимодействие с ботом. Проанализировав такую информацию, вы сможете изменить ваш сценарий и сравнить конверсию.'
 'От варианта Завершен успешно создайте блок Условия. Делаем условие $items.next(), которое возьмет вопрос из массива $items Назовем этот экран ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС От экрана ""ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС"" делаем связь на экран ""ВЫВОДИМ ВОПРОС"": Добавляем действие на случай, если есть история о пользователе Теперь нужно сделать так, чтобы на следующей сессии (например, при следующем запуске навыка в Алисе) мы узнавали пользователей и возвращали их на то место, где они остановились в последний раз. Вернемся в начало сценария. На экране ""ЕСТЬ ЛИ ИСТОРИЯ?"" от варианта Завершен успешно создайте новый блок Текст: С возвращением! В прошлый раз мы дошли до уровня $history.level. Твой счет: $history.score. Продолжим? Назовем этот экран ЕСЛИ ЕСТЬ ИСТОРИЯ Добавим на экран ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" блок Интенты. Добавим варианты реакций пользователя - готовые интенты Согласие и Отказ: :size=200 :size=200 Получаем неотвеченные вопросы От интента Отказ экрана ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" создадим блок http-запрос. Здесь нам снова нужно получить данные из Google Таблицы, как обычно. метод GET URL может быть таким же, как в блоке HTTP-запрос ""Получаем вопрос"" :size=200 :size=200 на вкладке RESPONSE нажмите на + и в поле Имя переменной вставьте: items, а в поле Значение вставьте: $httpResponse.slice(parseInt($history.level)) Давайте разберемся, что значит это выражение в блоке Значение: slice - возвращает новый массив, содержащий копию части исходного массива, parseInt - преобразует строку в число.'
 '$dialer.getBotSpeech Метод возвращает данные о воспроизведении реплики бота в телефонном канале. Синтаксис Метод вызывается без аргументов: Возвращаемое значение Метод возвращает массив объектов со свойствами: Формат объекта с репликой Объект с репликой бота reply содержит свойства со строковым типом. Если ответ отправлен через: Tег a, метод $reactions.answer или ответ с типом text, объект будет содержать свойства text и ssml — текст реплики и текст с разметкой синтеза речи, если она используется. Tег audio, метод $reactions.audio или ответ с типом audio, объект будет содержать свойство audioSrc — ссылку на аудиофайл audioSrc. Метод $reactions.ttsWithVariables, объект будет содержать свойства text — текст реплики, template — текст шаблона для синтеза речи, audio — ссылку на аудиофайл с шаблоном реплики. Пример возвращаемого значения Использование в сценарии Допустим, во время звонка бот информирует о текущих промоакциях. Он произносит текстовую реплику из тега a и затем воспроизводит запись диктора из тега audio. Чтобы записать информацию о воспроизведении реплики в комментарий в аналитику: Вызовите метод getBotSpeech, чтобы получить данные о реплике бота. Если все данные определены, переберите в цикле все ответы и создайте текст комментария.'
 'Блокировать ввод текста при использовании кнопок — выберите Да, если хотите заблокировать клиенту возможность ввода текстовых сообщений, когда используете кнопки в сценарии. Разрешить пользователям отправлять файлы — в чате появится кнопка , с помощью которой можно будет отправлять файлы боту. Подсказка в поле ввода — фраза, которая будет отображаться в поле ввода до момента, когда пользователь начинает вводить текст сообщения. Расположение На десктопе — положение виджета на экране десктопа: отступ от правого края экрана или отступ от нижнего края экрана в пикселях. Вы можете увидеть изменения сразу же на экране и отрегулировать наиболее подходящее для вас расположение виджета. На мобильном — положение виджета на экране мобильного устройства: слева или справа. Вовлечение в диалог Всплывающее сообщение — сообщение бота, которое будет всплывать в диалоге при наступлении настроенных событий. Открыть окно чата по наступлению условия — выбор условия открытия чата: время, проведенное пользователем на сайте или на странице. Приветствие в окне чата — выбор сообщения бота, которое появится в чате после открытия окна. Сессия начнется после первого сообщения пользователя. Показать кнопки меню — при включенном параметре вы сможете добавить в чат-виджет до 8 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут.'
 'Базовые элементы паттернов \\* \\* — любые символы в любом количестве. Использование в сценарии слово слово — слово: проверяет наличие последовательности указанных символов. Если клиент введет дополнительные символы (слова), его ответ не будет соотнесен с паттерном. Использование в сценарии Если клиент отправит или скажет боту Бот, привет, то его ответ не будет соотнесен с паттерном привет. корень \\*корень\\* — стемма: проверяет наличие в слове заданного текста. Звёздочки могут находиться: В начале, обозначает вариативный префикс: в паттерн \\*ход попадут слова вход, выход, ход. В конце, обозначает вариативный суффикс: в паттерн ход\\* попадут слова ходить, ходунки, ход. В начале и конце, обозначает вариативные префикс и суффикс: в паттерн \\*ход\\* попадут слова выходить, ход. Использование в сценарии (слово1|слово2|или целая фраза) (слово1|слово2|или целая фраза) — альтернативы: проверяет наличие одного из вариантов правила. Варианты разделяются |. Внутри каждого из них могут содержаться любые другие вложенные элементы паттерна. Варианты также можно разделять символом /. Использование в сценарии опциональное слово|или другая фраза \\[опциональное слово|или другая фраза] — опции: приведенные в квадратных скобках элементы не являются обязательными. У паттерна увеличивается вес, если правило сработало. Внутри опций можно использовать альтернативы.'
 'После бот продолжит реагировать согласно прописанному сценарию. В нашем случае он выведет кнопки «статус заказа» и «помощь». Когда пользователь нажмет на одну из них, бот пойдет по предусмотренному пути сценария. В тестовом виджете это будет выглядеть так: В канале Telegram это будет выглядеть так: Нажатие кнопки или набор текста? Как вы можете видеть на скриншотах выше, нажатие кнопки в диалоге выглядит так, как будто пользователь набрал слово «цены». Действительно, нажатие пользователем кнопки «цены» и ввод слова «цены» с клавиатуры являются равнозначными для бота. Если пользователь нажимает кнопку «цены», результат получается точно такой же, как если бы пользователь написал слово «цены» самостоятельно: Пользователь набирает точно такой же текст, который содержится в кнопке: Поведение бота в этих двух случаях будет одинаковым. В связи с этим удобно использовать в сочетании с кнопками блок Интенты. На самом деле, мы рекомендуем использовать блок Интенты в сочетании с кнопками, чтобы, если пользователь введет текст, не совпадающий ни с одной из кнопок, бот знал, как реагировать. Как сочетать использование кнопок и интентов? Для лучшего распознавания введенного пользователем текста рекомендуется совместно с кнопками всегда использовать на экранах блок Интенты. Иначе бот может отвечать Извините, непонятно в ответ на ввод того, чего нет в кнопках. Добавьте на экран с кнопками блок Интенты. Теперь в блок Интенты добавьте интенты с текстом, который содержится в ваших кнопках.'
 'Если его не будет, то при запуске бот найдет состояние, реагирующее на любой текстовый ввод, либо выведет ошибку обработки запроса. Клиент вводит сообщение Привет или Пока и получает соответствующий ответ от бота Привет привет или Пока пока. Глобальный тег intent! позволяет осуществить переход диалога в данный стейт из любого другого стейта. Например, клиент ввёл сообщение Пока, запрос попадет в стейт Bye, так как был активирован интент /пока. Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение клиента не подходит ни под один описанный стейт. При вводе клиентом сообщения, например Как дела?, активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Бот посылает сообщение Я не понял. Вы сказали: Как дела?. Подробнее ознакомьтесь с тегами в разделе DSL. Теперь перейдем к тестированию бота и созданию канала.']"	"Бот активирует состояния ""Привет"" и ""Пока"" при получении соответствующих сообщений от клиента."	['На сообщения Привет и Пока бот будет отвечать Привет привет и Пока пока.\nТекущий сценарий бота содержит в себе два простых интента /привет и /пока.\nТаким образом, бот будет определять намерение клиента и переходить в соответствующий стейт.\nКлиент вводит сообщение Привет или Пока и получает соответствующий ответ от бота Привет привет или Пока пока.']	0.930801999236104	0.09999999999	1.0
Какое действие позволяет боту запросить число у пользователя в указанном диапазоне и сохранить его в переменную, если оно используется в сценарии?	"['Метод возвращает целочисленные значения от 0 до max(не включая max), поэтому в качестве параметра укажем 100 и прибавим к получившемуся случайному значению 1. Запишем в тег script команду: В JS API переменная $session является объектом для сохранения сессионных данных. Присвоим переменной $session.number функцию случайного выбора числа. В дальнейшем будем сравнивать число, хранящееся в $session.number, с числом, введенным пользователем. Чтобы убедиться, что бот действительно загадывает числа в случайном порядке, выведем загаданное число на экран в виде сообщения Загадано \\*число\\*. Вставьте в скрипт следующую строку: Переходы по стейтам Переход в другой стейт осуществляется посредством вызова метода $reactions.transition. В параметре указывается путь к стейту /Проверка. Подробнее ознакомьтесь с использованием встроенных сервисов $jsapi и видах переменных в JS API Проверка Настройка интента Перейдите на вкладку CAILA > Интенты, расположенную в боковом меню. Создайте интент /Число и добавьте в поле Тренировочные фразы фразу @duckling.number, чтобы бот мог распознать введенное пользователем число и сохранить его. Интент число Выполнение условия Переменная $parseTree.\\_Number представляет собой число, которое ввел пользователь. Создадим отдельную переменную num. Присвоим ей значение, полученное в стейте Согласие из слота Number. Далее с помощью условного оператора if/else сравниваем загаданное значение с введенным. Если числа равны, то бот выдаст сообщение Ты выиграл!'
 'Если число попадает в диапазон Если число меньше 100 и больше 1, то выражения в нашем блоке Условия не будут выполняться и бот пойдет по else. От else создадим новый блок Условия, в котором напишем: $num &lt; $NUMBER $num > $NUMBER Назовем этот экран: сравнение с загаданным числом В этом блоке условий мы сравниваем число, которое загадал бот (мы записали его в переменную $num с помощью блока HTTP-запрос) с числом, которое загадал пользователь (это число записано в $NUMBER). Вот что у нас получилось: Если число меньше Кликните на строчку $num &lt; $NUMBER и создайте блок Текст: Мое число меньше! Попробуй еще раз. Назовем этот экран: меньше Добавим на экран ""меньше"" блок Переход и свяжем его с экраном ""прием ввода"". Если число больше От условия $num > $NUMBER создайте блок Текст: Мое число больше! Попробуй еще раз. Назовем этот экран: больше Добавим на экран ""больше"" блок Переход и свяжем его с экраном ""прием ввода"". Если введенное пользователем число равно загаданному ботом числу Если пользователь угадал, то число будет не больше и не меньше, значит, бот пойдет по else. Нажмите на else экрана ""сравнение с загаданным числом"" и создайте блок Текст: Правильно! Я загадал $num! Назовем этот блок: угадал Сыграем еще? Добавим на экран ""угадал"" блок Переход. От этого блока Переход создадим новый блок Текст: Сыграем еще раз? Назовем этот экран: сыграем еще? Добавим на экран ""сыграем еще"" готовые интенты Согласие, Отказ, Прощание. Свяжем интент Согласие с экраном ""запрос"".'
 'От варианта Завершен успешно создайте блок Условия. Делаем условие $items.next(), которое возьмет вопрос из массива $items Назовем этот экран ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС От экрана ""ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС"" делаем связь на экран ""ВЫВОДИМ ВОПРОС"": Добавляем действие на случай, если есть история о пользователе Теперь нужно сделать так, чтобы на следующей сессии (например, при следующем запуске навыка в Алисе) мы узнавали пользователей и возвращали их на то место, где они остановились в последний раз. Вернемся в начало сценария. На экране ""ЕСТЬ ЛИ ИСТОРИЯ?"" от варианта Завершен успешно создайте новый блок Текст: С возвращением! В прошлый раз мы дошли до уровня $history.level. Твой счет: $history.score. Продолжим? Назовем этот экран ЕСЛИ ЕСТЬ ИСТОРИЯ Добавим на экран ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" блок Интенты. Добавим варианты реакций пользователя - готовые интенты Согласие и Отказ: :size=200 :size=200 Получаем неотвеченные вопросы От интента Отказ экрана ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" создадим блок http-запрос. Здесь нам снова нужно получить данные из Google Таблицы, как обычно. метод GET URL может быть таким же, как в блоке HTTP-запрос ""Получаем вопрос"" :size=200 :size=200 на вкладке RESPONSE нажмите на + и в поле Имя переменной вставьте: items, а в поле Значение вставьте: $httpResponse.slice(parseInt($history.level)) Давайте разберемся, что значит это выражение в блоке Значение: slice - возвращает новый массив, содержащий копию части исходного массива, parseInt - преобразует строку в число.'
 'InputNumber Действие InputNumber позволяет боту запросить у пользователя число в указанном диапазоне и сохранить его в переменную. Параметры Использование в сценарии'
 '$dialer.bargeInInterrupt Метод позволяет задать поведение бота при перебивании по условию. Метод работает корректно только в обработчике события перебивания по условию — bargeInIntent. Синтаксис Метод принимает в качестве аргумента значение логического типа — true или false. Передача true означает, что условие перебивания выполнено. После того как обработчик события bargeInIntent завершит выполнение, бот прервется, чтобы обработать поступивший запрос. Если передано значение false, условие перебивания не выполнено. Бот не прервется и обработает поступивший запрос после того, как закончит выполнение реакций в текущем стейте. Отсутствие вызова $dialer.bargeInInterrupt в обработчике события bargeInIntent равносильно вызову метода со значением false. Использование в сценарии Метод используется совместно с методом $dialer.getBargeInIntentStatus, чтобы задать поведение в случае, если клиент пытается перебить бота. Если клиент произносит осмысленную фразу, явно передающую его намерение, в обработчике вызывается метод $dialer.bargeInInterrupt с аргументом true, чтобы бот прервался. В противном случае попытка перебить бота игнорируется — обработка запроса происходит лишь после того, как бот закончит ответ.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.'
 'Присвоение значений нескольким переменным Для того чтобы в одной строке создать и присвоить значения нескольким переменным, нужно каждую операцию присвоения заключить в скобки и поставить && между операциями. Если не заключать каждую операцию в скобки, бот выдаст ошибку. В результате выполнения данного условия бот создаст три переменные: $color1, $color2 и $color3. Осуществление нескольких математических операций Для того чтобы в одной строке выполнить несколько математических операций, необходимо каждую операцию заключить в скобки и между ними поставить &&. Предположим, на предыдущем шаге мы присвоили числовые значения переменным $num1 и $num2. Чтобы в одной строке узнать и сумму, и разность этих чисел, выполним эти операции в новых переменных при помощи выражения: Если не заключать каждую операцию в скобки, бот выдаст ошибку. В результате выполнения условия бот поместит сумму переменных $num1 и $num2 в переменную $num3, а их разность — в переменную $num4. Условный оператор JavaScript Условный (тернарный) оператор JavaScript является единственным оператором JavaScript, который использует три операнда. Оператор принимает одно из двух значений в зависимости от заданного условия. Синтаксис оператора: Например, в уроке о получении имени клиента используется следующее выражение: В данном условии мы присваиваем значение переменной $name с помощью оператора присвоения =. Если у нас есть переменная $NAME, то в $name будет записано значение $NAME.name.'
 'В Aimylogic мы пишем переменные используя $, а затем имя переменной. Регистр имеет значение - переменные $number и $NUMBER - это разные переменные. | Подробнее о переменных читайте здесь. На вкладке RESPONSE нажмите +. Скопируйте и вставьте в поля: Имя переменной: num В поле Значение скопируйте и вставьте: parseInt($httpResponse) Что здесь происходит? После HTTP запроса Aimylogic сохраняет ответ сервиса random.org в системную переменную $httpResponse. Но сервис random.org возвращает текст, а нам нужно целое число, чтобы мы могли сравнивать с ним число пользователя (строка и число - разные типы данных в Javascript). Поэтому нам нужно сначала преобразовать текстовый ответ сервиса в целое число. Для этого в Javascript есть функция parseInt, которой мы и воспользуемся. Передадим в функцию parseInt весь ответ от сервиса - так мы преобразуем строку в число. Затем мы записываем это значение в переменную, которую указали в поле ?? и сохраним его в переменную $num. Поля BODY и HEADERS заполнять не нужно. Нажмите Сохранить Назовем этот экран: запрос А теперь угадывай! Бот получил случайное число. Теперь бот должен вывести пользователю сообщение о том, что число загадано, и пригласить пользователя угадать число. Кликните на вариант Завершен успешно блока HTTP-запрос и создайте блок Текст. В нем напишите: Я загадал число от 1 до 100. Угадай, какое!'
 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.'
 '&lt;random> Описание Задает числа, которые будут возвращаться функцией random в JS API. Тег обязателен, если функция $jsapi.random вызывается в сценарии. Если его нет, функция будет возвращать 0. В случае, если в сценарии будет запрошено больше случайных чисел, чем определено в теге &lt;random>, то функция $jsapi.random будет возвращать 0. Если в запросе к боту не определено поле smartRandom, то $jsapi.random используется для получения случайных чисел при вызове $reactions.random. Повторяющиеся числа при этом игнорируются. $reactions.random так же используется при выборе варианта в теге random в сценариях. Все сгенерированные в ходе выполнения теста случайные числа записываются в response. Тело Список чисел, разделенных символом ,. Примеры Рассмотрим сценарий: Тест для сценария: Здесь: (1) $jsapi.random возвращает 1, возвращается ответ с индексом 1. (2) $jsapi.random возвращает 2, возвращается ответ с индексом 2. (0) $jsapi.random возвращает 0, так как закончились числа, определенные в теге &lt;random>, возвращается ответ с индексом 0.']"	Действие, которое позволяет боту запросить число у пользователя в указанном диапазоне и сохранить его в переменную, называется InputNumber.	['- Действие InputNumber позволяет боту запросить у пользователя число в указанном диапазоне и сохранить его в переменную.\n- Использование в сценарии.']	0.9744821414631488	0.6249999999791667	0.5
Какие данные бот может использовать из ввода пользователя в Aimylogic?	"['Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.'
 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.'
 'База данных В Aimylogic вы можете сохранять, читать и удалять любые данные, привязанные к пользователю бота. Запись данных Чтобы записать данные в базу данных: Создайте в сценарии блок HTTP-запрос. Выберите метод POST. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} Во вкладке BODY HTTP-запроса нужно указать JSON-объект, в котором вы можете указать любые данные, которые хотите сохранить. Например: { ""var1"": ""value"", ""var2"": 100, ""var3"": \\[1,2,3]} Вкладки RESPONSE и HEADERS заполнять не нужно. Пример HTTP-запроса Чтение данных Чтобы прочитать данные из базы данных: Создайте в сценарии блок HTTP-запрос. Выберите метод GET. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} На вкладке RESPONSE напишите название переменной, в которую вы будете записывать данные, и в поле значение пропишите нужное значение, например,$httpResponse. Вкладки BODY и HEADERS заполнять не нужно. Если никаких данных для этого пользователя найдено не будет, то запрос вернется с ошибкой 404. А если данные будут найдены, то в переменную $httpResponse будет записан тот объект, который ранее был сохранен в базу данных. Удаление данных Чтобы удалить все данные для текущего пользователя: Создайте в сценарии блок HTTP-запрос. Выберите метод DELETE. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} Вкладки RESPONSE, BODY и HEADERS заполнять не нужно.'
 'Поэтому вам не обязательно перечислять все возможные сочетания и синонимы при обучении бота. Однако, для более точной настройки вы можете использовать синтаксис шаблонов. Как получить данные из ввода пользователя Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту). Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони. Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос. Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах. В Aimylogic есть системные сущности, а также возможность создавать свои собственные. Подробнее о работе с сущностями можно прочитать в статье Сущности. Кнопки Совместно с интентами, для упрощения диалога с пользователем, вы можете использовать кнопки. Даже если вы используете кнопки на экране, рекомендуется также помещать на экран блок Интенты, чтобы бот понимал, что делать, если пользователь что-то напишет, а не нажмет кнопку. Подробно об использовании кнопок описано в этой статье.'
 'require Описание require — тег служит для загрузки зависимых файлов и, по сути, является альтернативой указанию всех зависимых файлов в chatbot.yaml. Тип значения string — задает имя подключаемого файла Параметры type (string) — опциональный параметр, определяет тип файла; по умолчанию определяется из расширения. from (string) — имя модуля, из которого импортируется файл; версия и репозиторий модуля указываются в chatbot.yml. rootTheme (string) — базовая тема для всех состояний, определенных в подключаемом файле. provide (multiline json) — набор параметров, передаваемый подключаемому модулю. name (string) — имя паттерна для справочников сущностей. var (string) — определяет имя js-переменной с данными из справочника. injector (string) — через объект $injector в скрипт могут передаваться метапараметры. module (string) — имя модуля, из которого загружается файл. Имя модуля либо задается в секции dependecies конфигурационного файла chatbot.yaml, либо соответствует имени папки в папке системных модулях. Подробнее о работе с module Вложенные данные named parametrs Примеры использования параметр varName; параметры from, rootTheme, provide; параметры type, patternName; параметр injector; параметр module; в значениях параметров возможны подстановки.'
 'Например, если у вас есть столбец name, то в блокноте у вас получится:$rawRequest.originateData.payload.name Ниже пример таблицы и значений $rawRequest: :size=400 Системную переменную с названием нужной колонки используйте в блоке Текст: :size=400 В данном случае при звонке на номер 79105555555 бот скажет: ""Здравствуйте, Саша!"". А при звонке на номер 79995555555 бот скажет ""Здравствуйте, Алекс!"" Почему при тестировании возникает ошибка? После того, как вы используете перечисленные выше значения $rawRequest в сценарии, при тестировании в тестовом виджете вы будете получать ошибку, так как информацию из таблицы можно доставать только из телефонного канала. :size=400 Поэтому мы рекомендуем добавлять значения $rawRequest для вывода имени тогда, когда вы уже готовы запустить обзвон. Извлекать имя пользователя и другую информацию из таблицы с номерами можно только в процессе обзвона. В тестовом виджете это работать не будет. Если вы в данный момент находитесь в процессе тестирования сценария и вам нужно тестировать стороннюю функциональность, отложите использование $rawRequest до того этапа, когда сможете запускать обзвон и тестировать в телефонном канале. Примеры содержания $rawRequest В текущей таблице переменная $rawRequest содержит следующие данные: После ответа пользователя $rawRequest будет также содержать текст сообщения пользователя:'
 'Если авторизацию получает бот, для всех пользователей используются общие учетные данные.'
 'timeout — максимальное время обработки запроса в миллисекундах. По умолчанию ограничение включено со значением таймаута 10000 (10 секунд). Если запрос превысит ограничение, в сценарии возникнет событие timeLimit. XML-тесты XML-тесты сценариев позволяют проверить логику чат-бота, эмулируя запросы клиента и проверяя ответы от бота. По умолчанию выполняются все тесты из файлов в папке проекта test. Это поведение можно переопределить в секции tests, задав значения для подсекций include и/или exclude: include — будут выполнены тесты только из тех файлов, которые попадают под шаблоны, перечисленные в этой подсекции. exclude — из выполнения будут исключены все файлы, которые попадают под шаблоны, перечисленные в этой подсекции. Шаблоны используют синтаксис Apache Ant. Поле caseSensitive определяет, должны ли шаблоны учитывать регистр названий файлов. Значение по умолчанию — true. Зависимости Секция dependencies позволяет задать список зависимостей проекта. Подробнее о зависимостях Теги действий Секция customTags задает список самостоятельно созданных тегов действий, которые используются в проекте. Пользовательские реакции Секция customBlocks задает список пользовательских реакций, которые используются в рассылках. Сообщения об ошибках Секция messages.onError позволяет задать текст сообщения, которое бот отправит при возникновении какой-либо ошибки. В подсекции locales могут быть заданы тексты сообщений, локализованные исходя из данных о пользователе.'
 '$caila Встроенный сервис $caila позволяет обращаться к CAILA API из сценария бота. NLU Следующие методы предоставляют доступ к возможностям CAILA для понимания и обработки естественного языка, таким как распознавание интентов и сущностей, операции словоизменения, определение языка. Передача API-ключа Для большинства перечисленных методов также предусмотрены аналогичные методы с суффиксом WithToken: markupWithToken, entitiesLookupWithToken и т. д. Эти методы работают так же, как основные, но принимают в качестве дополнительного последнего аргумента API-ключ CAILA. Используйте методы с суффиксом WithToken, когда бот и обученный классификатор для него расположены в разных проектах. В таком случае необходимо явно передавать API-ключ классификатора, к которому нужно обращаться. Клиентские сущности Клиентские сущности — сущности, которые клиент может персонализировать во время диалога с ботом. Содержимое таких сущностей для каждого клиента уникально и недоступно другим клиентам. Подробнее о клиентских сущностях Следующие методы позволяют управлять содержимым клиентских сущностей из сценария.'
 'Сущности Сущность — это часть пользовательского запроса, которую можно выделить из фразы в виде каких-либо языконезависимых данных. Дата и время, Число, Номер телефона, Название города — все это примеры сущностей, которые Aimylogic может автоматически обнаружить во фразе клиента. Всякий раз, когда бот должен выделить из фразы важные данные, используйте сущности. Какие есть сущности в Aimylogic В Aimylogic есть как системные сущности, доступные «из коробки», так и пользовательские сущности, которые вы можете добавить самостоятельно. Как работают сущности Когда бот анализирует фразу клиента, он пытается распознать в ней сущности. Как только сущность найдена, бот создает переменную и называет ее именем сущности, а затем сохраняет в нее значение, полученное от клиента. Предположим, в примере или шаблоне фразы вы указали, что во фразе клиента должно присутствовать число. В Aimylogic есть системная сущность $NUMBER, при помощи которой можно распознавать числа. Если клиент напишет боту фразу, в которой присутствует число, бот сможет распознать в числе сущность $NUMBER, даже если клиент напишет число словами, а не цифрами. После этого созданную переменную можно использовать в сценарии бота так же, как и любую другую. Например, добавлять ее в условия или передавать в HTTP-запросе. Как указать сущность во фразе Чтобы бот смог выделить сущность из фразы, ее нужно указать в примере или шаблоне фразы в блоке Интенты.']"	"Бот в Aimylogic может использовать следующие данные из ввода пользователя:

1. Данные из системных переменных:
- $bitrix.user.id – ID клиента в CRM системе Битрикс24.
- $bitrix.user.name – имя клиента в CRM системе Битрикс24.
- $bitrix.params.dialogId — ID диалога.
- $bitrix.params.fromUserId— ID отправителя.
- $bitrix.params.toUserId — ID получателя.
- $bitrix.params.chatId — ID чата.
- $bitrix.params.messageId — ID сообщения.
- $bitrix.params.message — сообщение.
- $bitrix.params.messageType — тип сообщения.
- $bitrix.params.chatType — тип чата.
- $bitrix.params.authorId — ID владельца чата.
- $bitrix.params.chatEntityType — внешний код для чата.
- $bitrix.params.chatEntityData1 — внешние данные для чата.
- $bitrix.params.chatEntityData2 — внешние данные для чата.
- $bitrix.params.chatEntityData3 — внешние данные для чата.
- $bitrix.params.language — язык чата.

2. Данные из клиентских сущностей:
- Клиентские сущности позволяют выделять из фразы клиента языконезависимые данные. Например, дату и время, числа, номера телефонов и другие.

3. Данные из сущностей, определенных в сценарии:
- В Aimylogic есть системные сущности, такие как $NUMBER, которые могут быть использованы для распознавания чисел.
- Также можно создать свои собственные сущности и использовать их в сценарии.

4. Данные из введенного пользователем текста:
- Бот может автоматически выделить из введенного пользователем текста некоторые важные данные, такие как дату и время, и использовать их в дальнейшем.

Все эти данные можно использовать в сценарии бота для реакций, вычислений или передачи во внешние системы."	['- Это значит, что бот, созданный на Aimylogic, может не только реагировать на заранее заложенные фразы, но и извлекать из фраз пользователя различные данные, а также воспринимать синонимы.\n- Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту).\n- Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони.\n- Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос.\n- Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах.']	0.9880286846839073	0.474999999988125	0.7142857142857143
Какие атрибуты можно использовать с тегом &lt;style>, чтобы изменить манеру (стиль) речи диктора на воодушевленный?	"['Вы также можете обозначить словесное ударение специальным символом + после ударной гласной. interpret-as — задает формат прочтения слова. Возможные значения: format — определяет формат даты. Его нужно указывать, если для атрибута interpret-as задано значение date. Возможные значения: &lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально. Для всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный. Для любого голоса вы также можете сгенерировать свои уникальные наборы стилей. Многие дикторы умеют ярко выражать свои эмоции, но некоторые читают тексты в однотипной сдержанной манере. Поэтому эффект от применения тега style зависит от выбранного голоса и иногда может быть неотличим от стиля по умолчанию. Основные стили Чтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name. Возможные значения: exilant — в голосе появится больше энергии, воодушевления. irate — голос приобретет оттенки раздраженности. depressive — голос станет подавленным, грустным. В варианте с атрибутом name тег style используется как парный тег. Основные стили могут быть применены ко всему тексту, его части или отдельному слову. Случайные стили В Aimyvoice вы также можете использовать случайные стили. Их особенности генерируются случайным образом в зависимости от подобранного числа — идентификатора стиля.'
 'Иначе стиль будет каждый раз звучать по-разному. rhythm — логическое значение 0 или 1. Указывает на то, что ритм целевого голоса будет изменен. Значение по умолчанию — 1. pitch — логическое значение 0 или 1. Указывает на то, что тон целевого голоса будет изменен. Значение по умолчанию — 1. При использовании атрибута mimic_voice тег style является непарным и применяется, только если стоит в начале текста. Стиль распространяется на весь текст целиком. Наложение стилей можно использовать совместно со случайными стилями. &lt;sub> Заменяет звучание слова на другое. Например, вы можете использовать этот тег, чтобы: Передать более привычное звучание: «что» — «што». Указать правильное произнесение единицы измерения: «м/c» — «метров в секунду». Укажите желаемое звучание в атрибуте alias.'
 'Поэтому вам не обязательно перечислять все возможные сочетания и синонимы при обучении бота. Однако, для более точной настройки вы можете использовать синтаксис шаблонов. Как получить данные из ввода пользователя Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту). Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони. Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос. Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах. В Aimylogic есть системные сущности, а также возможность создавать свои собственные. Подробнее о работе с сущностями можно прочитать в статье Сущности. Кнопки Совместно с интентами, для упрощения диалога с пользователем, вы можете использовать кнопки. Даже если вы используете кнопки на экране, рекомендуется также помещать на экран блок Интенты, чтобы бот понимал, что делать, если пользователь что-то напишет, а не нажмет кнопку. Подробно об использовании кнопок описано в этой статье.'
 '$reactions.ttsWithVariables Метод задает аудио и шаблон текста для синтеза речи с переменным на базе технологии Yandex SpeechKit Brand Voice Adaptive. В настройках телефонного канала должны быть активны переключатели Включить Yandex v3 и Использовать переменные. В противном случае вызов метода приведет к ошибке. Синтаксис Метод принимает объект с полями audioTemplate и textTemplate. audioTemplate audioTemplate — описание аудио, в которое будет вставлена переменная. Содержит поля: audio — ссылка на аудиофайл с шаблоном фразы. Файл должен быть публично доступен по протоколу httpS и удовлетворять требованиям, предъявляемым к аудиозаписям. textTemplate — описание расшифровки аудиофайла: template — текст шаблона. Переменные должны быть обозначены соответствующими именами в фигурных скобках. textVariables — массив объектов, описывающих использованные переменные. Каждый объект содержит поля: name — название переменной. value — расшифровка переменной, использованной в шаблоне. audioVariables — массив объектов, описывающих расположение переменных в аудиозаписи. Каждый объект содержит поля: name — название переменной. startMs — время от начала аудиозаписи до начала воспроизведения переменной в миллисекундах. lengthMs — длительность воспроизведения переменной в миллисекундах. textTemplate textTemplate — описание фразы, которую должен синтезировать бот в диалоге с клиентом. Содержит поля: template — текст шаблона.'
 '$dialer.getBotSpeech Метод возвращает данные о воспроизведении реплики бота в телефонном канале. Синтаксис Метод вызывается без аргументов: Возвращаемое значение Метод возвращает массив объектов со свойствами: Формат объекта с репликой Объект с репликой бота reply содержит свойства со строковым типом. Если ответ отправлен через: Tег a, метод $reactions.answer или ответ с типом text, объект будет содержать свойства text и ssml — текст реплики и текст с разметкой синтеза речи, если она используется. Tег audio, метод $reactions.audio или ответ с типом audio, объект будет содержать свойство audioSrc — ссылку на аудиофайл audioSrc. Метод $reactions.ttsWithVariables, объект будет содержать свойства text — текст реплики, template — текст шаблона для синтеза речи, audio — ссылку на аудиофайл с шаблоном реплики. Пример возвращаемого значения Использование в сценарии Допустим, во время звонка бот информирует о текущих промоакциях. Он произносит текстовую реплику из тега a и затем воспроизводит запись диктора из тега audio. Чтобы записать информацию о воспроизведении реплики в комментарий в аналитику: Вызовите метод getBotSpeech, чтобы получить данные о реплике бота. Если все данные определены, переберите в цикле все ответы и создайте текст комментария.'
 'Бот-лидогенератор для онлайн-школы В данном уроке вы создадите бота, который будет предлагать клиентам записаться на пробный урок в онлайн-школу английского языка. Если клиент согласится, бот уточнит его данные и время записи, а затем отправит полученную информацию в Google Таблицу. Приветствие Перейдите на главную страницу Aimylogic и нажмите Создать бота. В первую очередь бот должен поздороваться с клиентом. Для этого добавьте новый экран с блоком Текст и укажите приветственную реплику, например: Добро пожаловать в школу английского языка “High Five”! Я могу рассказать вам о часах работы и расписании уроков, а также записать на первое занятие. Чем я могу вам помочь? Приветственная реплика Прием реакции клиента Чтобы клиент мог отреагировать на сообщение бота, нужно добавить в сценарий кнопки и интенты. Интент определяет, чего хочет клиент, и направляет его по нужной ветке сценария. Кнопки Кнопки позволяют связать два экрана. Вам потребуется добавить несколько кнопок: Нажмите Кнопка и введите текст для кнопки — например, Часы работы. Таким же образом добавьте другие кнопки — Запись и Расписание. К кнопке Расписание добавьте ссылку на сайт с информацией о расписании. Прикрепить ссылку можно к любой кнопке. Для этого наведите курсор на кнопку, нажмите и укажите URL. Добавление кнопок Интенты Интенты позволяют боту распознавать определенные фразы клиента. Чтобы добавить интент, нажмите Блок → Сделать свой интент. Вы можете заполнить интент примерами и шаблонами фраз.'
 'Как обучать интенты Через интенты доступны два способа обучить бота понимать естественный язык: Паттерны — формальные правила для сопоставления запросов специальным шаблонам. Например, {\\[~ты/~вы] (~любить/нравится) \\* (спб/питер\\*/\\[санкт] \\*петербург\\*)} — паттерн, совпадение по которому с высокой вероятностью означает, что бота спрашивают об отношении к Санкт-Петербургу. Тренировочные фразы — примеры запросов для обучения классификатора. Например, научить бота распознавать тот же интент можно на таких тренировочных фразах: тебе нравится в спб, ты любишь питер, как ты относишься к санкт-петербургу. По сравнению с паттернами тренировочные фразы позволяют значительно уменьшить трудозатраты на обучение: не нужно вручную писать правила и пытаться учесть в них все возможные синонимы. Фразы можно добавить в классификатор из внешних файлов с логами, а также разметить фразы прямо из аналитики по диалогам уже после того, как бот был запущен. С другой стороны, из-за меньшей прозрачности алгоритмов, не основанных на правилах, тренировочные фразы могут быть менее предсказуемы. Если вы используете их для обучения, следует учитывать особенности выбранного классификатора и придерживаться некоторых правил при составлении обучающей выборки. Если у вас есть свои данные для обучения, но вы не хотите готовить их вручную, воспользуйтесь встроенным в CAILA инструментом разметки логов. Через него вы можете очистить выборку, автоматически сгруппировать фразы и сразу же добавить их в интенты.'
 '$imputer.generateAudioUrl Метод $imputer.generateAudioUrl возвращает URL реплики с переданными значениями переменных. За основу JAICP берет шаблон реплики из списка в разделе Гибридный синтез речи. Подробнее о том, как добавить шаблон реплики Чтобы воспроизвести в сценарии аудио по полученному URL, используйте тег audio. Синтаксис Принимаемые аргументы Метод $imputer.generateAudioUrl принимает аргументы: Возвращаемое значение Метод возвращает URL реплики с указанными значениями переменных и заданной скоростью. Примеры вызова Пример использования Например, для шаблона реплики {name: Алексей Викторович}, вы записаны завтра на {serviceName: диагностику двигателя}. Подтверждаете запись? с идентификатором confirmation вызов метода может выглядеть следующим образом: В этом примере реплика без переменных helloPhrase также была использована в сценарии при помощи вызова метода $imputer.generateAudioUrl. Это было сделано, чтобы избежать разницы в звучании реплик: c переменными и без. Подробнее см. в разделе Гибридный синтез от Just AI.'
 'Случайные стили существуют только в рамках конкретной версии голоса. При обновлении голосов найденные стили поменяются, и вам придется заново искать подходящие варианты. Поэтому не рекомендуется использовать случайные стили в долгосрочных проектах. Чтобы использовать случайные стили, примените к тегу &lt;style> атрибуты: id — идентификатор стиля, целое число в диапазоне от 0 до 999999999. При одном и том же значении атрибута особенности стиля будут сохранены. sigma — целое или дробное число от 0 до 4. Усиливает или ослабляет выраженность (интенсивность) случайного стиля. Значение по умолчанию — 1. Большие значения sigma могут приводить к появлению артефактов в звуке или неверному произношению текста. При использовании атрибута id тег style является непарным и применяется, только если стоит в начале текста. Стиль распространяется на весь текст целиком. Найденный стиль может быть применен к любому другому голосу с похожим эффектом. Наложение стилей Aimyvoice позволяет копировать манеру речи определенного диктора, комбинируя речевые особенности разных голосов. При копировании у голоса меняется ритмика и основной тон, но не тембр. Чтобы комбинировать стили, используйте следующие атрибуты тега &lt;style>: mimic_voice — имя диктора из каталога (например, Маруся) или random — тогда диктор будет выбран случайно. При указании значения random следует всегда использовать атрибут id — идентификатор стиля, целое число в диапазоне от 0 до 999999999.'
 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.']"	"Атрибуты, которые можно использовать с тегом &lt;style> для изменения манеры (стиля) речи диктора на воодушевленный, это:
- name со значением exilant"	['&lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально.\nДля всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный.\nЧтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name. Возможные значения: exilant — в голосе появится больше энергии, воодушевления. irate — голос приобретет оттенки раздраженности. depressive — голос станет подавленным, грустным.']	0.9918285597439024	0.6111111110805556	0.5
Какие атрибуты можно использовать с тегом &lt;style>, чтобы изменить манеру (стиль) речи диктора на спокойный?	"['Вы также можете обозначить словесное ударение специальным символом + после ударной гласной. interpret-as — задает формат прочтения слова. Возможные значения: format — определяет формат даты. Его нужно указывать, если для атрибута interpret-as задано значение date. Возможные значения: &lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально. Для всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный. Для любого голоса вы также можете сгенерировать свои уникальные наборы стилей. Многие дикторы умеют ярко выражать свои эмоции, но некоторые читают тексты в однотипной сдержанной манере. Поэтому эффект от применения тега style зависит от выбранного голоса и иногда может быть неотличим от стиля по умолчанию. Основные стили Чтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name. Возможные значения: exilant — в голосе появится больше энергии, воодушевления. irate — голос приобретет оттенки раздраженности. depressive — голос станет подавленным, грустным. В варианте с атрибутом name тег style используется как парный тег. Основные стили могут быть применены ко всему тексту, его части или отдельному слову. Случайные стили В Aimyvoice вы также можете использовать случайные стили. Их особенности генерируются случайным образом в зависимости от подобранного числа — идентификатора стиля.'
 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.'
 'Случайные стили существуют только в рамках конкретной версии голоса. При обновлении голосов найденные стили поменяются, и вам придется заново искать подходящие варианты. Поэтому не рекомендуется использовать случайные стили в долгосрочных проектах. Чтобы использовать случайные стили, примените к тегу &lt;style> атрибуты: id — идентификатор стиля, целое число в диапазоне от 0 до 999999999. При одном и том же значении атрибута особенности стиля будут сохранены. sigma — целое или дробное число от 0 до 4. Усиливает или ослабляет выраженность (интенсивность) случайного стиля. Значение по умолчанию — 1. Большие значения sigma могут приводить к появлению артефактов в звуке или неверному произношению текста. При использовании атрибута id тег style является непарным и применяется, только если стоит в начале текста. Стиль распространяется на весь текст целиком. Найденный стиль может быть применен к любому другому голосу с похожим эффектом. Наложение стилей Aimyvoice позволяет копировать манеру речи определенного диктора, комбинируя речевые особенности разных голосов. При копировании у голоса меняется ритмика и основной тон, но не тембр. Чтобы комбинировать стили, используйте следующие атрибуты тега &lt;style>: mimic_voice — имя диктора из каталога (например, Маруся) или random — тогда диктор будет выбран случайно. При указании значения random следует всегда использовать атрибут id — идентификатор стиля, целое число в диапазоне от 0 до 999999999.'
 'В данной подсекции ключи представляют собой ISO-коды языков, а значения — тексты сообщений. В поле defaultMessage указывается текст сообщения по умолчанию, которое отправляется в случае, если секция locales не задана или в ней не задан нужный язык. Также можно задать список сообщений по умолчанию в поле defaultMessages — тогда при ответе будет выбрано случайное из них. Если секция messages.onError не заполнена, то в случае возникновения ошибки бот не ответит клиенту. Для настройки более гибкого поведения при внештатных ситуациях используйте обработчики ошибок. Injector Секция injector позволяет задать параметры конфигурации чат-бота. Заданные параметры будут доступны в скриптах чат-бота через переменную $injector. Подробнее об $injector Настройки SMTP-сервера Секция injector.smtp позволяет задать настройки SMTP-сервера, через который будут отправляться email-сообщений при помощи метода $mail.sendMessage. Другие настройки Возможность изменения запроса Поле nlp.modifyRequestInPreMatch включает возможность изменять содержимое запроса в обработчике preMatch — например, редактировать текст запроса. Токенизация слов в паттернах Поле tokenizeWordsInPatterns включает токенизацию слов в паттернах для языков без разделителей между словами. Поле обязательно для корректной работы паттернов в проектах на китайском языке. Порядок загрузки файлов Поле scenarioLoadStrategy задает порядок загрузки файлов в сценарий, состоящий из множества файлов.'
 'Иначе стиль будет каждый раз звучать по-разному. rhythm — логическое значение 0 или 1. Указывает на то, что ритм целевого голоса будет изменен. Значение по умолчанию — 1. pitch — логическое значение 0 или 1. Указывает на то, что тон целевого голоса будет изменен. Значение по умолчанию — 1. При использовании атрибута mimic_voice тег style является непарным и применяется, только если стоит в начале текста. Стиль распространяется на весь текст целиком. Наложение стилей можно использовать совместно со случайными стилями. &lt;sub> Заменяет звучание слова на другое. Например, вы можете использовать этот тег, чтобы: Передать более привычное звучание: «что» — «што». Указать правильное произнесение единицы измерения: «м/c» — «метров в секунду». Укажите желаемое звучание в атрибуте alias.'
 '$dialer.getBotSpeech Метод возвращает данные о воспроизведении реплики бота в телефонном канале. Синтаксис Метод вызывается без аргументов: Возвращаемое значение Метод возвращает массив объектов со свойствами: Формат объекта с репликой Объект с репликой бота reply содержит свойства со строковым типом. Если ответ отправлен через: Tег a, метод $reactions.answer или ответ с типом text, объект будет содержать свойства text и ssml — текст реплики и текст с разметкой синтеза речи, если она используется. Tег audio, метод $reactions.audio или ответ с типом audio, объект будет содержать свойство audioSrc — ссылку на аудиофайл audioSrc. Метод $reactions.ttsWithVariables, объект будет содержать свойства text — текст реплики, template — текст шаблона для синтеза речи, audio — ссылку на аудиофайл с шаблоном реплики. Пример возвращаемого значения Использование в сценарии Допустим, во время звонка бот информирует о текущих промоакциях. Он произносит текстовую реплику из тега a и затем воспроизводит запись диктора из тега audio. Чтобы записать информацию о воспроизведении реплики в комментарий в аналитику: Вызовите метод getBotSpeech, чтобы получить данные о реплике бота. Если все данные определены, переберите в цикле все ответы и создайте текст комментария.'
 'useV3 Если параметр включен, для синтеза речи используется третья версия протокола Yandex SpeechKit. Обратитесь к своему аккаунт-менеджеру, если вы хотите включить этот параметр. Следующие параметры доступны, только если включен параметр useV3: volume Громкость синтезированной речи относительно цифровой полной шкалы LUFS. Принимает целое или дробное значение от -145 до 0. Рекомендуемый диапазон значений — от −20 до −16 LUFS. useVariables Если параметр включен, для синтеза используется технология Yandex SpeechKit Brand Voice Adaptive с поддержкой переменных. Azure language Язык, на котором синтезируется речь. voiceName Голос для синтеза. Полный список языков и голосов для синтеза в документации Azure. sampleRate Частота дискретизации. Aimyvoice voice Голос для синтеза. Сбер voice Голос для синтеза. Полный список голосов для синтеза в документации Сбера 3iTech model Языковая модель для синтеза речи. sampleRate Частота дискретизации. speed Скорость синтезированной речи. tone Тон голоса.'
 'Поэтому вам не обязательно перечислять все возможные сочетания и синонимы при обучении бота. Однако, для более точной настройки вы можете использовать синтаксис шаблонов. Как получить данные из ввода пользователя Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту). Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони. Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос. Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах. В Aimylogic есть системные сущности, а также возможность создавать свои собственные. Подробнее о работе с сущностями можно прочитать в статье Сущности. Кнопки Совместно с интентами, для упрощения диалога с пользователем, вы можете использовать кнопки. Даже если вы используете кнопки на экране, рекомендуется также помещать на экран блок Интенты, чтобы бот понимал, что делать, если пользователь что-то напишет, а не нажмет кнопку. Подробно об использовании кнопок описано в этой статье.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.'
 'Как обучать интенты Через интенты доступны два способа обучить бота понимать естественный язык: Паттерны — формальные правила для сопоставления запросов специальным шаблонам. Например, {\\[~ты/~вы] (~любить/нравится) \\* (спб/питер\\*/\\[санкт] \\*петербург\\*)} — паттерн, совпадение по которому с высокой вероятностью означает, что бота спрашивают об отношении к Санкт-Петербургу. Тренировочные фразы — примеры запросов для обучения классификатора. Например, научить бота распознавать тот же интент можно на таких тренировочных фразах: тебе нравится в спб, ты любишь питер, как ты относишься к санкт-петербургу. По сравнению с паттернами тренировочные фразы позволяют значительно уменьшить трудозатраты на обучение: не нужно вручную писать правила и пытаться учесть в них все возможные синонимы. Фразы можно добавить в классификатор из внешних файлов с логами, а также разметить фразы прямо из аналитики по диалогам уже после того, как бот был запущен. С другой стороны, из-за меньшей прозрачности алгоритмов, не основанных на правилах, тренировочные фразы могут быть менее предсказуемы. Если вы используете их для обучения, следует учитывать особенности выбранного классификатора и придерживаться некоторых правил при составлении обучающей выборки. Если у вас есть свои данные для обучения, но вы не хотите готовить их вручную, воспользуйтесь встроенным в CAILA инструментом разметки логов. Через него вы можете очистить выборку, автоматически сгруппировать фразы и сразу же добавить их в интенты.']"	Атрибуты, которые можно использовать с тегом &lt;style> для изменения манеры (стиля) речи диктора на спокойный, не указаны в предоставленной документации. Пожалуйста, уточните вопрос или переформулируйте его.	['&lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально.\nДля всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный.\nОсновные стили Чтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name. Возможные значения: exilant — в голосе появится больше энергии, воодушевления. irate — голос приобретет оттенки раздраженности. depressive — голос станет подавленным, грустным.']	0.9779582611560196	0.8333333332916666	0.0
Сколько попыток дозвониться было сделано в рамках первой серии?	"['Как получить городской номер телефона'
 'История всех попыток Поля с суффиксом ToPhone отражают историю всех попыток дозвониться на номер: completedAttemptsToPhone — суммарное число всех сделанных попыток дозвониться на номер. После очередной попытки дозвониться значение поля увеличивается на единицу. Значение этого поля не обнуляется. availableAttemptsToPhone — предельно допустимое число доступных попыток дозвониться на номер. Значение поля соответствует значению счетчика Максимальное количество, заданному при создании обзвона. Пример Из интерфейса JAICP создан новый обзвон, для которого настроены следующие значения счетчиков попыток: Начальное количество — 4, Максимальное количество — 8. Список клиентов для обзвона содержит один номер 79110000000. Рассмотрим возможную историю попыток дозвониться на номер: Первая серия, первая попытка — абонент не ответил на звонок. Первая серия, вторая попытка — абонент не ответил на звонок. Первая серия, третья попытка — абонент ответил. Результат вызова $dialer.getDialHistory: Абонент попросил перезвонить позже. В метод $dialer.redial передано поле maxAttempts: 3. Вторая серия, первая попытка — абонент не ответил на звонок. Вторая серия, вторая попытка — абонент ответил. Результат вызова $dialer.getDialHistory: Метод может быть использован для реализации продвинутой логики перепланирования звонков с учетом информации о том, сколько звонков уже было совершено и сколько еще осталось.'
 'Бот попробует дозвониться по каждому номеру указанное Начальное количество раз. Если в сценарии бота планируются дополнительные попытки дозвониться на номер при помощи метода $dialer.redial, то система ограничит общее число попыток — их может быть не больше, чем Максимальное количество. Начальное количество попыток по умолчанию — 1, максимум — 99. При изменении начального количества дополнительно заполните поля: Пауза между дозвонами — сколько минут пройдет от окончания предыдущей попытки дозвониться до начала следующей. Перезванивать, если звонок был менее — если разговор длился менее установленного времени в секундах, то произойдет повторная попытка дозвониться. Если произошла техническая ошибка, например по причине отсутствия связи с SIP-сервером, после каждого звонка с ошибкой время до повторной попытки будет увеличено в 2 раза, начиная со значения в 1 минуту. Попытка из счетчика Попыток дозвониться будет потрачена, только если звонок будет совершен успешно либо по достижении 9 звонков с ошибкой подряд. Запуск обзвона В поле Начать обзвон вы можете настроить время запуска обзвона: Сейчас — обзвон будет запущен сразу после создания. Запланировать на — обзвон будет запущен автоматически в указанное время. Нажмите Начать обзвон или Запланировать обзвон. Созданный обзвон отобразится в списке. Статусы обзвонов В списке обзвонов отображается их статус: Запланирована — запуск был назначен на определенное время и дату. В процессе — запуск состоялся, обзвон идет.'
 'Подробнее о планировании повторного звонка'
 '$dialer.getDialHistory Метод позволяет получить историю состоявшихся и доступных попыток дозвониться на номер. Синтаксис Метод вызывается без аргументов и возвращает объект из четырех целочисленных полей. История текущей серии попыток Если при обзвоне абонент не отвечает, бот может сделать несколько попыток дозвониться до абонента. Последовательность попыток дозвониться образует серию. Если в ходе диалога с абонентом бот планирует новый звонок при помощи метода $dialer.redial, серия попыток сбрасывается — новые попытки происходят уже в рамках новой серии. Поля completedAttempts и availableAttempts отражают историю текущей серии попыток: completedAttempts — число попыток дозвониться, сделанных в рамках текущей серии. После очередной попытки дозвониться значение поля увеличивается на единицу. Если из сценария планируется новая серия попыток, значение поля обнуляется. availableAttempts — число попыток дозвониться, доступных в текущей серии. Если номер добавлен в обзвон при помощи списка клиентов, то значение поля соответствует значению счетчика Начальное количество, заданному при создании обзвона. Если номер добавлен в обзвон при помощи запроса к Calls API с явно переданным значением поля maxAttempts, то значение availableAttempts совпадает с maxAttempts. Если из сценария бота запланирована новая серия и при вызове $dialer.redial явно передано поле maxAttempts, то значение availableAttempts также совпадает с maxAttempts.'
 '№ перезвона — порядковый номер повторного звонка на данный номер. Ячейка № перезвона будет заполнена, если звонок был запланирован из сценария при помощи метода $dialer.redial. Нумерация начинается с 1. Статус задания — статус, присвоенный звонку в момент завершения обзвона или выгрузки отчета. Причина окончания звонка — причина, по которой звонок был завершен. Например, клиент не ответил, бот положил трубку и т. д. Результат — результат звонка, проставленный при помощи метода $dialer.setCallResult. Длительность — время, затраченное на звонок. Начало звонка — дата и время начала звонка. Конец звонка — дата и время окончания звонка. Номер попытки — порядковый номер попытки дозвониться. При планировании новой серии попыток дозвониться при помощи метода $dialer.redial счетчик сбрасывается. Последняя попытка — столбец будет иметь значение да, если данная попытка является последней из всех возможных попыток дозвониться на номер. Если звонок так и не был совершен, все столбцы, кроме номера телефона, останутся пустыми. Если на звонок не было ответа, то время попытки проставляется в столбце Конец звонка. Для расширения отчета вы можете использовать метод $dialer.reportData.'
 'Отчет по попыткам Подробнее о статистике по обзвонам Далее расширим готовый сценарий некоторыми дополнительными возможностями.'
 'Затем с помощью метода $dialer.redial будет запланирован повторный звонок через час.'
 'При этом: Итого: за 5 звонков произойдет 7 списаний за использование гибридного синтеза. Отчет об использовании На странице Гибридный синтез речи вы можете скачать отчет, в котором будет информация о дате и объемах использования сервиса: В столбце Service API Calls указывается, сколько раз были вызваны методы генерации и кэширования реплик. Если вы кэшировали реплику, а затем сгенерировали ее, будет учтен только вызов метода кэширования. В столбце Test Calls указывается количество воспроизведений реплик на странице Гибридный синтез речи в блоках Тестирование переменных и Скорость.'
 'К существовавшим ранее типам обработчиков onScriptError и onAnyError мы добавили onDialogError, который обрабатывает специфические диалоговые ошибки: например, переход в несуществующий стейт. Подробнее об обработчиках ошибок Обзвоны Отчеты по обзвонам На диаграмме результатов обзвона теперь отображаются первые 8 результатов, с которыми завершилось наибольшее число звонков. Остальные результаты агрегируются в сегмент Другие результаты. Таблица под диаграммой наряду с количеством звонков различных типов отражает их процент от общего числа вызовов. История попыток дозвониться Во встроенный сервис $dialer добавлен метод getDialHistory, позволяющий получить из сценария историю состоявшихся и доступных попыток дозвониться на номер. Метод может быть использован для реализации продвинутой логики перепланирования звонков с учетом информации о том, сколько звонков уже было совершено и сколько еще осталось. Разное Исходящий SIP-прокси Теперь вы можете настроить исходящий SIP-прокси для телефонного подключения. Для настройки SIP-прокси задайте в соответствующем разделе расширенных настроек телефонного подключения адрес, порт, а также поведение прокси в ходе диалога с ботом. Блокировка ввода текста при использовании кнопок В настройках каналов Chat API и чат-виджет добавлена опция Блокировать ввод текста при использовании кнопок. С помощью нее вы можете заблокировать для клиента ввод текстовых сообщений, когда по сценарию используются кнопки.']"	Значение поля completedAttemptsToPhone отражает число попыток дозвониться, сделанных в рамках текущей серии. В документации не указано, сколько попыток дозвониться было сделано в рамках первой серии. Пожалуйста, переформулируйте вопрос.	['Первая серия, первая попытка — абонент не ответил на звонок.\nПервая серия, вторая попытка — абонент не ответил на звонок.\nПервая серия, третья попытка — абонент ответил.\nВторая серия, первая попытка — абонент не ответил на звонок.\nВторая серия, вторая попытка — абонент ответил.']	0.8723570630006527	0.4499999999775	0.3333333333333333
Сколько попыток дозвониться было сделано во второй серии?	"['История всех попыток Поля с суффиксом ToPhone отражают историю всех попыток дозвониться на номер: completedAttemptsToPhone — суммарное число всех сделанных попыток дозвониться на номер. После очередной попытки дозвониться значение поля увеличивается на единицу. Значение этого поля не обнуляется. availableAttemptsToPhone — предельно допустимое число доступных попыток дозвониться на номер. Значение поля соответствует значению счетчика Максимальное количество, заданному при создании обзвона. Пример Из интерфейса JAICP создан новый обзвон, для которого настроены следующие значения счетчиков попыток: Начальное количество — 4, Максимальное количество — 8. Список клиентов для обзвона содержит один номер 79110000000. Рассмотрим возможную историю попыток дозвониться на номер: Первая серия, первая попытка — абонент не ответил на звонок. Первая серия, вторая попытка — абонент не ответил на звонок. Первая серия, третья попытка — абонент ответил. Результат вызова $dialer.getDialHistory: Абонент попросил перезвонить позже. В метод $dialer.redial передано поле maxAttempts: 3. Вторая серия, первая попытка — абонент не ответил на звонок. Вторая серия, вторая попытка — абонент ответил. Результат вызова $dialer.getDialHistory: Метод может быть использован для реализации продвинутой логики перепланирования звонков с учетом информации о том, сколько звонков уже было совершено и сколько еще осталось.'
 'Бот попробует дозвониться по каждому номеру указанное Начальное количество раз. Если в сценарии бота планируются дополнительные попытки дозвониться на номер при помощи метода $dialer.redial, то система ограничит общее число попыток — их может быть не больше, чем Максимальное количество. Начальное количество попыток по умолчанию — 1, максимум — 99. При изменении начального количества дополнительно заполните поля: Пауза между дозвонами — сколько минут пройдет от окончания предыдущей попытки дозвониться до начала следующей. Перезванивать, если звонок был менее — если разговор длился менее установленного времени в секундах, то произойдет повторная попытка дозвониться. Если произошла техническая ошибка, например по причине отсутствия связи с SIP-сервером, после каждого звонка с ошибкой время до повторной попытки будет увеличено в 2 раза, начиная со значения в 1 минуту. Попытка из счетчика Попыток дозвониться будет потрачена, только если звонок будет совершен успешно либо по достижении 9 звонков с ошибкой подряд. Запуск обзвона В поле Начать обзвон вы можете настроить время запуска обзвона: Сейчас — обзвон будет запущен сразу после создания. Запланировать на — обзвон будет запущен автоматически в указанное время. Нажмите Начать обзвон или Запланировать обзвон. Созданный обзвон отобразится в списке. Статусы обзвонов В списке обзвонов отображается их статус: Запланирована — запуск был назначен на определенное время и дату. В процессе — запуск состоялся, обзвон идет.'
 'Подробнее о планировании повторного звонка'
 '$dialer.getDialHistory Метод позволяет получить историю состоявшихся и доступных попыток дозвониться на номер. Синтаксис Метод вызывается без аргументов и возвращает объект из четырех целочисленных полей. История текущей серии попыток Если при обзвоне абонент не отвечает, бот может сделать несколько попыток дозвониться до абонента. Последовательность попыток дозвониться образует серию. Если в ходе диалога с абонентом бот планирует новый звонок при помощи метода $dialer.redial, серия попыток сбрасывается — новые попытки происходят уже в рамках новой серии. Поля completedAttempts и availableAttempts отражают историю текущей серии попыток: completedAttempts — число попыток дозвониться, сделанных в рамках текущей серии. После очередной попытки дозвониться значение поля увеличивается на единицу. Если из сценария планируется новая серия попыток, значение поля обнуляется. availableAttempts — число попыток дозвониться, доступных в текущей серии. Если номер добавлен в обзвон при помощи списка клиентов, то значение поля соответствует значению счетчика Начальное количество, заданному при создании обзвона. Если номер добавлен в обзвон при помощи запроса к Calls API с явно переданным значением поля maxAttempts, то значение availableAttempts совпадает с maxAttempts. Если из сценария бота запланирована новая серия и при вызове $dialer.redial явно передано поле maxAttempts, то значение availableAttempts также совпадает с maxAttempts.'
 '№ перезвона — порядковый номер повторного звонка на данный номер. Ячейка № перезвона будет заполнена, если звонок был запланирован из сценария при помощи метода $dialer.redial. Нумерация начинается с 1. Статус задания — статус, присвоенный звонку в момент завершения обзвона или выгрузки отчета. Причина окончания звонка — причина, по которой звонок был завершен. Например, клиент не ответил, бот положил трубку и т. д. Результат — результат звонка, проставленный при помощи метода $dialer.setCallResult. Длительность — время, затраченное на звонок. Начало звонка — дата и время начала звонка. Конец звонка — дата и время окончания звонка. Номер попытки — порядковый номер попытки дозвониться. При планировании новой серии попыток дозвониться при помощи метода $dialer.redial счетчик сбрасывается. Последняя попытка — столбец будет иметь значение да, если данная попытка является последней из всех возможных попыток дозвониться на номер. Если звонок так и не был совершен, все столбцы, кроме номера телефона, останутся пустыми. Если на звонок не было ответа, то время попытки проставляется в столбце Конец звонка. Для расширения отчета вы можете использовать метод $dialer.reportData.'
 'Затем с помощью метода $dialer.redial будет запланирован повторный звонок через час.'
 'Отчет по попыткам Подробнее о статистике по обзвонам Далее расширим готовый сценарий некоторыми дополнительными возможностями.'
 'Например, чтобы бот распознал просьбу перезвонить через час, добавьте фразу \\* через час\\* \\*. Нажмите — это сделает фразу шаблоном. Блок Интенты Сохраните блок. Участок сценария Настройка повторного звонка Чтобы запланировать повторный звонок, бот должен выполнить определенный JavaScript-код. От шаблона \\* через час\\* \\* создайте новый экран с блоком Код. Бот будет использовать метод $dialer.redial. Этот метод позволяет запланировать новую серию попыток дозвониться до абонента, а также переопределить политику звонков на данный номер из сценария. Чтобы бот перезвонил клиенту через час, вставьте в блок следующий код: Блок Код В данном случае бот будет звонить клиенту через 60 минут. Бот сделает две попытки дозвониться с паузой не менее 5 минут между попытками и не будет звонить позднее, чем через 75 минут от текущего момента, — то есть будет звонить в течение 15 минут. Вы можете отредактировать параметры объекта для метода $dialer.redial самостоятельно. Чтобы бот попрощался с клиентом, добавьте на экран блок Переход и создайте от него новый экран с блоком Синтез речи: Я перезвоню вам позже. До свидания!. На тот же экран добавьте блок Завершение сценария. В итоге у вас получится такой участок сценария: Сценарий Чтобы осуществлять гибкую настройку повторного звонка, воспользуйтесь другим нашим продуктом — JAICP. Боты JAICP могут использовать специальные сущности, чтобы извлекать из ответа клиента произвольное время для повторного звонка.'
 'Обработка неудачного звонка При разработке сценария нужно учитывать, что бот не всегда может дозвониться до клиента. Например, клиент не взял трубку или номер был занят. Такие звонки попадают в статистику по телефонии, но не обрабатываются в сценарии. Для того чтобы обработать неудачный звонок и, например, запланировать новый, нужно предусмотреть в сценарии обработчик события onCallNotConnected. Настройка chatbot.yaml Прежде чем использовать обработчик события в сценарии, укажите флаг onCallNotConnected в файле chatbot.yaml: Теперь при неудачном звонке в сценарий бота будет приходить событие onCallNotConnected. Пример использования Рассмотрим пример, в котором боту не удалось дозвониться до клиента. Когда сработает событие onCallNotConnected, метод $dialer.getCallNotConnectedReason вернет причину неудавшегося звонка, а $dialer.setCallResult проставит его результат в отчетах по обзвону и сессиям. Например, Не дозвонился. Причина: NO_ANSWER. Для определения причины, по которой бот не дозвонился клиенту, используйте метод $dialer.getCallNotConnectedReason. Метод вернет одну из двух строк: BUSY, если абонент занят, или NO_ANSWER, если не ответил. Затем с помощью метода $dialer.redial будет запланирован повторный звонок через час.'
 '$dialer.redial Во время разговора бота с клиентами может потребоваться запланировать новый звонок — например, если клиент просит перезвонить ему позже. Метод $dialer.redial позволяет запланировать новую серию попыток дозвониться до абонента, а также переопределить политику звонков на данный номер из сценария. Синтаксис Метод принимает в качестве аргумента объект со следующими полями. Передаваемый объект обязательно должен содержать поля startDateTime или allowedTime. Если прочие поля не указаны, их значения будут взяты из параметров обзвона. Формат значений полей allowedDays и allowedTime полностью аналогичен одноименным полям в теле запроса к методу Calls API POST /addPhones. Ограничения В одном диалоге можно запланировать повторную серию попыток дозвониться только один раз. Последующие вызовы $dialer.redial в этом диалоге будут проигнорированы. Число повторных попыток дозвониться на каждый номер в рамках одного обзвона ограничено значением параметра Максимальное количество, указанного при создании обзвона. Использование в сценарии Рассмотрим пример, как можно обработать просьбу перезвонить через час: Вы можете извлекать из запроса произвольное время при помощи сущностей Duckling, а также использовать слот-филлинг для обязательного уточнения у клиента времени повторного звонка.']"	Во второй серии было сделано две попытки дозвониться.	['Первая серия, первая попытка — абонент не ответил на звонок.\nПервая серия, вторая попытка — абонент не ответил на звонок.\nПервая серия, третья попытка — абонент ответил.\nВторая серия, первая попытка — абонент не ответил на звонок.\nВторая серия, вторая попытка — абонент ответил.']	0.880154627764342	0.62499999996875	1.0
Какое действие позволяет боту запросить у пользователя номер телефона и сохранить его в переменную?	"['Блок phone to $var Блок phone to $var позволяет боту получить от клиента номер телефона и сохранить его в переменную. Полученное значение переменной можно использовать на других экранах сценария. Подробнее о переменных Как добавить блок Блок доступен через меню Добавить экран → Еще блоки → phone to $var. Параметры В открывшемся окне заполните поля: Сообщение, которое бот выведет клиенту, чтобы запросить номер телефона. Имя переменной, в которую бот сохранит результат. Используйте символы Aa-Zz, \\_, 0-9. Имя переменной должно начинаться с Aa-Zz. Нельзя использовать зарезервированные слова языка JavaScript. Сообщение об ошибке, которое бот выведет в случае некорректного ввода номера телефона. Сообщений об ошибке может быть несколько. Клиенту они будут выводиться случайным образом. HTML-разметка Вы можете использовать HTML-разметку в полях Сообщение и Сообщение об ошибке. Для этого активируйте переключатель Использовать в сообщении HTML-разметку. Не все каналы поддерживают HTML-разметку. Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений. Формат номера телефона Клиент вводит номер российского мобильного телефона: Цифрами, например: 89123456789 или +79123456789. Текстом, например: восемь девять один два три четыре пять шесть семь восемь девять. При помощи данного блока можно получать только российские мобильные номера. Получить иностранный номер телефона можно при помощи регулярных выражений в блоке Интенты. Допускается наличие скобок и дефисов.'
 'Клиент вводит номер телефона Бота можно научить общаться с клиентами, если показать ему разные варианты реакций клиента и ответов на них. Эти реакции закладываются в блок Интенты (от англ. intent — намерение). В зависимости от намерения клиента бот направит разговор по подходящей ветке сценария. Реакции клиента часто можно предугадать. Например, в процессе диалога клиент может написать или сказать свой номер телефона. Бот может получить этот номер несколькими способами. При помощи этих способов можно получать только российские мобильные номера. Подробнее о том, как получать другие номера Как получить российский номер телефона Вы можете получить номер телефона клиента двумя способами: Через блок phone to $var: Бот будет пытаться распознать номер телефона, то есть системную сущность $PHONE внутри сообщения клиента. Бот распознает номер, даже если клиент напишет в сообщении другие слова до или после номера телефона. При помощи блока phone to $var вы можете получить только номер телефона на одном экране. Через готовый интент Номер телефона: Бот распознает номер телефона строго по шаблону $PHONE. Если клиент напишет дополнительные слова до или после номера телефона, бот не распознает его. Бот может одновременно пытаться распознать в сообщении клиента несколько типов контактных данных, поэтому вы можете добавить несколько готовых интентов на один экран.'
 'Если пользователь ввел номер столика, которого нет в списке, то вернем его на предыдущий экран. Если же такой номер есть, то сделаем новый экран на котором выведем пользователю информацию перед бронированием. Добавляем блок Текст: Столик $res.table на $date в $res.time. Бронируем? Также добавим кнопки: От кнопки Отменить делаем связь на первый экран, на котором спрашиваем, на какое время пользователь хочет забронировать столик. От кнопки Бронировать создаем новый экран с блоком Текст, в котором попросим пользователя оставить номер телефона и имя. Добавим блок Интенты\\* и добавим интент: \\* $NAME $PHONE \\*и пример: \\* $NAME $PHONE \\* После того, как пользователь введет номер телефона и имя, нам нужно отправить информацию о бронировании в нашу таблицу. Чтобы отправить метку ""занято"" в нужную ячейку, необходимо знать этот адрес ячейки. Для этого делаем дополнительный лист в нашей таблице, выглядит он так: Снова публикуем эту страницу с помощью нашего сервиса. Теперь мы можем по дате получить нужный адрес. Делаем блок Http-запрос от интента $NAME $PHONE. Запрос выглядит так: Тут мы создали две переменные: letter $httpResponse\\[0]\\[$date] - берем первый элемент массива, а он у нас всего один, и ищем по ключу букву, ключ у нас дата. cell $letter + $res.num - склеиваем строку, наша буква, которую мы получили в переменной $letter и номер строки, num - это столбец из нашей первоначальной строки. Теперь у нас есть адрес ячейки. Дальше, нам нужно оформить запись в ячейку.'
 'В поле Сообщение напишите: Введите адрес В поле Имя переменной напишите: address Вот что у нас получится: Вариант Переход после ввода $address свяжите с новым блоком Номер телефона. От варианта Переход после ввода $phone создайте блок Изображение. ""По ссылке"" → введите в поле Url картинки: $items.image 13\\. На этот экран с изображением добавьте блок Текст: $items.flowerscolorname на сумму $summ.Ваш адрес: $addressНомер телефона: $phoneВсе верно? На этот же экран добавьте блок Интенты - Согласие и Отказ. Свяжите вариант Любая другая фраза с этим же экраном, который содержит Изображение, Текст и Интенты. Интент Отказ свяжите с экраном приветствия. От интента Согласие создайте блок Интеграция с CRM. Этот блок будет содержать следующее: Система: BITRIX24 Задача Создать лида Список параметров для записи: Название лида: Клиент Адрес $address Телефон контакта: $phone Комментарий: $items.flowerscolorname на сумму $summ. От варианта Данные сохранены создайте блок Текст: Менеджер свяжется с вами в течение 15 минут. От варианта Данные не записаны создайте блок Текст: Произошла ошибка отправки данных $httpStatus. Не страшно, менеджер прочитает диалог и свяжется с вами! Готово! Теперь мы можем собрать у клиента данные по заказу и по итогу диалога с ботом создать карточку лида в Битрикс24.'
 'Calls API Платформа JAICP предоставляет Calls API для работы с исходящей телефонией. Перед началом работы с Calls API необходимо: Настроить телефонию. Подключить телефонный канал. Создать обзвон. Методы API API предоставляет методы для следующих операций: Добавление телефонных номеров с параметрами в обзвон. POST /api/calls/campaign/{token}/addPhones GET /api/crmCalls/campaign/{token}/addPhone POST /api/crmCalls/campaign/{token}/addPhone Отмена созданных заданий на обзвон. POST /api/calls/campaign/{token}/callJob/cancel Получение отчетов по ID задания на обзвон или по номеру телефона. POST /api/calls/campaign/{token}/callJob/getReport POST /api/calls/campaign/{token}/callAttempt/getReport Получение информации об обзвоне. GET /api/calls/campaign/{token} GET /api/calls/campaign/{token}/status Приостановление, возобновление и остановка обзвона. POST /api/calls/campaign/{token}/control/pause POST /api/calls/campaign/{token}/control/resume POST /api/calls/campaign/{token}/control/stop Подробное описание Calls API: методы, параметры запроса, форматы ответа, примеры, возвращаемые ошибки Параметры запросов Обязательные параметры В строки запросов к Calls API подставляются следующие обязательные параметры: host_name — имя хоста, на котором запущен обзвон. token — уникальный токен для управления обзвоном. Получить токен можно на вкладке Обзвоны, нажав на иконку рядом с названием обзвона либо на > Скопировать API-токен.'
 'Как сохранять информацию о пользователе | Викторина | База данных Потребность Бот должен уметь сохранять информацию о пользователе: когда пользователь зайдет повторно в нашего бота, то сможет начать с того места, где остановился в предыдущий раз. Решение Для примера сделаем небольшую игру «Логические концовки». Вы можете поговорить с этим ботом в Telegram по адресу @Logic_check_bot. Посмотреть на сценарий вы можете здесь. Как это работает Запрашиваем данные об игроке В начале сценария нам нужно запросить данные об игроке. Для этого у нас должна быть создана какая-то база данных, в которой эти данные будут сохраняться и из которой их можно будет получить. Воспользуемся нашим сервисом для сохранения, удаления и чтения данных. В сценарии создайте первый экран, добавьте на него блок HTTP-запрос: метод - GET \\* в поле URL вставьте данный адрес: https&#x3A;//tools.aimylogic.com/api/data/${userId} На вкладке RESPONSE нажмите на + и в поле Имя переменной вставьте: history а в поле Значение вставьте: $httpResponse Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. Для удобства добавим на этот экран метку ЕСТЬ ЛИ ИСТОРИЯ? Если данные об игроке будут, то они сохранятся в переменную $history, запрос завершится успешно, и мы сможем оперировать этой переменной.'
 'Перевод звонка на оператора Для перевода звонка на оператора используйте $response.replies с типом switch или тег действия TransferCallToOperator. Синтаксис Статус перевода на оператора При помощи метода $dialer.getTransferStatus вы можете отслеживать статус перевода звонка на оператора. Например: В лог будет добавлена запись формата: Оператор недоступен При неуспешном переводе на оператора, например, номер для перевода занят, абонент может быть возвращен в диалог с ботом. Для этого укажите в $response.replies свойство continueCall: true и отслеживайте в сценарии event: transfer. Например: Обратите внимание, что абонент будет возвращен в стейт, где отслеживается событие event: transfer. Здесь вы можете добавить реплики или реакции бота. Отображение номера При переводе звонка на оператора можно настроить отображение фактического номера клиента, а не номера бота. Для этого необходимо создать телефонное подключение и настроить SIP-транк без регистрации и пароля: перейдите на вкладку Настройка телефонии в боковом меню > Создать новое подключение; в меню Общие настройки > Пароль оставьте поле пустым; в меню Расширенные настройки > Требуется регистрация переведите переключатель в неактивное положение; заполните остальные поля в соответствии с инструкцией. Обратите внимание, что SIP-транки провайдера Билайн не позволяют использовать настройки в таком виде. Поэтому отображение фактического номера клиента для них недоступно.'
 'Как запланировать повторный звонок — как настроить бота, чтобы он повторно позвонил клиенту позже.'
 'Например: 8(912)3456789 или 8912-345-67-89. Бот распознает номер, если клиент напишет или произнесет его в следующем формате: Код 8 или +7 в начале номера, то есть, слова восемь или плюс семь. Трехзначное число, начинающееся с цифры 9, например: девять один один или девятьсот одиннадцать. Три цифры, написанные одним из способов: три цифры подряд: восемь шесть пять; ноль и двузначное число: ноль восемьдесят один; трехзначное число: триста двадцать шесть. Четыре цифры, написанные одним из способов: четыре цифры подряд: три восемь шесть один; ноль, цифра и двухзначное число: ноль пять шестьдесят три; ноль и трехзначное число: ноль восемьсот тридцать два; два двузначных числа: двадцать три сорок семь; двузначное число, ноль и цифра: семьдесят три ноль пять. После того, как клиент введет корректный номер телефона, бот создаст переменную, в которую сохранит номер в отформатированном виде. Например, если клиент напишет 8(912)345-67-89, то бот отформатирует результат в виде +79123456789. Получить городской номер телефона клиента можно через Telegram API. Как получить городской номер телефона'
 'Как получить городской номер телефона клиента В данной статье мы расскажем, как получить от клиента имя и городской либо мобильный номер телефона. Полученные данные будут отправляться в личные сообщения администратора бота в канале Telegram. Если вам нужно получать только мобильные номера телефонов, вы можете использовать готовый интент Номер телефона или блок phone to $var. Получение данных клиента Получение имени Создайте новый сценарий для чат-бота и добавьте экран с блоком Текст с приветствием и просьбой ввести имя. На этом же экране нажмите + БЛОК → Еще блоки → Имена. Раздел Еще блоки содержит готовые интенты. Готовый интент Имена будет распознавать российские имена, которые содержатся в системном справочнике $NAME. Когда бот распознает имя, он поместит его в переменную $NAME. Интент Имена принимает только те имена, которые есть в справочнике $NAME. Чтобы распознавать имена, которых нет в справочнике, необходимо дополнить сценарий. Интент Имена в меню блоков Экран с интентом Соедините опцию Любая другая фраза с этим же экраном, чтобы бот спрашивал у клиента имя до тех пор, пока клиент его не напишет. Связь с экраном Если вы общаетесь с клиентом в канале, где уже указано его имя, вы можете получить имя из канала при помощи переменной $rawRequest. Получение номера телефона От интента Имена создайте второй экран с блоком Текст и напишите в нем просьбу ввести номер телефона. На этот же экран добавьте блок Интенты.']"	"Действие, которое позволяет боту запросить у пользователя номер телефона и сохранить его в переменную, это блок ""phone to $var""."	['- Действие InputPhoneNumber позволяет боту запросить у пользователя номер телефона и сохранить его в переменную.\n- Поддерживаются только российские номера.']	0.8691165202088161	0.8857142857016327	1.0
Какую функцию можно использовать для форматирования JSON-объекта с отступами при логировании?	"['timeout — максимальное время обработки запроса в миллисекундах. По умолчанию ограничение включено со значением таймаута 10000 (10 секунд). Если запрос превысит ограничение, в сценарии возникнет событие timeLimit. XML-тесты XML-тесты сценариев позволяют проверить логику чат-бота, эмулируя запросы клиента и проверяя ответы от бота. По умолчанию выполняются все тесты из файлов в папке проекта test. Это поведение можно переопределить в секции tests, задав значения для подсекций include и/или exclude: include — будут выполнены тесты только из тех файлов, которые попадают под шаблоны, перечисленные в этой подсекции. exclude — из выполнения будут исключены все файлы, которые попадают под шаблоны, перечисленные в этой подсекции. Шаблоны используют синтаксис Apache Ant. Поле caseSensitive определяет, должны ли шаблоны учитывать регистр названий файлов. Значение по умолчанию — true. Зависимости Секция dependencies позволяет задать список зависимостей проекта. Подробнее о зависимостях Теги действий Секция customTags задает список самостоятельно созданных тегов действий, которые используются в проекте. Пользовательские реакции Секция customBlocks задает список пользовательских реакций, которые используются в рассылках. Сообщения об ошибках Секция messages.onError позволяет задать текст сообщения, которое бот отправит при возникновении какой-либо ошибки. В подсекции locales могут быть заданы тексты сообщений, локализованные исходя из данных о пользователе.'
 'И, наконец, добавим еще одну строку: $TEXT::isname Данная строка будет отрабатывать только в том случае, если ни один из других примеров не отработал. Введенное на данном экране сообщение клиента будет попадать в нее полностью. Этот $TEXT нам нужен на случай, если клиент добавил необычное имя одним словом. По умолчанию, когда вы переходите в редактирование блока Интенты и начинаете добавлять строки, они добавляются как примеры фраз, а не как шаблоны. Об этом свидетельствует иконка . Нажмите Сохранить. Теперь можно удалить экран с текстом Вас правда зовут $queryText?, так как у вас есть сущность $TEXT, которая будет принимать любую строку. Если в интентах есть $TEXT, то ветка Любая другая фраза отрабатывать не будет. Далее нам нужно сделать связь от интента \\* меня \\* зовут $TEXT::isname и создать блок Условия: В блок Условия вставьте следующее выражение: $name = $NAME ? $NAME.name : $isname С помощью этого условия вы создаете переменную $name. = — это оператор языка программирования JavaScript, с помощью которого присваивается значение переменной $name. Далее идет логическое выражение. Если у вас ранее что-то попало в системную сущность $NAME, то переменная $NAME.name будет записываться в переменную $name. Если же в системную сущность $NAME ничего не попало, то в $name запишется значение $isname. В итоге в переменной $name окажется имя из словаря или принятое необычное имя.'
 'В дальнейшем вы сможете использовать поля из значений сущностей в сценарии бота. При использовании значений сущностей в формате JSON есть ряд дополнительных требований к записи строк: В строке для сущности сначала указывается JSON со значениями сущности, а затем синонимы. Если вы загружаете справочник в формате CSV, синонимы должны отделяться от объекта JSON точкой с запятой, а сами синонимы между собой отделяются запятыми. Пример строки для CSV-файла: После загрузки файла на странице справочника такая строка отобразится следующим образом: Если строки из файла отобразились на странице справочника некорректно, убедитесь, что вы активировали опцию Добавлять значения сущностей в формате JSON перед загрузкой файла и что корректно записали строки со значениями сущностей и синонимами в файле. В сценарии можно обратиться к конкретному полю из значения сущности, указав его как $&lt;имя справочника>.&lt;имя поля>: В данном случае бот будет искать во фразе клиента сущности из справочника $macbook. Когда он распознает во фразе слово mac как синоним сущности из этого справочника, он запишет его в переменную $macbook. Далее бот получит поле full из объекта JSON со значениями сущности, соответствующей данному синониму, и выведет в ответе следующее:'
 '$integration.customRequest Метод позволяет выполнить произвольный запрос к любому методу, который поддерживается на стороне API интеграции, подключенной к проекту. Метод функционально схож с методом $http.query для выполнения HTTP-запросов. Используйте вместо него $integration.customRequest для обращения к API, имеющим отдельную интеграцию на стороне платформы. Синтаксис Принимаемые аргументы Метод принимает 5 обязательных аргументов. Возвращаемое значение Метод возвращает объект со следующими полями. Примеры использования Рассмотрим примеры того, как вызывать при помощи $integration.customRequest методы API для работы с таблицами Google. В примерах предположим, что идентификатор интеграции и таблицы сохранены в переменных integrationId и spreadsheetId соответственно. Подробное описание методов Google Sheets API Чтение данных из ячеек Для чтения данных воспользуемся методом spreadsheets.values.get. Получим данные из ячейки A1 на первом листе: Если первый лист называется Sheet1, а ячейка содержит значение Привет, метод вернет следующий объект: Поле responseBody содержит тело ответа от API в виде строки. Не забудьте использовать метод JSON.parse, чтобы преобразовать его в объект и извлечь необходимые данные. Запись данных в ячейки Воспользуемся методом spreadsheets.values.update, чтобы обновить существующие данные в ячейках таблицы. При успешном вызове метода значение ячейки A1 будет заменено на Пока.'
 'Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.'
 'Параметры с типом integer приводятся к числу через parseInt или parseFloat. Параметры с типами stringArray, nameValueList, json приводятся к объекту через JSON.parse. Настройки отображения в J‑Graph В графическом редакторе J‑Graph тегам действий соответствуют блоки действий. Поля ниже позволяют настроить их отображение в J‑Graph. Все эти поля необязательны. В качестве значения все поля принимают объект с ключами ru и eng. Значение ru используется при отображении интерфейса JAICP на русском языке, eng — на английском. Пример настроек Пример JSON-файла для сценария по сложению двух чисел, разработанного на шаге 1: Шаг 3. Укажите путь к JSON-файлу в chatbot.yaml В конфигурационном файле chatbot.yaml создайте секцию customTags, если ее еще нет. Укажите в ней путь к JSON-файлу относительно корневой директории проекта. Если вы хотите использовать тег как действие в J‑Graph, обязательно сохраните изменения, сделанные в редакторе кода. Для этого нажмите . Шаг 4. Используйте тег в сценарии Через редактор кода Перейдите в нужный файл сценария бота, например main.sc. Создайте новый стейт для вашего тега действия и укажите его параметры, например: Стейт срабатывает на запросы наподобие два плюс три. Через сущность @duckling.number из запроса извлекаются два числа, которые передаются в тег. SumTwoNumbers — название тега действия. Оно соответствует значению параметра tagName в JSON-файле с настройками.'
 'По умолчанию package.json. npmRcFile — путь до конфигурационного файла npm, относительно директории src. По умолчанию .npmrc. forceEs6 — если указано true, то код всех тегов реакций (не только script, но и, например, тега a) будет запускаться в новой среде исполнения. По умолчанию false. Запуск всех тегов в новой среде исполнения в настоящее время не оптимизирован. Рекомендуется не включать параметр forceEs6, если важно сохранить скорость ответа бота. Подключение npm-пакетов Ключевое преимущество новой среды исполнения над старой заключается в том, что для расширения возможностей бота вы можете использовать не только встроенное JS API, но и внешние зависимости — npm-пакеты, написанные сторонними разработчиками. Как подключить и использовать пакет Создайте в директории src файл package.json. Если вы переопределили requirementsFile, создайте файл по тому пути, который вы задали сами. Задайте в этом файле свойство dependencies. Его значением должен быть объект, где ключи — названия требуемых пакетов, а значения — их версии. Если вы разрабатываете проект локально, рекомендуется устанавливать зависимости через npm или любой другой пакетный менеджер, например yarn. Пакетные менеджеры могут сами определять оптимальные версии зависимостей и заполнять файл package.json автоматически. В файле могут быть заданы и другие свойства, но JAICP будет учитывать только dependencies.'
 'Здесь можно указывать данные в любом формате (JSON, XML, произвольный текст), а также добавлять переменные. Настройка тела HTTP-запроса В примере тело запроса указано в формате JSON. Бот автоматически подставит в тело запроса значения переменных $client.name и $client.age. При добавлении переменных в объект JSON необходимо учитывать, какой тип данных содержится в переменной. В примере переменная $client.name указана в кавычках, потому что она содержит данные строкового типа, а $client.age без кавычек, потому что содержит число. Обработка ответа В ответ на запрос сервер обычно возвращает данные, которые можно обработать или вывести клиенту. Для этого на вкладке Response вы можете указать, какие данные из ответа вы хотите сохранить в новые переменные. Например, по адресу https&#x3A;//api.forismatic.com/api/1.0/?method=getQuote&format=json&lang=ru сервер возвращает следующий ответ: JAICP сохраняет этот ответ в переменную $httpResponse. Поскольку это ответ в формате JSON, JAICP автоматически конвертирует его в JavaScript-объект, с которым сценарий может далее работать. Ответы в формате XML также конвертируются в JavaScript-объекты. Если же сервер вернул ответ в другом формате, он сохранятся в $httpResponse как строка без какой-либо обработки. Чтобы сохранить данные из определенного поля объекта, на вкладке Response укажите: Имя переменной. Значение будет сохранено в сценарии как $session.&lt;имя переменной>.'
 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.']"	Для форматирования JSON-объекта с отступами при логировании можно использовать функцию JSON.stringify с параметрами space или replacer.	['- toPrettyString Преобразует переданный объект в форматированный JSON-объект с отступами.\n- Можно использовать при логировании: Сравните примеры логирования объектов с использованием toPrettyString и без:\n- log(toPrettyString(customer))']	0.9702686365924394	0.0	0.0
Как изменить размер кнопок внешнего вида чат-виджета с помощью CSS?	"['В появившемся окне вы можете настроить графический интерфейс чат-виджета. Здесь вы можете изменить следующие элементы внешнего вида и поведения: Общие настройки Оформление Заголовок чата Окно чата Отправка сообщений Расположение Вовлечение в диалог Звуковые уведомления Установка Общие настройки Название — название канала, отображается в списке каналов. Токен — уникальный идентификатор бота. Используется в ссылке скрипта для встраивания чат-виджета на сайт. Ветка — ветка проекта, которая будет развернута в канал. Оператор — операторский канал, в который при необходимости будут направляться запросы клиентов. Публикация — способ публикации канала: автоматически после сохранения изменений в проекте или вручную. Показывать % пользователей — процент пользователей, которые увидят виджет на сайте. Показывать кнопку закрытия виджета — при включенной опции у иконки виджета появится кнопка, с помощью которой пользователь сможет закрыть виджет. Чтобы виджет появился вновь, нужно обновить страницу. Копировать настройки проекта — вы можете применить настройки из уже созданного канала к текущему. Если у вас был ранее опубликованный чат-виджет с темой По умолчанию, то его настройки не будут доступны для копирования. Для применения настроек замените тему на По умолчанию (beta). Оформление В этом разделе вы можете настроить: Тип шрифта Размер шрифта Размер аватаров бота и пользователя Цветовую тему На выбор представлены несколько цветовых тем.'
 'Как настроить внешний вид чат-виджета с помощью CSS В Aimylogic есть удобный графический конструктор, в котором вы можете настроить внешний вид вашего виджета, не прибегая к программированию. Мы написали отдельную статью о том, как им пользоваться. Но также вы можете использовать CSS для настройки внешнего вида чат-виджета. Далее мы приводим примеры того, как можно изменить разные элементы с помощью CSS. Размер логотипа Размер диалогового окна Текст сообщений Кнопки Размер кнопок Изменить кнопку отправки Имена клиента и бота Имя и сообщения бота Имя и сообщения пользователя Аватары Аватар бота Аватар пользователя Аватар пользователя фон Быстрые ссылки Ссылки Заголовок виджета Поле ввода сообщения Сместить виджет Все или часть этих стилей вы можете описать в своем CSS файле на сайте.'
 'Изменение стиля чат-виджета Чтобы изменить стиль виджета, переопределите некоторые CSS классы на вашем сайте. Ниже мы приводим примеры для некоторых компонентов виджета, стиль которых можно переопределить. Фон иконки свернутого виджета Иконка свернутого виджета Фон аватара бота Аватар бота Фон аватара пользователя Аватар пользователя Размер виджета Пузырь Быстрые ссылки Ссылки Размер логотипа Текст сообщений Кнопки Размер кнопок Изменить кнопку отправки Имена клиента и бота Имя и сообщения бота Имя и сообщения пользователя Заголовок виджета Поле ввода сообщения Сместить виджет'
 'Оформление графического интерфейса чат-виджета Вы также можете создать собственную цветовую тему. Для этого внесите изменения в любую готовую цветовую тему. Новая тема сохранится под иконкой кастомизированной темы, и вы сможете вернуться к ней в любой момент. Все внесённые изменения сразу применяются к чат-виджету, который расположен в правом углу экрана. Нажмите на него и оцените внешний вид чат-виджета. Заголовок чата Название — название чат-виджета, которое будет отображаться в заголовке. Аватар — загрузка пользовательского аватара для чат-виджета вместо изображения по умолчанию. Аватар бота — изображение, которое отображается, когда виджет свернут. Окно чата Имена — выбор имени участников чата: пользователя, бота и оператора. Сообщения, отправленные оператором, подписываются именем оператора из операторского канала. Если из операторского канала имя не удалось получить, то используется имя, указанное в конфигурации чат-виджета. Аватарки — загрузка аватара для участников чата. Предварительный просмотр ссылок — в сообщении бота будет отображаться содержимое ссылки. Анимация при ожидании ответа бота — бот будет имитировать набор текста, если ожидание ответа длится дольше 2 секунд. Отправка сообщений Пользователи отправляют сообщения — выбор способа отправки сообщений: по нажатию Enter и по нажатию на кнопку в окне чата или только по нажатию Enter.'
 'Настройка параметров чат-виджета при установке в iframe Для настройки параметров чат-виджета при установке в iframe: При установке в iframe с использованием внешнего скрипта: в обработчике событий onWidgetReady вызовите метод addJuswidgetVariables(), например: При установке в iframe с использованием кастомных обработчиков: измените добавляемый на страницу скрипт на скрипт с методом addJuswidgetVariables: Для настройки параметров чат-виджета после инициализации вызовите метод justWidgetApi.addJuswidgetVariables, например:'
 'Размер логотипа Размер диалогового окна Текст сообщений Кнопки Размер кнопок Изменить кнопку отправки Имена клиента и бота Имя и сообщения бота Имя и сообщения пользователя Аватары Аватар бота Аватар пользователя Аватар пользователя фон Быстрые ссылки Ссылки Заголовок виджета Поле ввода сообщения Сместить виджет Все или часть этих стилей вы можете описать в своем CSS файле на сайте.'
 'Элемент: должен иметь id=""justwidget--asst-close""; по клику на кнопку должен вызывать justWidgetApi.close(). Добавить на страницу &lt;iframe>, на момент загрузки страницы должен быть скрыт. Элемент: должен иметь id=""justwidget--iframe""; заполненный атрибут src, например src=""https&#x3A;//&lt;имя\\_сервера>/chatadapter/chatwidget/&lt;токен\\_чат-виджета>/justwidget-iframe.html"". Добавить на страницу скрипт: switch (type) можно, например, задать так: После инициализации виджета вы можете подключить к нему стили. Для этого вызовите: justWidgetApi.addCustomStyles(&lt;url\\_внешнего\\_css\\_файла>). Настройка параметров чат-виджета при установке в iframe Для настройки параметров чат-виджета при установке в iframe: При установке в iframe с использованием внешнего скрипта: в обработчике событий onWidgetReady вызовите метод addJuswidgetVariables(), например: При установке в iframe с использованием кастомных обработчиков: измените добавляемый на страницу скрипт на скрипт с методом addJuswidgetVariables: Для настройки параметров чат-виджета после инициализации вызовите метод justWidgetApi.addJuswidgetVariables, например:'
 'Здесь вы устанавливаете, какой заголовок будет у карточки. В этом поле можно указать статичный текст и добавить в него какой-либо параметр. В данном случае укажем только первый передаваемый параметр. Чтобы это сделать, нажмите Add ingredient и выберите Value1. Поле Description определяет, что будет написано в самой карточке. Вы можете оставить это поле без изменений либо отредактировать позже. Остальные поля оставьте без изменений. У вас получится примерно следующее: Нажмите Create action, затем Continue. При желании отредактируйте название апплета, после чего нажмите Finish. Вы будете перенаправлены на страницу апплета. Теперь, когда бот отправит HTTP-запрос на настроенный вебхук, IFTTT возьмет переменные из этого запроса и автоматически добавит карточку с этими переменными на доску Trello. Тестирование вебхука Перейдите на страницу Webhooks и нажмите Documentation. Откроется страница тестирования вебхука. На ней можно проверить, правильно ли вы осуществили настройку вебхука. Вместо {event} напишите название своего события без скобок, кавычек и пробелов. Если вы забыли название своего события, перейдите на главную страницу IFTTT. Вы увидите карточку своего апплета. Если вы не меняли название апплета, он будет называться по шаблону: «If Maker Event “add_trello_card”, then Create a card in — Клиенты board». Значение в кавычках и есть название вашего события — в данном примере это add_trello_card. Заполните поля value, value2 или value3 любыми значениями. Нажмите Test it.'
 'Блокировать ввод текста при использовании кнопок — выберите Да, если хотите заблокировать клиенту возможность ввода текстовых сообщений, когда используете кнопки в сценарии. Разрешить пользователям отправлять файлы — в чате появится кнопка , с помощью которой можно будет отправлять файлы боту. Подсказка в поле ввода — фраза, которая будет отображаться в поле ввода до момента, когда пользователь начинает вводить текст сообщения. Расположение На десктопе — положение виджета на экране десктопа: отступ от правого края экрана или отступ от нижнего края экрана в пикселях. Вы можете увидеть изменения сразу же на экране и отрегулировать наиболее подходящее для вас расположение виджета. На мобильном — положение виджета на экране мобильного устройства: слева или справа. Вовлечение в диалог Всплывающее сообщение — сообщение бота, которое будет всплывать в диалоге при наступлении настроенных событий. Открыть окно чата по наступлению условия — выбор условия открытия чата: время, проведенное пользователем на сайте или на странице. Приветствие в окне чата — выбор сообщения бота, которое появится в чате после открытия окна. Сессия начнется после первого сообщения пользователя. Показать кнопки меню — при включенном параметре вы сможете добавить в чат-виджет до 8 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут.'
 'Если настройка выключена, новое сообщение отображается только на активной вкладке с чат-виджетом. Звуковые уведомления В данном разделе вы можете настроить: Наличие звукового уведомления: При получении сообщения от клиента и бота. При получении сообщения от бота. При получении сообщения от клиента. Ни для каких сообщений. Звук для уведомления: Juntos. For sure. Just maybe. Дополнительные настройки В разделе Дополнительные настройки вы можете: Включить кнопку закрытия виджета. Если пользователь закрыл виджет, ему потребуется обновить страницу, чтобы виджет появился вновь. Указать процент клиентов, которым будет показываться чат-виджет. Скопировать настройки из другого проекта: если у вас уже есть все нужные настройки чат-виджета в другом проекте, вы можете перенести их в текущий проект. Для этого выберите из выпадающего списка название проекта, настройки которого вы хотите скопировать. Установка В разделе Установка вы можете: Скопировать код чат-виджета, чтобы вставить его на ваш сайт. Активировать опцию встраивания виджета в контейнер на странице и указать идентификатор нужного элемента страницы, в который вы хотите встроить чат-виджет.']"	Вы можете изменить размер кнопок внешнего вида чат-виджета с помощью CSS. Для этого вам нужно описать соответствующий стиль в своем CSS файле на сайте. В документации представлены примеры того, как можно изменить размер кнопок с помощью CSS. Вы можете использовать эти примеры для настройки внешнего вида чат-виджета.	['Размер кнопок\nИзменить кнопку отправки']	0.9817384891799592	0.5595238095098214	0.5
Как связано изменение размера диалогового окна с настройкой размера кнопок?	"['Условия открытия чата: Спустя какое количество времени пребывания клиента на сайте открывать чат-виджет. Спустя какое количество времени пребывания клиента на странице открывать чат-виджет. Приветствие в окне чата: Показывать ли приветствие в начале диалога. Текст приветствия. Показывать ли кнопки меню. Текст кнопок меню. Используя опцию Приветствие в окне чата, вы можете экономить уникальных пользователей. Если опция отключена, уникальный пользователь спишется сразу после открытия клиентом чат-виджета. Если опция включена, уникальный пользователь спишется только после того, как клиент ответит боту на приветствие. При включенном параметре Показать кнопки меню вы сможете добавить в чат-виджет до 12 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут. Вы также можете сделать инлайн-кнопку и передать в нее ссылку на любой источник. Для этого нажмите на иконку на выбранной кнопке. Отображение кнопок только над формой ввода: Если настройка активна, инлайн-кнопки будут отображаться рядом с обычными кнопками над формой ввода. Если настройка неактивна, инлайн-кнопки будут отображаться в поле чата. Отображение нового сообщения миганием вкладки (по умолчанию включено). Если настройка включена, оповещение о новом сообщении от бота или оператора отображается на вкладке, когда она неактивна.'
 'После нажатия на кнопку ""цены"" бот перейдет на второй экран, на котором должны отображаться Инлайн-кнопки. Но из-за особенностей канала, обычные кнопки не исчезнут. Вы можете пользоваться таким поведением, если для вас даже удобно отображать два вида кнопок. Либо, если для вас такое поведение неудобно, разделяйте экраны с обычными кнопками от экранов с Инлайн-кнопками другими экранами текста с интентами вместо кнопок, чтобы не было такой последовательности.'
 'Диалог с ботом начнется после того, как клиент отправит любое сообщение. Обработка непредсказуемых фраз клиента Чтобы бот смог отвечать на сообщения клиента, не предусмотренные в сценарии, добавьте еще один интент и введите $TEXT. Соедините опцию Любая другая фраза с новым экраном. Добавьте на него блок Текст с ответом бота на случай, если он не сможет распознать фразу клиента. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и переводить диалог на экран приветствия. Особенности канала В канале LiveTex нельзя отправлять кнопки и файлы в одном сообщении. То есть, блоки Аудио, Видео и Изображение не должны размещаться на одном экране с кнопками. Вы можете использовать интенты вместо кнопок на экране с файлами либо поместить файлы и кнопки на разные экраны. Для настройки канала в Aimylogic вам потребуется: Получить токен интеграции у менеджеров LiveTex. Указать приветственное сообщение. Клиент получит его, когда откроет виджет или напишет сообщение в канале. Перевод на оператора Чтобы бот в определенный момент переводил диалог на оператора, добавьте блок Перевод на оператора на нужном участке сценария. Также вы можете переводить диалог на группу операторов, если добавите ее на стороне LiveTex. Свяжите блок Перевод на оператора с другими экранами при помощи кнопок или интентов.'
 'Кнопки и ссылки К каждому ответу бота и к блокам ввода (ввод текста, числа, номера телефона и т.д.) можно добавить одну или несколько кнопок. Как добавить кнопку на экран? Чтобы добавить кнопку на экран, нажмите + КНОПКА. Введите текст, который будет написан на кнопке, и нажмите Enter. Как связать кнопку с нужным экраном? Вы можете связать кнопку с тем экраном, на который должен перейти бот после того, как пользователь нажмет эту кнопку. Чтобы связать кнопку с нужным экраном, нажмите на кружок на кнопке и протяните стрелку к нужному экрану. Также можно создать новую кнопку, а затем кликнуть по ней. Новый экран появится автоматически и сразу привяжется к этой кнопке. Сколько кнопок можно добавить на один экран? На один экран вы можете добавить до 12 кнопок. Подробнее о том, как добавить больше 12 кнопок Как перемещать кнопки? Чтобы переместить кнопку в границах экрана, удерживайте иконку, которая появляется слева от кнопки при наведении курсора на нее, и перетащите кнопку на нужное место. На другой экран кнопку переместить нельзя. Как работают кнопки? Рассмотрим такой пример: Здесь сценарий начинается с экрана «Привет! Чем могу помочь?». На этом экране будут выведены три кнопки: «цены», «статус заказа» и «доставка». Когда пользователь нажмет кнопку «цены», бот перейдет на экран «Цены вы можете посмотреть здесь». Когда пользователь нажимает кнопку «цены» у себя в канале, ему приходит ответ от бота «Цены вы можете посмотреть здесь».'
 'Блокировать ввод текста при использовании кнопок — выберите Да, если хотите заблокировать клиенту возможность ввода текстовых сообщений, когда используете кнопки в сценарии. Разрешить пользователям отправлять файлы — в чате появится кнопка , с помощью которой можно будет отправлять файлы боту. Подсказка в поле ввода — фраза, которая будет отображаться в поле ввода до момента, когда пользователь начинает вводить текст сообщения. Расположение На десктопе — положение виджета на экране десктопа: отступ от правого края экрана или отступ от нижнего края экрана в пикселях. Вы можете увидеть изменения сразу же на экране и отрегулировать наиболее подходящее для вас расположение виджета. На мобильном — положение виджета на экране мобильного устройства: слева или справа. Вовлечение в диалог Всплывающее сообщение — сообщение бота, которое будет всплывать в диалоге при наступлении настроенных событий. Открыть окно чата по наступлению условия — выбор условия открытия чата: время, проведенное пользователем на сайте или на странице. Приветствие в окне чата — выбор сообщения бота, которое появится в чате после открытия окна. Сессия начнется после первого сообщения пользователя. Показать кнопки меню — при включенном параметре вы сможете добавить в чат-виджет до 8 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут.'
 'Релиз JAICP 1.10.7 Настройка для отображения инлайн-кнопок над формой ввода в чат-виджете. Поддержка протокола Open Graph в чат-виджете. Некорректный токен при подключении канала Telegram через прокси. Часть User ID не попадает в результат фильтра по диалогам. Обновляется время отправки сообщений в чат-виджете. Внешний репозиторий перезаписывается системным шаблоном. В релизе 1.10.7 основные доработки коснулись чат-виджета. Отображение инлайн-кнопок над формой ввода В настройках вовлечения в диалог для чат-виджета добавлена настройка Показывать кнопки только над формой ввода. Настройка позволяет отображать инлайн-кнопки не под сообщениями диалога (поведение по умолчанию), а над формой ввода текста, наравне с обычными кнопками. Поддержка Open Graph Благодаря поддержке протокола Open Graph стал возможен предварительный просмотр содержимого по ссылкам, если ссылки содержатся в сообщениях бота, клиента или оператора. Исправлено'
 'Изменения призваны подчеркнуть целевое назначение метода — добавление номеров в обзвон из CRM-систем, в частности Битрикс24. При необходимости добавлять номера в обзвон из других внешних сервисов рекомендуется использовать основной метод POST /addPhones. Ограничение количества звонков на номер Параметр Количество попыток дозвониться, настраиваемый при создании обзвона, теперь разбит на два параметра: Начальное количество и Максимальное количество. Бот попробует дозвониться по каждому номеру указанное Начальное количество раз. Если в сценарии бота планируются дополнительные попытки дозвониться на номер при помощи метода $dialer.redial, то система ограничит общее число попыток — их может быть не больше, чем Максимальное количество. Разное Исправления Обновления документации Добавлен пошаговый сценарий бота для отправки напоминаний. Добавлено общее описание редактора сценариев. Обновлена статья о передаче параметров в чат-виджет. Обновлена OpenAPI-спецификация Calls API.'
 'Мигание вкладки с чат-виджетом при новом сообщении Для чат-виджета добавлена опция Показывать новое сообщение миганием вкладки. При включенной опции клиенты всегда будут знать о новом сообщении, даже если перейдут на другую вкладку браузера. Опция включается в параметрах вовлечения в диалог, а также может быть настроена для виджета в iframe с использованием как внешнего скрипта, так и кастомных обработчиков. Исправлено'
 'Вы также можете сделать инлайн-кнопку и передать в нее ссылку на любой источник. Для этого нажмите на выбранной кнопке. Показывать кнопки только над формой ввода — при включенном параметре инлайн-кнопки будут отображаться рядом с обычными кнопками над формой ввода, а не в поле чата. Параметр выключен по умолчанию. Показывать новое сообщение миганием вкладки — оповещение о новом сообщении от бота или оператора. Отображается на вкладке с чат-виджетом, когда вкладка не активна. Параметр включен по умолчанию. Сценарий вовлечения Виджет закрыт → наступает установленное событие → всплывает сообщение рядом с закрытым виджетом. Виджет открылся и клиент закрывает его → наступает следующее событие → виджет открывается. Виджет открылся и клиент не закрывает его → наступает следующее событие → виджет закрывается и открывается повторно. Клиент самостоятельно открыл виджет → наступает событие → виджет остается открытым. Подробнее о настройке начала сессии в чат-виджете Звуковые уведомления Звуковой эффект — включение уведомлений при отправке и/или получении сообщений. Звук — выбор рингтона для уведомлений. Установка В разделе Установка вы можете скопировать код чат-виджета, чтобы вставить его на ваш сайт. Разместите код скрипта между тегами &lt;head>&lt;/head> на всех страницах сайта, где будет находиться виджет. Также скрипт доступен по нажатию на Получить скрипт под названием созданного канала. Код для вставки виджета будет скопирован в буфер обмена.'
 'Аватарки участников диалога: Будут ли отображаться аватарки участников чата. Какие аватарки будут отображаться для бота, клиента и оператора. Если вы активируете опцию Аватарки, но не загрузите аватарку для какого-либо участника диалога, то для этого участника будет отображаться одна из стандартных аватарок Aimylogic. Предварительный просмотр ссылок. Будет ли отображаться содержимое ссылки в сообщении бота. Анимацию при ожидании ответа бота. Будет ли бот имитировать набор текста, если ожидание ответа длится дольше 2 секунд. Отправка сообщений В разделе Отправка сообщений вы можете настроить: Отправку сообщения клиентом: Отправлять сообщения только по нажатию Enter. Отправлять сообщения по нажатию Enter или по нажатию мышкой на кнопку отправки сообщения в поле ввода текста. Блокировку ввода текста при использовании кнопок. Отображение кнопки прикрепления файлов в поле ввода текста. Подсказку в поле ввода текста. Расположение В разделе Расположение вы можете настроить: Для десктопа: Отступ виджета от правого края страницы (в пикселях). Отступ виджета от нижнего края страницы (в пикселях). Для мобильных устройств: Место страницы, где будет размещаться значок чат-виджета — нижний левый угол или нижний правый. Вовлечение в диалог В разделе Вовлечение в диалог вы можете настроить: Всплывающее сообщение: Показывать ли сообщение рядом со значком чат-виджета. Текст всплывающего сообщения. Спустя какое время после попадания клиента на сайт показывать сообщение.']"	Документация не содержит информации о связи изменения размера диалогового окна с настройкой размера кнопок. Пожалуйста, уточните вопрос или задайте его по-другому.	['Размер диалогового окна\nРазмер кнопок']	0.94256666827015	0.0	0.5
"Какие атрибуты для тега &lt;style> изменят стиль речи диктора с идентификатором ""exilant""?"	"['От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.'
 'Вы также можете обозначить словесное ударение специальным символом + после ударной гласной. interpret-as — задает формат прочтения слова. Возможные значения: format — определяет формат даты. Его нужно указывать, если для атрибута interpret-as задано значение date. Возможные значения: &lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально. Для всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный. Для любого голоса вы также можете сгенерировать свои уникальные наборы стилей. Многие дикторы умеют ярко выражать свои эмоции, но некоторые читают тексты в однотипной сдержанной манере. Поэтому эффект от применения тега style зависит от выбранного голоса и иногда может быть неотличим от стиля по умолчанию. Основные стили Чтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name. Возможные значения: exilant — в голосе появится больше энергии, воодушевления. irate — голос приобретет оттенки раздраженности. depressive — голос станет подавленным, грустным. В варианте с атрибутом name тег style используется как парный тег. Основные стили могут быть применены ко всему тексту, его части или отдельному слову. Случайные стили В Aimyvoice вы также можете использовать случайные стили. Их особенности генерируются случайным образом в зависимости от подобранного числа — идентификатора стиля.'
 '$reactions.ttsWithVariables Метод задает аудио и шаблон текста для синтеза речи с переменным на базе технологии Yandex SpeechKit Brand Voice Adaptive. В настройках телефонного канала должны быть активны переключатели Включить Yandex v3 и Использовать переменные. В противном случае вызов метода приведет к ошибке. Синтаксис Метод принимает объект с полями audioTemplate и textTemplate. audioTemplate audioTemplate — описание аудио, в которое будет вставлена переменная. Содержит поля: audio — ссылка на аудиофайл с шаблоном фразы. Файл должен быть публично доступен по протоколу httpS и удовлетворять требованиям, предъявляемым к аудиозаписям. textTemplate — описание расшифровки аудиофайла: template — текст шаблона. Переменные должны быть обозначены соответствующими именами в фигурных скобках. textVariables — массив объектов, описывающих использованные переменные. Каждый объект содержит поля: name — название переменной. value — расшифровка переменной, использованной в шаблоне. audioVariables — массив объектов, описывающих расположение переменных в аудиозаписи. Каждый объект содержит поля: name — название переменной. startMs — время от начала аудиозаписи до начала воспроизведения переменной в миллисекундах. lengthMs — длительность воспроизведения переменной в миллисекундах. textTemplate textTemplate — описание фразы, которую должен синтезировать бот в диалоге с клиентом. Содержит поля: template — текст шаблона.'
 'Иначе стиль будет каждый раз звучать по-разному. rhythm — логическое значение 0 или 1. Указывает на то, что ритм целевого голоса будет изменен. Значение по умолчанию — 1. pitch — логическое значение 0 или 1. Указывает на то, что тон целевого голоса будет изменен. Значение по умолчанию — 1. При использовании атрибута mimic_voice тег style является непарным и применяется, только если стоит в начале текста. Стиль распространяется на весь текст целиком. Наложение стилей можно использовать совместно со случайными стилями. &lt;sub> Заменяет звучание слова на другое. Например, вы можете использовать этот тег, чтобы: Передать более привычное звучание: «что» — «што». Указать правильное произнесение единицы измерения: «м/c» — «метров в секунду». Укажите желаемое звучание в атрибуте alias.'
 'Релиз JAICP 1.10.9 Интеграция с таблицами Google. Фиксация результата диалога во всех каналах. Новые фильтры в аналитике по диалогам. Метод POST /addPhone в Calls API. Ограничение количества звонков на номер. Поддержка приема файлов в канале Slack. Возможность изменения почты пользователя. Ограничения на число и объем ответов чат-бота. Некорректно работает тег if при числовом значении в теле тега, близком к 0. В аналитике по диалогам вместо имени интента отображается имя стейта. Ответы бота не попадают в логи диалогов, если не заполняется поле $response.answer. Дублируется файл nlu.json в репозитории с несколькими ботами. При планировании обзвонов некорректно отображается время начала. В канале Telegram создается лишняя сессия при вызове $pushgate.createEvent. Добавлен пошаговый сценарий бота для отправки напоминаний. Добавлено общее описание редактора сценариев. Обновлена статья о передаче параметров в чат-виджет. Обновлена OpenAPI-спецификация Calls API. В релизе 1.10.9 у JAICP появились новые возможности для интеграции с внешними системами. Теперь в настройках проекта на вкладке Каналы доступен новый раздел Интеграции, где вы можете создать подключение к нужной внешней системе и, получив его идентификатор, легко взаимодействовать с системой из сценария. На данный момент поддерживается интеграция с таблицами Google. Мы продолжаем развивать новую версию аналитики: в этом релизе добавлена возможность фиксировать результат диалога во всех каналах, а также ряд новых фильтров.'
 'state Декларативный тег state объявляет стейт — состояние, в котором может находиться контекст диалога. Стейты всегда должны быть вложены в какую-либо тему, которая объявлена при помощи тега theme. Значение После тега записывается название стейта. Название может содержать любые символы Unicode. Вложенные данные На уровне вложенности, следующем после объявления стейта, могут записываться теги активации, теги реакций и теги действий. Они определяют то, как контекст диалога может попасть в стейт и какие реакции выполнит бот. Кроме того, в теги state могут быть рекурсивно вложены другие теги state. Таким образом задается древовидная структура сценария, где одни стейты вложены в другие. Подробнее о принципах перехода по стейтам Примеры использования Стейт Start является родительским для стейта GetName. Стейты, вложенные в родительские, называются дочерними. Параметры Параметры — пары «ключ — значение», которые отделяются от названия или значения тега (если оно есть) двумя вертикальными чертами. Если параметров несколько, они отделяются друг от друга запятыми. Параметры позволяют модифицировать поведение тега. Для тега state могут быть заданы параметры: noContext Если у стейта есть параметр noContext со значением true, то при переходе в такой стейт контекст того, в каком стейте находится бот, не меняется. Следующий запрос пользователя обрабатывается в контексте стейта, в котором бот находился до перехода. Рассмотрим сценарий: Предположим, что в ответ на вопрос Как дела?'
 '$dialer.getBotSpeech Метод возвращает данные о воспроизведении реплики бота в телефонном канале. Синтаксис Метод вызывается без аргументов: Возвращаемое значение Метод возвращает массив объектов со свойствами: Формат объекта с репликой Объект с репликой бота reply содержит свойства со строковым типом. Если ответ отправлен через: Tег a, метод $reactions.answer или ответ с типом text, объект будет содержать свойства text и ssml — текст реплики и текст с разметкой синтеза речи, если она используется. Tег audio, метод $reactions.audio или ответ с типом audio, объект будет содержать свойство audioSrc — ссылку на аудиофайл audioSrc. Метод $reactions.ttsWithVariables, объект будет содержать свойства text — текст реплики, template — текст шаблона для синтеза речи, audio — ссылку на аудиофайл с шаблоном реплики. Пример возвращаемого значения Использование в сценарии Допустим, во время звонка бот информирует о текущих промоакциях. Он произносит текстовую реплику из тега a и затем воспроизводит запись диктора из тега audio. Чтобы записать информацию о воспроизведении реплики в комментарий в аналитику: Вызовите метод getBotSpeech, чтобы получить данные о реплике бота. Если все данные определены, переберите в цикле все ответы и создайте текст комментария.'
 'Теги активации Теги активации определяют действия пользователей или события, которые могут перевести контекст диалога в тот или иной стейт. Все теги активации делятся на два вида: локальные и глобальные. По локальному тегу переход в стейт возможен только из ближайшего родительского, из соседних или дочерних стейтов. По глобальному тегу диалог может перейти в стейт из любого другого стейта в сценарии. Названия глобальных тегов заканчиваются на !. Параметры Параметры — пары «ключ — значение», которые отделяются от названия или значения тега (если оно есть) двумя вертикальными чертами. Если параметров несколько, они отделяются друг от друга запятыми. Параметры позволяют модифицировать поведение тега. Для локальных тегов q, intent, intentGroup и event могут быть заданы параметры: fromState Параметр fromState задает путь до стейта, из которого возможен переход в текущий стейт по данному тегу активации. fromState позволяет перевести диалог из определенного контекста в нужный стейт без использования глобальных паттернов. Кроме того, это один из способов покинуть контекст модального стейта. Рассмотрим пример. В сценарии ниже пользователь может выйти из контекста модального стейта OrderStatus, если не знает номер заказа. toState Параметр toState задает путь до стейта, в который возможен переход из текущего стейта по данному тегу активации. Назначение fromState и toState одинаково, и ответ на вопрос, что лучше использовать, во многом зависит от личных предпочтений.'
 'Для тега можно задать необязательные атрибуты: strictMatch — строгость сопоставления мок-объекта телу запроса. Значение по умолчанию: false. При нестрогом сопоставлении (false) проверяется, что все значения полей, указанные в теге &lt;body>, равны соответствующим значениям полей из тела запроса. При строгом сопоставлении (значение true) проверяется полное совпадение объекта в теге &lt;body> и тела запроса. field — JsonPath-выражение, указывающее на поле для сопоставления. Если атрибут указан, сопоставление производится не по всему объекту из тела запроса, а только по его части. Ответ &lt;response> — описание ответа, который вернет мок-объект в качестве ответа сервера. Обязательный элемент. В теле элемента указывается строка с ответом. Возвращаемое значение метода $http.query помимо HTTP-ответа в поле data содержит ряд служебных полей: isOk, status и другие. Данные поля не следует помещать в &lt;response>. Указывайте только ответ от сервера — то, что приходит в поле data. Возможные атрибуты для тега: status — код ответа на HTTP-запрос, по умолчанию 200. type — тип ответа, по умолчанию json. Если тип ответа json или xml, ответ парсится и возвращается в сценарий в виде JS-объекта. В противном случае ответ передается в виде строки. Если формат тела &lt;response> не соответствует указанному типу, при публикации бота возникнет синтаксическая ошибка.'
 'Поэтому вам не обязательно перечислять все возможные сочетания и синонимы при обучении бота. Однако, для более точной настройки вы можете использовать синтаксис шаблонов. Как получить данные из ввода пользователя Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту). Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони. Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос. Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах. В Aimylogic есть системные сущности, а также возможность создавать свои собственные. Подробнее о работе с сущностями можно прочитать в статье Сущности. Кнопки Совместно с интентами, для упрощения диалога с пользователем, вы можете использовать кнопки. Даже если вы используете кнопки на экране, рекомендуется также помещать на экран блок Интенты, чтобы бот понимал, что делать, если пользователь что-то напишет, а не нажмет кнопку. Подробно об использовании кнопок описано в этой статье.']"	"Для тега &lt;style> с идентификатором ""exilant"" можно использовать атрибуты ""exilant"", ""irate"" и ""depressive""."	['&lt;style> Изменяет манеру (стиль) речи диктора. Например, вы можете сделать так, чтобы голос звучал более энергично или печально.\nДля всех голосов, кроме Татьяна (для рекламы), предусмотрены три основных стиля: воодушевленный, раздраженный, подавленный.\nЧтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name.\nВозможные значения: exilant — в голосе появится больше энергии, воодушевления.\nirate — голос приобретет оттенки раздраженности.\ndepressive — голос станет подавленным, грустным.']	0.9607111490632926	0.49999999995	0.0
"Какие правила игры в игру ""Угадай число""?"	"['Угадай число В этом уроке мы изучим основные компоненты Aimylogic, которые понадобятся для создания любого бота. В итоге у нас получится бот, который загадывает случайное число и предлагает пользователю угадать его в процессе диалога. Поведение бота Наш диалоговый бот должен загадывать число случайным образом. Далее пользователь выдвигает свое предположение. Если его предположение неверно, то бот должен сказать, больше или меньше число, загаданное ботом, и предложить пользователю попытаться еще раз. И так до тех пор, пока пользователь не отгадает загаданное ботом число. После этого можно предложить сыграть еще раз. Примеры диалога с этим ботом: Создание сценария Зайдите на https&#x3A;//app.aimylogic.com/. Создайте новый аккаунт или войдите в свой аккаунт. Нажмите ""Создать бота или обзвон"" чтобы создать новый сценарий: Дайте сценарию название, выберите русский язык и нажмите Продолжить. Разработаем сценарий Бот работает согласно сценарию, который вы разработаете. Вы можете контролировать конкретное поведение бота, внося изменения в сценарий. Приветствие Наш бот при старте должен рассказать пользователю правила игры и предложить сыграть. Чтобы добавить сообщение с приветствием Стартовый экран - это экран, который находится слева и наверху. Бот всегда будет начинать общение с этого экрана. Чтобы добавить приветствие, нажмите Текст. Это создаст блок Текст. Напишем в нем: Привет! Нажмите Сохранить, чтобы добавить этот блок.'
 'Игра «Угадай число» В этом туториале мы показываем как создать бота, который будет играть с пользователем в игру «Угадай число». Суть игры заключается в том, что бот загадывает число, а вы с помощью подсказок бота угадываете его. В процессе разработки игры вы узнаете о слот-филлинге и слотах, научитесь пользоваться генератором случайных чисел и другими функциями случайного выбора значений. Перед началом работы над ботом мы рекомендуем ознакомиться с общей структурой проекта бота, а также пройти туториал Создание простого бота. Правила игры Сначала установим правила игры: Бот загадывает любое число случайным образом и просит пользователя угадать это число. Пользователь вводит число. Если его предположение неверно, то бот должен сказать, больше или меньше загаданное число, а затем предложить пользователю повторить попытку. Если пользователь угадает число, игра считается завершенной. Теперь приступайте к созданию бота: Настройте конфигурационный файл. Cоздайте сценарий. Протестируйте бота.'
 'Пример использования Напишем стейт, который эмулирует игру в кости и выдает сумму двух случайных чисел от 1 до 6:'
 'От Любая другая фраза экрана ""прием ввода"" создадим блок Текст: Не вижу в твоем ответе числа… Назовем этот экран: нет числа Добавим на экран ""нет числа"" блок Переход и свяжем его с экраном ""назови число"". Свяжем интент Согласие экрана ""прием ввода"" с экраном ""назови число"". Добавьте на экран ""прощание"" блок Интенты, создайте интент, скопируйте и вставьте в него: \\* \\*игр\\* \\* Этот экран будет принимать такие реплики пользователя, как ""давай играть"", ""играть еще"", ""поиграем"", ""давай поиграем"", ""давай поиграем еще раз"", ""играть еще раз"" и т.д. Свяжите интент \\* \\*игр\\* \\* с экраном ""запрос"". Свяжем вариант Любая другая фраза экрана ""прощание"" с экраном ""играть"". Добавьте на экран ""прощание"" кнопку: играть Свяжите интент Приветствие с экрана ""прием ввода"" с экраном ""приветствие"". Доработаем интенты Чтобы сделать реакции бота более ""живыми"" можем добавить дополнительные интенты. Например, на экран ""играть"" в интент Согласие можем добавить такой интент: \\* \\*игр\\* \\* Тогда, если пользователь напишет ""ну, давай поиграем"", бот также распознает как согласие. В интент Отказ на экране ""играть"" можно добавить интент: \\* не \\* \\*игр\\* \\* Этот интент может принимать такие реплики, как ""не хочу играть"", ""не буду играть"" и т.д. В процессе тестирования бота вы можете найти ""слепые места"" бота и добавить нужные интенты в сценарий. Готово! Сценарий готов.'
 'Если же данных нет, то запрос завершится с ошибкой - это будет значить что пользователь к нам пришел первый раз. Если пользователь у нас впервые От блока http-запрос Завершен с ошибкой сделаем новый экран с блоком Текст: Привет! Это игра логические концовки. Вооружись логическим мышлением! В этой игре нужно правильно закончить фразы. Ну что, начнем? Назовем этот экран ЕСЛИ НЕТ ИСТОРИИ Добавим варианты ответов пользователя Добавим на экран ""ЕСЛИ НЕТ ИСТОРИИ"" блок Интенты. :size=200 :size=200 Добавим готовый интент Согласие. :size=200 :size=200 :size=200 Сохраним блок Узнать больше о блоке Интенты вы можете здесь, а о готовых интентах – здесь. Вот что у нас получилось: Оформим таблицу, в которой будем хранить содержание игры Пример таблицы вы можете посмотреть здесь. Можете просто скопировать эту таблицу. После того, как пользователь согласился сыграть в игру, нужно дать ему первый вариант фразы, которую нужно продолжить. Фразы мы будем сохранять в Google Таблице. Выглядеть таблица будет следующим образом: В таблице должно быть 4 столбца с названиями: question answer level score Копируйте и вставляйте эти названия в таблицу. Если вы напишете названия столбцов неправильно, измените одну букву, добавите пробел или сделаете иную опечатку, сценарий, предложенный в этом уроке, не будет работать.'
 'Игра «Города» В этом туториале мы покажем как создать бота, который будет играть с пользователем в игру «Города». Суть игры заключается в том, что игроки поочередно называют реально существующий город любой страны. Название города должно начинаться на букву, которой оканчивается название города предыдущего игрока. Например, первый игрок говорит Москва, тогда второй должен назвать город на букву А, например Архангельск. Перед началом работы над ботом мы рекомендуем ознакомиться с общей структурой проекта бота, а также пройти туториал Создание простого бота. Правила игры Сначала установим правила игры: Бот спрашивает пользователя, кто первым будет загадывать город. Бот или игрок называет город. Следующий игрок называет город на последнюю букву. Нельзя повторно использовать город. Кроме того, нельзя использовать короткие названия городов. Например, Санкт-Петербург, а не Питер. Если города на определенную букву закончились, то используем вторую букву с конца. Игра заканчивается тогда, когда игрок напишет боту «сдаюсь» или «мне надоело». Теперь приступайте к созданию бота: Напишите функции для игры, которые понадобятся для сценария. Cоздайте конфигурационный файл и сценарий бота. Разберитесь со структурой сценария Протестируйте бота.'
 'Подробнее о кнопках читайте здесь. Нажмите + КНОПКА, введите текст: Давай! И нажмите Enter, либо кликните на свободном месте экрана. Загадаем число Чтобы сгенерировать случайное число, нам понадобится сторонний сервис, который умеет выдавать случайное число по запросу. Таким сервисом может выступить сайт random.org, который умеет генерировать истинно случайные числа и события. У этого сайта есть API, с помощью которого наш бот может получить случайное число. Мы можем использовать этот API с помощью блока HTTP-запрос. Нажмите на интент Согласие. Таким образом мы создадим связь от интента Согласие и определим, что будет делать бот, когда пользователь скажет ""да"", ""хорошо"", ""давай"", ""ладно"" и т.д. Выберите блок HTTP-запрос. Оформим вопрос следующим образом: Метод GET В поле URL скопируйте и вставьте: https&#x3A;//www.random.org/integers/?num=1&min=1&max=100&col=1&base=10&format=plain&rnd=new В этом URL мы указали, что будем выдавать случайное число от 1 до 100. Если открыть этот адрес в браузере, то вы увидите, что он просто возвращает некоторое целое число от единицы до сотни. Если перезагрузить страницу, то появится новое случайное число, Как раз то, что нам нужно. Наш бот должен запросить это число и сохранить его в некоторую переменную, с которой потом будет сравнивать ответ пользователя. Переменные - это как коробки, в которые мы что-то кладем, какую-то информацию. Для порядка удобно подписать коробки, поэтому каждая переменная имеет свое имя.'
 'Вывод случайных данных Если вы хотите выводить случайным образом какие-либо данные, вы можете воспользоваться способом, описанным в уроке Печеньки с предсказаниями. Либо, если данных немного, или если в зависимости от выбора вы хотите вести пользователя по какой-либо ветке сценария, вы можете реализовать эту задачу прямо в сценарии, минуя использование Google Таблиц. Допустим, мы хотим создать простого бота, который будет предлагать поучаствовать в лотерее и будет случайным образом выводить всего три приза на выбор. Это можно реализовать с помощью такого участка сценария: Здесь мы сначала спрашиваем согласия на участие в лотерее. Когда пользователь нажимает на кнопку ""Да"", бот переходит на блок Условие. В Условие скопируйте и вставьте: $prize = \\_.random (1, 3) Таким образом, мы используем метод \\_.random, чтобы выбрать число от 1 до 3. Данное число мы присваиваем переменной $prize с помощью оператора присвоения = языка Javascript. Далее, мы переходим на ряд условий, в которым сравниваем содержание переменной $prize с числами. Для этого используем оператор сравнения ==. $prize == 1 $prize == 2 $prize == 3 Если число равно 1, то выводим первый приз. Если число равно двум, то выводим второй приз и т.д. Данный способ подойдет вам, если у вас мало вариантов выбора, либо если в зависимости от случайного числа вы хотите вести клиента по какой-либо ветке сценария.'
 'Назовем этот экран: загадал И добавим на экран ""загадал"" блок Переход: Вот что у нас получается: Примем ввод пользователя От блока Переход создайте новый блок Интенты. Нажмите Создать интент. Скопируйте и вставьте: \\* $NUMBER \\* $NUMBER - системная переменная, которая принимает числа. При этом числа можно называть как цифрами - 1, 3, 99, так и словами - один, три, девяносто девять. Звездочки означают, что перед и после $NUMBER могут быть любые слова. Таким образом, бот сможет понять, если пользователь скажет что-то вроде ""Наверное, пять"". Бот достанет оттуда ""пять"". | Подробнее о звездочках и других способах принимать ввод в интентах читайте в статье о синтаксисе шаблонов. Затем нажмите ВЫБРАТЬ ГОТОВЫЙ ИНТЕНТ и выберите готовые интенты - Согласие, Отказ, Приветствие, Прощание. Таким образом, мы предусматриваем различную реакцию пользователя, и далее скажем боту, что делать в ответ на такие реплики. Нажмите Выбрать и Сохранить Назовем этот экран: прием ввода Вот что у нас получилось: Мы вывели блок Интенты на отдельный экран, чтобы было удобно перенаправлять сюда в дальнейшем. Проверяем диапазон числа Нам нужно убедиться, что пользователь ввел число, которое не больше 100 и не меньше 1. Нажмите на интент \\* $NUMBER \\* и создайте блок Условия. Блок Условия используется, когда нужно добавить нелинейности в диалог. Вы можете написать строку Javascript выражения в строку условия. В зависимости от выполнения того или иного условия бот переходит на разные экраны.'
 '$history.level - уровень, на котором остановился пользователь. Получится, что мы откинем часть массива, а значит, выведем пользователю только те фразы, на которые он еще не давал ответ. Нажмите Сохранить. Назовем этот экран НЕОТВЕЧЕННЫЕ ВОПРОСЫ Связываем вариант Завершен успешно экрана ""НЕОТВЕЧЕННЫЕ ВОПРОСЫ"" с экраном ""Первый вопрос"". Добавим распознавание желания начать новую игру Осталось дать возможность пользователю начать новую игру. Добавим блок Интенты в любое место сценария: :size=200 :size=200 Включите опцию Сделать доступным из любой точки сценария, чтобы сделать этот блок Интенты глобальным. Добавим интент \\* нов\\* игр\\* \\* Этот интент будет ловить такой ввод, как ""новая игра"", ""новую игру"", ""начать новую игру"", ""хочу новую игру"", ""новую игру давай"" и т.д. Подробнее читайте в статье о синтаксисе шаблонов. Назовем экран ГЛОБАЛЬНЫЙ ИНТЕНТ От интента \\* нов\\* игр\\* \\* создадим новый блок http-запрос, с помощью которого будем удалять данные о пользователе: выберите метод DELETE и в поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} нажмите Сохранить. Назовем этот экран УДАЛЯЕМ Так мы очистим все данные об этом игроке. От варианта Завершен успешно экрана ""УДАЛЯЕМ"" делаем связь с экраном ""ЕСЛИ НЕТ ИСТОРИИ"" Добавим сообщение об успешном завершении игры Найдите экран ""ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС"". От варианта else создайте блок Текст: Поздравляю, игра пройдена! Хочешь сыграть еще? Это сообщение будет выводиться, если вопросов больше не осталось.']"	"Правила игры в игру ""Угадай число"" следующие:
1. Бот загадывает случайное число.
2. Пользователь вводит свое предположение.
3. Если предположение неверно, бот говорит, больше или меньше число загаданное им, и предлагает пользователю попытаться еще раз.
4. Игра продолжается до тех пор, пока пользователь не угадает число.
5. После этого можно предложить сыграть еще раз."	['- Суть игры заключается в том, что бот загадывает число, а вы с помощью подсказок бота угадываете его.\n- Правила игры Сначала установим правила игры: Бот загадывает любое число случайным образом и просит пользователя угадать это число.\n- Если его предположение неверно, то бот должен сказать, больше или меньше загаданное число, а затем предложить пользователю повторить попытку.\n- Если пользователь угадает число, игра считается завершенной.']	0.9875324398660186	0.7182539682360118	1.0
Какой вид подсказки дает бот в этой игре?	"['Как добавить ChatGPT в бота из конструктора'
 'Работа с Telegram Bot API Telegram предоставляет Bot API для управления поведением ботов. С помощью доступных методов API вы можете настраивать логику ботов для данного канала. Например, вы можете: отправлять сообщения удалять сообщения Если ваш бот еще не подключен к каналу Telegram, сначала перейдите к инструкции по подключению и выполните ее шаги, чтобы опубликовать бота. После подключения перейдите к следующему шагу этой статьи. Отправка сообщений С помощью метода sendMessage вы можете отправлять сообщения от клиента в ваш личный аккаунт Telegram и отвечать клиенту прямо в диалоге с ботом. В личный аккаунт Чтобы отправить сообщение клиента в личный аккаунт, добавьте в сценарий: Блок text to $var, чтобы записать сообщение клиента в переменную. Блок HTTP-запрос: Выберите метод GET. В поле URL вставьте https&#x3A;//api.telegram.org/bot&lt;token>/sendMessage, где &lt;token> — токен из последнего сообщения бота BotFather при создании бота в Telegram. Это значение вида 5949769123:AAFVkGudasD-qdWscjxJsmlqphhOcD59eXs. Скопируйте JSON-объект ниже и вставьте его на вкладку BODY: Здесь: 223001234 — пример идентификатора вашего диалога с ботом. Вы можете узнать его через специального бота. $rawRequest.message.from.id — идентификатор диалога клиента с ботом из переменной $rawRequest. Он также имеет вид 223001235. $message — переменная, которая содержит текст сообщения клиента. Опубликуйте сценарий и протестируйте отправку сообщений.'
 'Сперва откройте конфигурационный файл chatbot.yaml и дополните его полем injector, в котором укажите настройки прерывания слот-филлинга: В данном случае параметр maxSlotRetries: 3 означает, что бот дважды переспросит время перезвона, если не распознает его в ответах. Если клиент назовет некорректное время в третий раз, слот-филлинг прервется, а запрос попадет в стейт /Симптомы/Ответ по активатору event! : noMatch. Возможность прерывания по интенту для данного сценария не играет роли, поскольку других стейтов с глобальными интентами в сценарии нет. Поэтому параметры stopOnAnyIntent и stopOnAnyIntentThreshold установлены в соответствии с поведением по умолчанию. Дополнение сценария Осталось подключить в main.sc модуль слот-филлинга и добавить в корневую тему theme новый стейт: Метод $dialer.redial запланирует новый звонок с учетом нужного времени и включит его в обзвон. Перебивание Не всегда целесообразно ждать, когда бот закончит говорить, чтобы дать клиенту возможность ответить. Чтобы клиент мог перебивать бота, настройте в сценарии прерывание речевого потока.'
 'Настройка конфигурационного файла Создайте конфигурационный файл бота chatbot.yaml и укажите следующие параметры: В этом туториале мы будем использовать процесс дозапроса информации слот-филлинг, поэтому настроим параметры его прерывания: maxSlotRetries — количество попыток для одного слота. Если клиент ответил указанное количество раз, и слот не был заполнен, процесс слот-филлинга будет прерван. Последняя фраза клиента будет обработана в сценарии бота. Установим две попытки. В дальнейшем, когда будем настраивать заполнение слотов, именно столько фраз будет использовано в поле Вопросы. stopOnAnyIntent — параметр прерывания процесса слот-филлинга по интенту. Если stopOnAnyIntent: true, то интент будет прерван тогда, когда пользователь захочет обработать другой интент. В нашем сценарии не предусмотрены случаи, когда нужно прервать интент со слот-филлингом по другому интенту. Поэтому установим stopOnAnyIntent: false. stopOnAnyIntentThreshold — параметр соответствия, задающий минимально необходимую похожесть фразы на один из классов. Является параметром прерывания процесса слот-филлинга по интенту. В ходе разработки NLU-сервиса было эмпирически определено, что оптимальное значение этого параметра 0.2. Теперь перейдем к разработке сценария бота.'
 'Для этого: Перейдите в BotFather Напишите команду /mybots Выберите нужного бота Перейдите в Bot Settings → Group Privacy Выберите Turn off Должна появиться фраза Privacy mode is disabled for Bot Удалите $rawRequest Вернитесь в сценарий бота. Теперь можно удалить блок, который содержит $rawRequest.message.chat.id. Опубликуйте бота Опубликуйте бота в Telegram и дождитесь публикации: Протестируйте бота Теперь напишите в Telegram боту (не в группу). Ссылка на бота есть в BotFather, в сообщении, в котором вы получали токен бота. :size=400 Запустите новую сессию с помощью /start, пришлите боту сообщение и убедитесь, что оно приходит в группу: :size=300 :size=300 Если ваши пользователи напишут боту, сообщения от них также будут публиковаться в группу в Telegram. Что сделать, чтобы бот отвечал пользователям? Чтобы бот отвечал пользователям в группе в Telegram, вам нужно добавить бота в администраторы группы. Если этого не сделать, бот будет реагировать только если пользователь напишет / и затем название интента. Например, /привет. Вам также может быть интересно Как отправить сообщение в Telegram Как валидировать городской номер телефона Авторизация в Telegram Инлайн-кнопки'
 'Рассмотрим поведение бота, которое реализует данный фрагмент сценария: В начальном стейте Start бот представляется и запрашивает у клиента город. Поскольку стейту присвоен флаг modal, из него можно попасть только во вложенные стейты: GetCity и CatchAll. Стейт CatchAll служит для обработки нераспознанных реплик в данном локальном контексте. Для него установлен флаг noContext, поэтому при попадании контекст не будет меняться. В сумме это означает, что клиент не сможет продолжить диалог с ботом, пока не назовет город. В стейте GetCity бот извлекает из запроса город при помощи именованной сущности $City и передает значение часового пояса для города в метод $reactions.setClientTimezone. После установки часового пояса бот выходит из контекста модального стейта /Start в корневую тему /, что дает возможность продолжить диалог по инициативе клиента. Тестирование сценария Запустите тестовый виджет по кнопке и убедитесь в работоспособности сценария: Теперь, когда часовой пояс известен боту, мы можем приступить к реализации планирования и обработки напоминаний.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.'
 'Если при нахождении в модальном стейте возникнет событие, для которого в любом стейте сценария предусмотрен стейт-обработчик, событие будет успешно обработано. Если среди достижимых стейтов нет стейтов для обработки запроса или события noMatch, то бот попытается перейти в глобальный стейт-обработчик события noMatch. Если такого стейта в сценарии нет, возникнет ошибка о том, что не найден стейт для перехода. Рассмотрим сценарий: В этом сценарии пользователь может уточнить статус своего заказа, назвав его номер. У стейта OrderStatus есть параметр modal, поэтому диалог сможет выйти из него, только когда пользователь: Назовет номер заказа. Контекст перейдет в стейт WhatElse по go!. Скажет, что не знает номер. Контекст перейдет в стейт WhatElse по q с fromState. Параметр modal используется для стейтов, в которых от пользователя запрашивается важная информация, без получения которой диалог не может продолжаться. sessionResult и sessionResultColor Параметр sessionResult задает результат, который присваивается диалогу при попадании в стейт. Чаще всего это описание бизнес-результата, которого достигает бот, однако это может быть и свободный комментарий. То же назначение имеет метод $analytics.setSessionResult. Если у стейта есть и параметр, и вызов этого метода из тега script, то учитывается только вызов метода. Опциональный параметр sessionResultColor задает цвет метки с результатом, которая отображается в графическом редакторе J-Graph.'
 '$dialer.bargeInInterrupt Метод позволяет задать поведение бота при перебивании по условию. Метод работает корректно только в обработчике события перебивания по условию — bargeInIntent. Синтаксис Метод принимает в качестве аргумента значение логического типа — true или false. Передача true означает, что условие перебивания выполнено. После того как обработчик события bargeInIntent завершит выполнение, бот прервется, чтобы обработать поступивший запрос. Если передано значение false, условие перебивания не выполнено. Бот не прервется и обработает поступивший запрос после того, как закончит выполнение реакций в текущем стейте. Отсутствие вызова $dialer.bargeInInterrupt в обработчике события bargeInIntent равносильно вызову метода со значением false. Использование в сценарии Метод используется совместно с методом $dialer.getBargeInIntentStatus, чтобы задать поведение в случае, если клиент пытается перебить бота. Если клиент произносит осмысленную фразу, явно передающую его намерение, в обработчике вызывается метод $dialer.bargeInInterrupt с аргументом true, чтобы бот прервался. В противном случае попытка перебить бота игнорируется — обработка запроса происходит лишь после того, как бот закончит ответ.'
 'Функция first Кликните на Завершен успешно в блоке HTTP запрос, чтобы создать экран, на который бот перейдет, если поисковый сервис отработал корректно. На новом экране добавьте блок Условия Добавьте единственное условие вида $items.first() Функция first вернет первый элемент из массива, если массив не пуст. Таким образом бот пытается вытащить первый навык из результатов поиска, и если там что-то есть, то условие сработает, и бот перейдет на следующий экран. Нажмите на Сохранить и кликните на условие $items.first, чтобы связать его с новым экраном, на котором бот должен рассказать о навыке. Функция current На новом экране нужно рассказать о навыке, который мы нашли. Для этого добавьте блок Текст Тут бот вызывает функцию current, чтобы получить данные о текущем навыке из массива items. Из поля name можно получить название навыка. В поле examples хранится массив с примерами запросов. $items.current().name. Просто скажите Алисе - ""$items.current().examples\\[0]"". Так бот формирует строку ответа, например Футбольная игра Яндекса. Просто скажите Алисе - ""запусти навык футбольная игра"". Функция next Теперь нужно дать пользователю возможность послушать информацию о следующем найденном навыке. Для этого добавьте на этот же экран кнопку ""Еще варианты"". Кликните на нее, чтобы создать новый экран. На нем добавьте блок Условия Здесь тоже только одно условие $items.next() Функция next переместит бота на следующий элемент в массиве items, если там еще есть элементы.']"	Бот дает подсказку о следующем найденном навыке в игре.	['- Суть игры заключается в том, что бот загадывает число, а вы с помощью подсказок бота угадываете его.\n- Если его предположение неверно, то бот должен сказать, больше или меньше загаданное число, а затем предложить пользователю повторить попытку.']	0.8993432985473545	0.0	1.0
Как получить метку перебивания при помощи метода $dialer.getBargeInLabel?	"['Если условие перебивания выполнено, в обработчике должен быть вызван метод $dialer.bargeInInterrupt с аргументом true.'
 '$dialer.getBargeInLabel Метод используется при контекстном перебивании и позволяет получить из сценария метку перебивания, установленную для ответа при помощи параметра bargeInLabel. Синтаксис Метод вызывается без аргументов и возвращает строку со значением установленной метки. Подробнее о bargeInLabel'
 '$dialer.bargeInInterrupt — метод для задания поведения бота: должен ли бот прерваться, чтобы обработать запрос, или нет. Таким образом, в примере выше клиент сможет перебить прощание бота, только упомянув в запросе слово «оператор». Используйте метод $nlp.matchPatterns для динамического сопоставления текста запроса паттернам, чтобы задать более сложную логику классификации запросов на перебивание бота. Зависимость от bargeInTrigger Обратите внимание, что условия срабатывания события bargeInIntent отличаются в зависимости от того, какое значение присвоено полю bargeInTrigger при настройке перебивания. При использовании значения interim событие срабатывает при каждом промежуточном результате распознавания. Большое число вызовов обработчика события могут существенно увеличить потребляемые ресурсы и замедлить работу бота. Рекомендуется использовать для перебивания по условию только значение final, при котором событие возникает после получения окончательного результата распознавания.'
 'Перебивание бота Перебивание (англ. barge-in) — возможность телефонного канала, позволяющая абонентам прерывать речь собеседника, не дожидаясь, пока тот закончит говорить. Использование перебивания в проектах голосовых ботов позволяет им воспринимать запросы клиентов в реальном времени и оперативно на них реагировать. Это делает разговор более живым и стимулирует вовлеченность клиента в диалог. Параметры перебивания Для того чтобы включить перебивание, вызовите в нужном стейте метод $dialer.bargeInResponse с нужными настройками перебивания. Если произойдет перебивание, ответ бота будет прерван, а запрос клиента будет обработан в контексте данного стейта. Рассмотрим пример: Если клиент не дослушает и перебьет бота вопросом «Что?», бот прервется и отреагирует на вопрос. Метод $dialer.isBargeInInterrupted позволяет определить, был ли прерван ответ бота. Контекстное перебивание При зачитывании длинных последовательностей фраз вы можете настроить перебивание так, чтобы контекст перебивания отличался в зависимости от того, на какой фразе клиент перебил бота. Для настройки контекстного перебивания используются параметры тегов реакций a или audio, которые передаются через разделитель || после тела тегов. Рассмотрим синтаксис на следующем примере. bargeInTransition Параметр bargeInTransition задает путь до стейта, в который будет перенаправлен бот при перебивании. Путь задается в том же формате, что и после тега реакции go.'
 '$dialer.getBargeInIntentStatus Метод позволяет получить в сценарии данные о перебивании по условию. Метод работает корректно только в обработчике события перебивания по условию — bargeInIntent. Синтаксис Метод вызывается без аргументов и возвращает объект с двумя строковыми полями: bargeInIf — метка перебивания по условию. text — текст запроса, который вызвал условное перебивание. Использование в сценарии На основании данных о метке и тексте перебивания стейт-обработчик события bargeInIntent может определить, должен ли бот прерваться или нет. Если условие перебивания выполнено, в обработчике должен быть вызван метод $dialer.bargeInInterrupt с аргументом true.'
 'Такой подход может быть неэффективен, например, в условиях фонового шума либо если клиент при прослушивании активно использует речевые маркеры восприятия речи («ага», «ясно», «понятно»). Они не требуют ответной реакции, однако бот вынужден прерываться, чтобы обработать такие фразы. Для решения этой проблемы используйте возможность перебивания по условию, которая позволяет определить из сценария, в каких случаях бот должен обработать перебивание, а в каких нет. Рассмотрим пример ниже. bargeInIf Параметр bargeInIf после тега a или audio включает условное перебивание для фразы. Значением параметра является метка условного перебивания — строка с любой необходимой справочной информацией. bargeInIntent Если клиент перебьет бота во время произнесения фразы, для которой задан параметр bargeInIf, в сценарии сработает событие bargeInIntent, которое необходимо обработать в отдельном стейте. Само по себе возникновение этого события не заставит бота прерваться — бот продолжит ответ и одновременно запустит обработчик события. В результате выполнения обработчика бот должен определить, действительно ли ему нужно прерваться или же проигнорировать попытку его перебить. Для решения этой задачи в обработчике события bargeInIntent доступны следующие методы: $dialer.getBargeInIntentStatus — метод для получения метки условного перебивания и текста запроса, которым клиент пытался перебить бота.'
 '$dialer.isBargeInInterrupted Метод позволяет узнать, сработало ли перебивание бота. Синтаксис Метод вызывается без аргументов и возвращает логическое значение: Метод позволяет отличить друг от друга случаи, когда переход в стейт совершен обычным способом, а когда в ходе обработки перебивания бота при использовании bargeInTransition.'
 'Например, если клиент откажется от предложения во время произнесения первой или второй фразы, когда бот не успел полностью озвучить условия предложения, будет совершен переход в стейт /Offer/NotDone. После этого бот обработает преждевременный отказ в стейте /Offer/NotDone/No и вернется к предложению. Если же перебивание отказом произойдет на последней фразе, запрос будет обработан в контексте стейта /Offer/Done. В данном случае бот прервется, чтобы попрощаться с клиентом и завершить звонок. Путь к стейту для обработки перебивания, установленный для ответа, можно получить из сценария при помощи метода $dialer.getBargeInTransition. bargeInLabel Параметр bargeInLabel задает метку перебивания с какой-либо необходимой справочной информацией — например, о номере фразы, на которой произошло перебивание. Метод $dialer.getBargeInLabel позволяет получить в стейте для обработки перебивания значение установленной метки. ignoreBargeIn Если для фразы указан параметр ignoreBargeIn со значением true, то перебивание на такой фразе не сработает, даже если для стейта перебивание включено. Используйте игнорирование перебивания для фраз с важной информацией, которую клиент не должен пропустить, дослушав до одной из таких фраз. Перебивание по условию Способы обработки перебивания, рассмотренные выше, имеют следующий недостаток: при получении любого результата распознавания речи от ASR-провайдера бот обязан прерваться и обработать фразу клиента.'
 '$dialer.bargeInInterrupt Метод позволяет задать поведение бота при перебивании по условию. Метод работает корректно только в обработчике события перебивания по условию — bargeInIntent. Синтаксис Метод принимает в качестве аргумента значение логического типа — true или false. Передача true означает, что условие перебивания выполнено. После того как обработчик события bargeInIntent завершит выполнение, бот прервется, чтобы обработать поступивший запрос. Если передано значение false, условие перебивания не выполнено. Бот не прервется и обработает поступивший запрос после того, как закончит выполнение реакций в текущем стейте. Отсутствие вызова $dialer.bargeInInterrupt в обработчике события bargeInIntent равносильно вызову метода со значением false. Использование в сценарии Метод используется совместно с методом $dialer.getBargeInIntentStatus, чтобы задать поведение в случае, если клиент пытается перебить бота. Если клиент произносит осмысленную фразу, явно передающую его намерение, в обработчике вызывается метод $dialer.bargeInInterrupt с аргументом true, чтобы бот прервался. В противном случае попытка перебить бота игнорируется — обработка запроса происходит лишь после того, как бот закончит ответ.'
 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.']"	Метку перебивания можно получить при помощи метода $dialer.getBargeInLabel. Для этого необходимо вызвать данный метод без аргументов. Он вернет строку со значением установленной метки перебивания.	['$ dialer.getBargeInLabel Method is used for contextual interruption and allows you to get the interruption label set for the response using the bargeInLabel parameter. \nThe method is called without arguments and returns a string with the value of the set label. \nMore about bargeInLabel.']	0.9878884592144904	0.37499999998125	1.0
Какое действие позволяет боту запросить у пользователя файл и сохранить ссылку на него в переменную?	"['То есть по сути мы складываем значения переменных, которые получили в ходе сценария, с текстом, который будет пояснять их значение. Также мы используем переменную $rawRequest.user_info.id, которая будет содержать значение id страницы пользователя. И добавляем переносы строк с помощью знака \\\\n. После присвоения значения переменной $text, мы ставим запятую, пробел и создаем переменную $num. Этой переменной мы присваиваем случайное значение от 1 до 9223372036854775808 с помощью метода \\_.random. Этот параметр нужен для идентификации сообщения при отправке в ВКонтакте. Если вы используете в сценарии другие переменные, то измените, соответственно, и текст условия в соответствии с вашим сценарием. Напоминаем, что бот может отправлять сообщения только тем пользователям, с которыми он уже общался. Поэтому, чтобы менеджер, который обрабатывает заявки пользователей, мог получать сообщения, он должен для начала написать любое сообщение самому сообществу. :size=400 Оформите HTTP-запрос От блока Условие создайте связь с блоком HTTP-запрос. :size=400 метод POST в BODY скопируйте и вставьте: {""response"": 484045} :size=400 Вкладки RESPONSE и HEADERS заполнять не нужно. Составим URL запроса. Он может выглядеть примерно так: Разберем его по частям.'
 'Функция first Кликните на Завершен успешно в блоке HTTP запрос, чтобы создать экран, на который бот перейдет, если поисковый сервис отработал корректно. На новом экране добавьте блок Условия Добавьте единственное условие вида $items.first() Функция first вернет первый элемент из массива, если массив не пуст. Таким образом бот пытается вытащить первый навык из результатов поиска, и если там что-то есть, то условие сработает, и бот перейдет на следующий экран. Нажмите на Сохранить и кликните на условие $items.first, чтобы связать его с новым экраном, на котором бот должен рассказать о навыке. Функция current На новом экране нужно рассказать о навыке, который мы нашли. Для этого добавьте блок Текст Тут бот вызывает функцию current, чтобы получить данные о текущем навыке из массива items. Из поля name можно получить название навыка. В поле examples хранится массив с примерами запросов. $items.current().name. Просто скажите Алисе - ""$items.current().examples\\[0]"". Так бот формирует строку ответа, например Футбольная игра Яндекса. Просто скажите Алисе - ""запусти навык футбольная игра"". Функция next Теперь нужно дать пользователю возможность послушать информацию о следующем найденном навыке. Для этого добавьте на этот же экран кнопку ""Еще варианты"". Кликните на нее, чтобы создать новый экран. На нем добавьте блок Условия Здесь тоже только одно условие $items.next() Функция next переместит бота на следующий элемент в массиве items, если там еще есть элементы.'
 'Передача парaметров Описание Иногда возникает необходимость, чтобы бот получил от пользователя дополнительные параметры при запуске. Например, это может быть команда, которая запустит бота, или токен аутентификации для подключения учетной записи Telegram пользователя к учетной записи другого внешнего сервиса или его имя. Такие параметры передаются в ссылке бота Telegram https&#x3A;//t.me/&lt;bot username>?start=&lt;test> в виде запроса /start text. Переход по ссылке с установленным параметром откроет личный диалог с ботом, а вместо поля ввода будет находиться кнопка Запустить. Как только пользователь нажмет кнопку Запустить, бот получает от этого пользователя сообщение в виде /start text, где text — это значение параметра start, переданного в ссылке. Использование в сценарии Рассмотрим пример получения параметра из сценария. Произвольный параметр, указанный в ссылке, возвращается в переменную $parseTree.Text\\[0].value. Допустим пользователь перейдет по следующей ссылке: В этом случае пользователь будет автоматически перенаправлен в чат с ботом exampleBot. После того, как пользователь нажмет на кнопку Запустить, сработает паттерн q! : \\*start $Text $weight&lt;+0.5>. Бот выведет сообщение Вот: test. Вы можете проверить, получили ли вы необходимые параметры:'
 'Передача парaметров Описание Иногда возникает необходимость, чтобы пользователь перешел по ссылке в определенный диалог. ВКонтакте использует сервис коротких URL vk.me, который перенаправляет пользователей в указанный диалог. Ссылка имеет формат http&#x3A;//vk.me/{group_name}. Здесь group_name — это идентификатор сообщества. Например, vk.me/exampleclub. Кроме того, вы можете передать в ссылке произвольный параметр ref. Это полезно использовать для отслеживания эффективности ссылок, размещенных в разных каналах, или привязки пользователя к сеансу или аккаунту во внешнем приложении. В зависимости от переданного параметра можно варьировать ответы бота в сообществе. Ссылка с дополнительными параметрами примет вид: Использование в сценарии Диалог с ботом ВКонтакте начинается с сообщения начать. Поэтому для корректной работы сценария состояние start должно быть задано как: Произвольный параметр вернется в переменную $request.rawRequest.object.message.ref по нажатию на кнопку начать. Допустим пользователь перейдет по следующей ссылке: В этом случае пользователь будет автоматически перенаправлен в чат с ботом exampleBot. После того, как пользователь нажмет на кнопку Начать, сработает паттерн q! : начать. В теге script проверяем получили ли мы необходимый параметр. Если получили, то выводим его в качестве ответа бота: TEST. Иначе выведем сообщение: Параметр не получил.'
 'InputFile Действие InputFile позволяет боту запросить у пользователя файл (например, фотографию товара или документ с данными юридического лица) и сохранить ссылку на него в переменную. Параметры Использование в сценарии'
 'Отправка файлов $http.query позволяет отправлять файлы на внешний сервис. Для этого укажите в настройках запроса поля fileUrl и опционально fileName. Такому запросу автоматически устанавливается заголовок Content-Type со значением multipart/form-data. Запрос отправляется как HTML-форма с полем file, где закодировано содержимое файла в бинарном виде. Если fileName не указан, но fileUrl содержит название файла с расширением, будет взято оно. В противном случае именем файла будет случайный UUID. Типы данных запроса и ответа Чтобы указать тип данных, которые содержатся в запросе и ожидаются в ответе, используйте поле dataType. Обратите внимание на то, как оно взаимодействует с передаваемым HTTP-заголовком Content-Type. Возвращаемое значение Метод возвращает объект со следующими полями: Пример использования В следующем примере выполняется запрос к API сервиса OpenWeather, чтобы получить информацию о текущей погоде в запрашиваемом городе. Пример предполагает, что вы получили собственный ключ к API OpenWeather и сохранили его в проекте как токен OPENWEATHER_API_KEY. $http.query выполняет HTTP-запросы синхронно. Обработка запроса пользователя приостанавливается до тех пор, пока HTTP-запрос не вернет ответ. Во время обработки одного запроса можно выполнить не более 15 вызовов $http.query. При превышении этого лимита метод возвращает ответ со статусом -1 и ошибкой Callback limit reached.'
 'Для этого укажите название события в заголовке экрана: Вы можете выбрать любой цвет заголовка, а затем кликнуть на значок вебхука , чтобы он загорелся: Если событие на экране включено, то бот будет отправлять переменные и выбранное событие на сервер, а затем копировать переменные из ответа сервера. Только после этого бот будет выполнять блоки на экране. Переменные, полученные от вашего сервера, можно использовать точно так же, как и все другие – например, подставлять в текстовый ответ, использовать в условиях или в HTTP-запросах. Протокол вебхуков Aimylogic На каждом экране, где включено событие для вебхука, бот посылает POST-запрос, а в теле запроса передает объект JSON, в котором содержатся все текущие переменные бота, в том числе системные, а также поле action — текст события, которое вы прописали на этом экране: Ваш сервер должен вернуть в ответ JSON с нужными вашему боту переменными, которые он ожидает получить на этом экране: В этом примере сервер вебхука вернул переменные $lastSeen, $name и $data. Теперь бот может их использовать в своем сценарии начиная с того экрана, на котором он получил эти переменные. Чем вебхук отличается от блока HTTP-запрос? Вы бы могли использовать блок HTTP-запрос всякий раз, когда вашему боту нужно получить данные от вашего сервера.'
 'С помощью одного запроса можно передать сразу несколько переменных: Блок должен быть оформлен следующим образом: Метод GET Формирование URL Для создания URL скопируйте в блокнот строку: https&#x3A;//api.telegram.org/bot&lt;token>/sendMessage Затем перейдите в Telegram в канал BotFather и скопируйте токен вашего бота, который был сгенерирован, когда вы публиковали канал: В блокноте выделите &lt;token> И вместо &lt;token> вставьте токен из Telegram: Получится примерно следующий адрес: Теперь выделите строку целиком и вставьте ее в поле URL HTTP-запроса в Aimylogic Оформление поля BODY В BODY нам нужно указать: значение chat_id, которое мы получили ранее все переменные, которые мы до этого собрали в сценарии. Если вы повторили урок по сбору контактных данных, то в сценарии вы получили следующую информацию: Ваше имя: $name Ваша фамилия: $lastname Ваш телефон: $PHONE Ваш email: $EMAIL Вид услуги: $service Поэтому сейчас мы используем именно эти переменные. Итак, нужно вставить значение chat_id и перечислить переменные, которые были в сценарии до отправки. Обратите внимание на отступы и знаки препинания! Рекомендуем не набирать текст, а скопировать и вставить. { ""chat_id"": 123456789, ""text"": ""Имя клиента: $name $lastname, номер телефона: $PHONE, email: $EMAIL, Вид услуги: $service""} Нажмите Сохранить. Готово, мы оформили Http-запрос для отправки данных.'
 '$pushgate.createPushback Метод создает специальную сущность для обработки событий — пушбэк. Пушбэк используется для отправки событий в сценарий при каких-либо действиях в стороннем сервисе. Таким образом при помощи бота становится возможным создавать исходящие рассылки. Рассмотрим принцип работы пушбэков: В сценарии вызывается метод $pushgate.createPushback. При вызове в метод передаются идентификаторы нужного диалога и строка, определяющая тип события, например myEvent. Пушбэк регистрируется в платформе. Ему присваивается уникальный идентификатор pushbackId, который можно использовать в запросах к методам GET и POST /push\\_{pushbackId} Pushgate API. Когда в стороннем сервисе происходит событие, о котором необходимо уведомить клиента при помощи бота, сервис делает HTTP-запрос к методу /push\\_{pushbackId}, чтобы активировать пушбэк. Пушбэк генерирует в диалоге с клиентом заданное ранее событие myEvent, которое можно обработать при помощи тега event и отправить нужную информацию в диалог. Пушбэк привязан к диалогу с клиентом в определенном канале. Чтобы клиент получал уведомления в нескольких каналах, он должен дойти до соответствующего места сценария в каждом из них. Синтаксис Принимаемые аргументы Метод $pushgate.createPushback принимает 5 аргументов. Все аргументы являются обязательными. Возвращаемое значение Метод возвращает объект, в котором как поля содержатся все аргументы, переданные при вызове, а также 3 дополнительных поля, описывающие созданный пушбэк.'
 'Это связано с тем, что в CAILA невозможно создать сущность, которая бы обрабатывала произвольный текст. Разработка сценария В сценарии нам будут полезны возможности для обработки времени, которые предоставляет библиотека Moment.js. Вы можете импортировать ее из системного модуля dateTime, объявив в начале файла main.sc следующую зависимость: Далее продолжим разработку сценария. Рассмотрим предполагаемое взаимодействие бота с клиентом: Клиент просит поставить напоминание и по интенту /SetReminder попадает в соответствующий стейт. Слот-филлинг гарантирует, что бот попадет в обработчик стейта лишь после того, как клиент назовет время напоминания. Распознанное время сохраняется в поле $session.reminderTime. Бот запрашивает у клиента текст напоминания. Поскольку ответ клиента может быть любым, для его обработки используется системное событие noMatch, которое срабатывает при любом нераспознанном вводе. Ответ клиента обрабатывается в стейте GetReminder. В обработчике стейта планируется новое событие при помощи метода $pushgate.createEvent. В качестве времени наступления события передается ранее распознанное время в формате yyyy-MM-ddTHH:mm:ss, а в объекте с дополнительными данными — распознанный текст. Метод $pushgate.createEvent возвращает объект с идентификатором созданного события, который мы сохраняем в поле $session.reminderId — позже он нам пригодится.']"	Действие InputFile позволяет боту запросить у пользователя файл и сохранить ссылку на него в переменную.	['- Действие InputFile позволяет боту запросить у пользователя файл и сохранить ссылку на него в переменную.\n- InputFile позволяет боту запросить у пользователя файл и сохранить ссылку на него в переменную.']	0.8584208333061903	0.19999999998	1.0
Какой тег эмулирует отправку текстового сообщения боту?	"['&lt;q> Описание Тег &lt;q> эмулирует отправку текстового сообщения боту пользователем. Тело Текст сообщения, которое посылается боту. Примеры'
 '&lt;event> Описание Тег &lt;event> эмулирует отправку события боту. Тело Имя события. Примеры Пользователь Telegram отправил данные о своем местоположении. Пользователь прикрепил файл.'
 'Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений.'
 'Если его не будет, то при запуске бот найдет состояние, реагирующее на любой текстовый ввод, либо выведет ошибку обработки запроса. Клиент вводит сообщение Привет или Пока и получает соответствующий ответ от бота Привет привет или Пока пока. Глобальный тег intent! позволяет осуществить переход диалога в данный стейт из любого другого стейта. Например, клиент ввёл сообщение Пока, запрос попадет в стейт Bye, так как был активирован интент /пока. Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение клиента не подходит ни под один описанный стейт. При вводе клиентом сообщения, например Как дела?, активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Бот посылает сообщение Я не понял. Вы сказали: Как дела?. Подробнее ознакомьтесь с тегами в разделе DSL. Теперь перейдем к тестированию бота и созданию канала.'
 'Блокировать ввод текста при использовании кнопок — выберите Да, если хотите заблокировать клиенту возможность ввода текстовых сообщений, когда используете кнопки в сценарии. Разрешить пользователям отправлять файлы — в чате появится кнопка , с помощью которой можно будет отправлять файлы боту. Подсказка в поле ввода — фраза, которая будет отображаться в поле ввода до момента, когда пользователь начинает вводить текст сообщения. Расположение На десктопе — положение виджета на экране десктопа: отступ от правого края экрана или отступ от нижнего края экрана в пикселях. Вы можете увидеть изменения сразу же на экране и отрегулировать наиболее подходящее для вас расположение виджета. На мобильном — положение виджета на экране мобильного устройства: слева или справа. Вовлечение в диалог Всплывающее сообщение — сообщение бота, которое будет всплывать в диалоге при наступлении настроенных событий. Открыть окно чата по наступлению условия — выбор условия открытия чата: время, проведенное пользователем на сайте или на странице. Приветствие в окне чата — выбор сообщения бота, которое появится в чате после открытия окна. Сессия начнется после первого сообщения пользователя. Показать кнопки меню — при включенном параметре вы сможете добавить в чат-виджет до 8 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут.'
 'Для тега можно задать необязательные атрибуты: strictMatch — строгость сопоставления мок-объекта телу запроса. Значение по умолчанию: false. При нестрогом сопоставлении (false) проверяется, что все значения полей, указанные в теге &lt;body>, равны соответствующим значениям полей из тела запроса. При строгом сопоставлении (значение true) проверяется полное совпадение объекта в теге &lt;body> и тела запроса. field — JsonPath-выражение, указывающее на поле для сопоставления. Если атрибут указан, сопоставление производится не по всему объекту из тела запроса, а только по его части. Ответ &lt;response> — описание ответа, который вернет мок-объект в качестве ответа сервера. Обязательный элемент. В теле элемента указывается строка с ответом. Возвращаемое значение метода $http.query помимо HTTP-ответа в поле data содержит ряд служебных полей: isOk, status и другие. Данные поля не следует помещать в &lt;response>. Указывайте только ответ от сервера — то, что приходит в поле data. Возможные атрибуты для тега: status — код ответа на HTTP-запрос, по умолчанию 200. type — тип ответа, по умолчанию json. Если тип ответа json или xml, ответ парсится и возвращается в сценарий в виде JS-объекта. В противном случае ответ передается в виде строки. Если формат тела &lt;response> не соответствует указанному типу, при публикации бота возникнет синтаксическая ошибка.'
 'Блок Текст Используйте этот блок, когда бот должен вывести текстовое сообщение в чате с клиентом. В сценариях для звонков вместо блока Текст используйте блок Синтез речи. Параметры В параметрах блока можно указать один или несколько вариантов реплик, одну из которых бот будет выводить клиенту. Если нажать на кнопку Добавить другую реплику, то можно указать другой вариант реплики бота. В процессе диалога с клиентом бот будет случайным образом выбирать одну из реплик в этом блоке и выводить ее клиенту. После сохранения блока с несколькими репликами, вы будете видеть, сколько всего реплик вы добавили в этот блок. Использование переменных Вы можете подставлять переменные в выводимый текст. Например, если написать «Привет, $name!», то бот подменит $name на значение переменной name перед выводом. Вы также можете подставить несколько переменных в поле Реплика бота. Каждую переменную необходимо добавлять с новой строки. Если вы разместите несколько переменных на одной строке, то в боте появится ошибка. Несколько текстов подряд Можно поставить несколько блоков Текст подряд. Тогда бот выведет несколько реплик подряд, либо «склеит» тексты в одну реплику — зависит от канала, в котором работает бот. Разметка синтеза речи Вы можете добавить разметку синтеза речи для навыков голосовых ассистентов. Разметку синтеза речи нужно добавлять именно в поле Разметка синтеза речи. Настройка голосового синтеза При оформлении реплик бота вы можете при помощи разметки управлять синтезируемыми звуками.'
 'Название может содержать только латиницу и цифры, а также не должно пересекаться с названиями системных событий. Вы можете добавить и другие стейты, чтобы предусмотреть действия бота на разное поведение клиентов. В любом стейте с помощью тега script можно вызвать метод $analytics.setTextCampaignResult, чтобы присвоить рассылке результат. В дальнейшем это позволит провести аналитику по рассылке и оценить ее эффективность. Ниже приведен пример сценария рассылки, которая будет запущена по событию textCampaignEvent. Если реакция клиента совпадет с одним из интентов, рассылке будет присвоен соответствующий результат. Настройка события При создании рассылки, для которой вы написали сценарий, вы можете не использовать встроенный конструктор. Вместо этого укажите в поле Событие в сценарии (event) название события, по которому сработает нужный стейт. Вы также можете одновременно задать и содержимое рассылки, и название события. Тогда при рассылке бот сначала выполнит реакции, заданные через конструктор, а затем обработает событие в сценарии. Список рассылок Рассылки отображаются в списке, упорядоченном по времени создания. О каждой рассылке доступна следующая информация: Название. Дата создания. ID, уникальный в рамках аккаунта (например, #169). Нажмите на ID, чтобы быстро перейти в аналитику по диалогам, начатым при запуске этой рассылки. Прогресс в режиме реального времени: Канал. Название списка клиентов, которым отправляется рассылка. Дата и время запуска и завершения. Статус.'
 'Блок text to $var Блок text to $var позволяет боту получить текст от клиента и сохранить его в переменную. Блок доступен через меню Добавить экран → Еще блоки → text to $var. Полученные значения переменной можно использовать в последующих шагах сценария (например, обращение по имени), выгружать в .csv или отправлять в стороннюю систему (например, в свою базу данных). Подробнее о переменных Параметры При добавлении этого блока нужно указать текст, который бот будет показывать клиенту в качестве приглашения к вводу текста, а также имя переменной, в которую нужно сохранить введенный клиентом текст. Здесь бот напишет клиенту Введите текст и будет ожидать ввода произвольного текста. После того как клиент введет текст, бот сохранит его в переменную text и перейдет к следующему экрану сценария. Бот не будет каким-либо образом интерпретировать ввод, а просто сохранит все, что клиент ввел в переменную. Если вам нужно, чтобы бот реагировал на определенные фразы, используйте блок Интенты. HTML-разметка Вы можете использовать HTML-разметку в текстовых сообщениях. Для этого активируйте переключатель Использовать в сообщении HTML разметку. Не все каналы поддерживают HTML-разметку. Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений.'
 '&lt;a> Описание Проверяет: наличие ответа от бота; текст ответа; состояние, в котором ответ был сгенерирован; состояние, с которого началось выполнение сценария. В проверках текста не учитывается разница в пробелах и переносах строк. На каждую реплику бота a необходим тег &lt;a> в тестах. Атрибуты class — стейт, с которого началось выполнение сценария для текущего запроса, необязательный атрибут. state — стейт, в котором был сгенерирован ответ, необязательный атрибут. Тело Текст ожидаемого ответа, необязательно. Примеры Вместо текста в ответе &lt;a> можно указать стейт, в который переходит система. Для этого используйте атрибуты class и state. Атрибут class будет указывать на стейт, в который запрос пользователя был классифицирован. Атрибут state — на стейт, из которого был получен ответ. Например: Если нужно проверить, что сначала система попадает в один стейт, а потом при помощи go! переходит в другой, то можно использовать class как атрибут, указывающий на стейт, в который система попала первым. Затем используйте state как атрибут, указывающий на стейт, в который система попадает далее. Если после первого стейта идет последовательность переходов, они также должны быть описаны при помощи атрибута state. Например: class и state могут совпадать. Если проверяется один переход в стейт, целесообразнее использовать один из этих атрибутов при тестировании. Полная запись:']"	Тег &lt;q> эмулирует отправку текстового сообщения боту пользователем.	['- Описание Тег &lt;q> эмулирует отправку текстового сообщения боту пользователем.\n- Тело Текст сообщения, которое посылается боту.']	0.8325932450542961	0.9999999999	1.0
Какие значения может возвращать метод $dialer.getCallNotConnectedReason?	"['$reactions.random Метод возвращает случайное целое число в заданном диапазоне. Синтаксис Метод принимает один аргумент — целочисленное значение max: Метод возвращает случайное целое число в диапазоне от 0 до max (не включая max). Особенности Значения, которые возвращает метод, могут быть переопределены в XML-тестах при помощи тега &lt;random>, чтобы тесты проходили стабильно. Для встроенного JavaScript-метода Math.random переопределить возвращаемые значения нельзя. Поэтому использовать его в сценариях JAICP не рекомендуется. Возвращаемые значения могут быть переопределены в сценарии при помощи модификации объекта $request.data.smartRandom. Все возвращаемые значения записываются в $response и могут быть использованы для повторного выполнения сценария с такими же результатами. Метод гарантирует, что возвращаемые случайные числа не повторяются чаще, чем через max / 2 последовательных вызовов метода. Пример использования Напишем стейт, который эмулирует игру в кости и выдает сумму двух случайных чисел от 1 до 6:'
 '$dialer.getCallNotConnectedReason Метод возвращает причину, по которой звонок был неудачен. Используйте его только в сценариях, в которых предусмотрена обработка неудачных звонков при помощи события onCallNotConnected. Синтаксис Метод вызывается без аргументов и возвращает одно из двух строковых значений: BUSY (абонент занят) или NO_ANSWER (абонент не отвечает).'
 '$dialer.getAbonentTimezone Метод возвращает часовой пояс текущего клиента. Метод не предназначен для использования в сценариях ботов для входящих звонков и корректно работает только для обзвонов. Синтаксис Метод вызывается без аргументов и возвращает строку, содержащую часовой пояс клиента в формате ±hh:mm: Особенности Поведение метода зависит от настроек обзвона и способа добавления номера в обзвон: Для обзвона активен параметр Учитывать местное время: Если номер добавлен в обзвон через список номеров, содержащий столбец GMT_ZONE, метод возвращает часовой пояс, соответствующий указанному в списке номеров. Если номер добавлен в обзвон через Calls API и в запросе передано поле gmtZone, метод возвращает часовой пояс, соответствующий переданному в запросе. В противном случае метод возвращает часовой пояс, автоматически определенный по номеру телефона клиента. Если параметр Учитывать местное время неактивен, метод возвращает серверное время платформы JAICP. Использование в сценарии Данный метод в связке с $dialer.redial позволяет запланировать из сценария новую серию попыток дозвониться с учетом часового пояса клиента. Рассмотрим следующий пример стейта для обработки просьбы перезвонить позже. Для извлечения времени повторного звонка используется сущность @duckling.time. Альтернативное решение может опираться на методы сервиса $reactions для установки и получения часового пояса. Однако при такой реализации часовой пояс должен быть явно запрошен у клиента.'
 'Возможные значения: readDataFromCells writeDataToCells writeDataToLine deleteRowOrColumn clearCellData customRequest &lt;parameters> — список аргументов, передача которых ожидается при вызове метода. Содержит вложенные элементы, теги которых соответствуют названиям аргументов. Например, метод readDataFromCells принимает аргументы integrationId, spreadsheetId, sheetName и cells, поэтому элемент &lt;parameters> может быть заполнен так: &lt;response> — ответ в формате JSON, который будет принят за ответ от метода при выполнении теста. Пример Рассмотрим следующий фрагмент сценария. Бот принимает время и произвольный текст, которые он записывает в новую строку таблицы через метод writeDataToLine. Работу такого стейта можно проверить при помощи теста, приведенного ниже. Поскольку в примере используется сущность @duckling.time, для тест-кейса необходимо переопределить текущее время через тег &lt;dateTime>. В значении &lt;response> указаны не все поля, которые возвращает интеграция: достаточно перечислить лишь те поля, которые используются в коде сценария.'
 '$dialer.getDialHistory Метод позволяет получить историю состоявшихся и доступных попыток дозвониться на номер. Синтаксис Метод вызывается без аргументов и возвращает объект из четырех целочисленных полей. История текущей серии попыток Если при обзвоне абонент не отвечает, бот может сделать несколько попыток дозвониться до абонента. Последовательность попыток дозвониться образует серию. Если в ходе диалога с абонентом бот планирует новый звонок при помощи метода $dialer.redial, серия попыток сбрасывается — новые попытки происходят уже в рамках новой серии. Поля completedAttempts и availableAttempts отражают историю текущей серии попыток: completedAttempts — число попыток дозвониться, сделанных в рамках текущей серии. После очередной попытки дозвониться значение поля увеличивается на единицу. Если из сценария планируется новая серия попыток, значение поля обнуляется. availableAttempts — число попыток дозвониться, доступных в текущей серии. Если номер добавлен в обзвон при помощи списка клиентов, то значение поля соответствует значению счетчика Начальное количество, заданному при создании обзвона. Если номер добавлен в обзвон при помощи запроса к Calls API с явно переданным значением поля maxAttempts, то значение availableAttempts совпадает с maxAttempts. Если из сценария бота запланирована новая серия и при вызове $dialer.redial явно передано поле maxAttempts, то значение availableAttempts также совпадает с maxAttempts.'
 '$dialer.getAsrConfig Метод возвращает настройки провайдера ASR телефонного канала, через который проходит текущий звонок. Синтаксис Метод вызывается без аргументов: Метод возвращает объект с настройками. Поля этого объекта отличаются в зависимости от провайдера. Если у провайдера нет дополнительных настроек, метод возвращает пустой объект {}. Все настройки, которые возвращает метод, можно переопределить для текущего звонка при помощи метода $dialer.setAsrConfig. Настройки провайдеров Google lang Язык, на котором распознается речь. model Языковая модель для распознавания речи. Яндекс lang Язык, на котором распознается речь. model Языковая модель для распознавания речи. numbersAsWords Если параметр включен, то обозначения чисел указываются в распознанном тексте в словесной, а не цифровой записи (например, тринадцать вместо 13). sensitivityReduction Включенный параметр уменьшает чувствительность распознавания к фоновому шуму. Azure language Язык, на котором распознается речь. outputFormat Формат вывода данных. profanityOption Параметр определяет, что делать с обсценной лексикой в распознанном тексте: фильтровать, маскировать или оставлять как есть. enableDictation Параметр включает распознавание речи под диктовку. В этом режиме слова, обозначающие знаки препинания и другие элементы разметки, распознаются как спецсимволы (например, запятая как ,). АСМ Решения model Языковая модель для распознавания речи. sampleRate Частота дискретизации.'
 '$pushgate.createEvent Метод создает событие, которое наступит в заданное время. Синтаксис Принимаемые аргументы Метод $pushgate.createEvent принимает 6 аргументов. Обратите внимание на следующие особенности задания даты и времени события: Строка, переданная в аргументе dateTime, должна иметь формат yyyy-MM-ddTHH:mm:ss. Отправка, запланированная на прошедшее время, не вызовет ошибки, но будет выполнена немедленно. В поле eventData вы можете передать любые данные, которые потребуются при наступлении события. Данные будут доступны в обработчике события в поле $request.rawRequest.eventData. Возвращаемое значение Метод возвращает объект с одним полем id — идентификатором созданного события. Идентификатор используется для отмены события при помощи метода $pushgate.cancelEvent. Учет часового пояса Планирование событий из сценария происходит с учетом часового пояса, который был задан для клиента при помощи метода $reactions.setClientTimezone. Если часовой пояс для клиента не задан, по умолчанию используется часовой пояс, указанный в настройках проекта на вкладке Классификатор. Пример Рассмотрим пример создания будильника при помощи сообщений от бота. Когда клиент отвечает, в какое время нужно поставить будильник, он попадает в стейт Time. Названное им время извлекается из запроса при помощи сущности Duckling — @duckling.time. В значении сущности @duckling.time есть поле value — строка, описывающая распознанное время и удовлетворяющая формату, требуемому $pushgate.createEvent.'
 '$dialer.getTransferStatus Метод возвращает статус перевода звонка на оператора. Синтаксис Метод вызывается без аргументов: Метод возвращает объект со свойствами:'
 '$dialer.setNoInputTimeout Метод позволяет изменить стандартный таймаут (5 секунд) при событии speechNotRecognized для нужного стейта. Метод не поддерживается, если провайдер ASR подключен к телефонному каналу по протоколу MRCP. Синтаксис Метод принимает в качестве аргумента целочисленное значение — таймаут в миллисекундах. Использование в сценарии Особенности Допустимые значения: от 1000 (1 секунда) до 20000 (20 секунд). Если превысить диапазон, будет использован максимальный таймаут — 20 секунд. Если задать значение ниже диапазона, будет использован минимальный таймаут — 1 секунда. Метод $dialer.setNoInputTimeout действует только в том стейте, в котором он был вызван. Чтобы изменить таймаут и в других стейтах, нужно отдельно вызвать в них метод или использовать обработчик postProcess:'
 'Параметры Метод $dialer.redial принимает в качестве аргумента объект со следующими полями: Передаваемый объект обязательно должен содержать поля startDateTime или allowedTime. Если прочие поля не указаны, их значения будут взяты из настроек обзвона. Формат значений полей allowedDays и allowedTime полностью аналогичен одноименным полям в теле запроса к методу POST /addPhones API для звонков.']"	Метод $dialer.getCallNotConnectedReason может возвращать два значения: BUSY (абонент занят) или NO_ANSWER (абонент не отвечает).	['- $dialer.getCallNotConnectedReason Метод возвращает причину, по которой звонок был неудачен.\n- Используйте его только в сценариях, в которых предусмотрена обработка неудачных звонков при помощи события onCallNotConnected.\n- Синтаксис Метод вызывается без аргументов и возвращает одно из двух строковых значений: BUSY (абонент занят) или NO_ANSWER (абонент не отвечает).']	0.9008722978809196	0.49999999995	1.0
Какие способы разметки текста предлагает Aimyvoice для управления звучанием с использованием SSML-тегов и упрощенной разметки?	"['Разметка синтеза речи При написании ответов бота в телефонном канале вы можете использовать специальную разметку, чтобы управлять звучанием произносимых слов и фраз при синтезе речи бота. Элементы разметки отличаются в зависимости от используемого провайдера TTS. SSML SSML (Speech Synthesis Markup Language) — язык разметки синтеза речи, основанный на XML. SSML позволяет гибко настраивать речь бота, тем самым делая ее более естественной и выразительной. Вы можете ознакомиться со списком поддерживаемых тегов SSML в документации выбранного провайдера. В JAICP SSML-разметка поддерживается для следующих провайдеров TTS: Aimyvoice Azure Google Яндекс Использовать разметку SSML в сценарии можно несколькими способами: Тег реакции a. После тега укажите параметр tts и передайте в нем размеченный текст: Ответы с типом text. Передайте размеченный текст в поле tts объекта с ответом: Метод $reactions.answer. Передайте размеченный текст в поле tts аргумента метода: Упрощенная разметка Провайдеры Яндекс и Google также поддерживают упрощенную разметку синтеза речи, не совместимую с SSML. Если возможностей упрощенной разметки для вас достаточно, то используйте ее вместо SSML. Использовать упрощенную разметку можно в теге a, ответе типа text и методе $reactions.answer. Если вы используете упрощенную разметку, не передавайте в ответе дополнительное поле tts.'
 'В данной подсекции ключи представляют собой ISO-коды языков, а значения — тексты сообщений. В поле defaultMessage указывается текст сообщения по умолчанию, которое отправляется в случае, если секция locales не задана или в ней не задан нужный язык. Также можно задать список сообщений по умолчанию в поле defaultMessages — тогда при ответе будет выбрано случайное из них. Если секция messages.onError не заполнена, то в случае возникновения ошибки бот не ответит клиенту. Для настройки более гибкого поведения при внештатных ситуациях используйте обработчики ошибок. Injector Секция injector позволяет задать параметры конфигурации чат-бота. Заданные параметры будут доступны в скриптах чат-бота через переменную $injector. Подробнее об $injector Настройки SMTP-сервера Секция injector.smtp позволяет задать настройки SMTP-сервера, через который будут отправляться email-сообщений при помощи метода $mail.sendMessage. Другие настройки Возможность изменения запроса Поле nlp.modifyRequestInPreMatch включает возможность изменять содержимое запроса в обработчике preMatch — например, редактировать текст запроса. Токенизация слов в паттернах Поле tokenizeWordsInPatterns включает токенизацию слов в паттернах для языков без разделителей между словами. Поле обязательно для корректной работы паттернов в проектах на китайском языке. Порядок загрузки файлов Поле scenarioLoadStrategy задает порядок загрузки файлов в сценарий, состоящий из множества файлов.'
 'Разметка синтеза речи Aimyvoice позволяет размечать синтезируемый текст, чтобы управлять его звучанием: задавать паузы, ударения, тон и другие особенности произношения. Разметка делает звучание более естественным и выразительным. Вы можете размечать текст двумя способами: Чтобы расставлять в тексте ударения и паузы, используйте упрощенную разметку при помощи специальных символов и знаков препинания. Чтобы задавать правила произношения отдельных слов, управлять громкостью, стилем и другими характеристиками речи, используйте SSML-теги. SSML (Speech Synthesis Markup Language) — язык разметки синтеза речи, основанный на XML. Упрощенная разметка Поддерживаемые SSML-теги &lt;break> Добавляет в текст паузу. Для обозначения пауз также можно использовать знаки препинания. Если тег &lt;break> использован совместно со знаками препинания, то он имеет более высокий приоритет и заменяет другие паузы. Возможные атрибуты: time — длительность паузы. Указывается в формате &lt;число>s (в секундах) или &lt;число>ms (в миллисекундах). Максимальная длительность — 5 секунд. При значении более 2 секунд фактическая длительность паузы может отличаться от указанной на ±200 миллисекунд. breath — логическое значение 0 или 1. Указывает на необходимость синтеза вдоха в конце паузы. Значение по умолчанию — 0. breath_power — целое или дробное число в диапазоне 0–1. Задает силу вдоха: чем больше значение, тем вдох будет громче.'
 '$analytics.setMessageLabel Метод проставляет метки фразам клиента. Синтаксис Метод принимает два аргумента: Проставленная метка появится в интерфейсе раздела Аналитика > Диалоги, а также в отчете по фразам. Особенности Прежде чем добавлять метку в сценарии, нужно создать группу и метку в интерфейсе. Для этого нажмите в правом верхнем углу экрана и перейдите Справочник меток > Метки фраз. Если при вызове метода указана метка, которой нет в интерфейсе, то такая метка не добавится. Если метка неактивна в интерфейсе, то она все равно будет добавлена в отчет. Если существует несколько меток с одинаковыми именами, то будут проставлены все такие метки. Использование в сценарии'
 'Распознавание и синтез речи В ботах, которые совершают и принимают звонки, используется распознавание и синтез речи: Automatic Speech Recognition (ASR) или распознавание речи — процесс преобразования речи в текст. Text-To-Speech (TTS) или синтез речи — процесс генерации речи по печатному тексту. При создании телефонного канала вы можете: Выбрать одного из провайдеров ASR/TTS, предоставляемых Just AI. В этом случае из интерфейса JAICP вы можете задать настройки синтеза и распознавания речи: например, выбрать модель распознавания, голос для синтеза и другие параметры. Создать подключение с использованием собственного аккаунта одного из провайдеров ASR/TTS. Если для ASR/TTS вы используете собственное подключение, использование минут ASR/TTS Just AI для вас не тарифицируется. Затем для формирования ответов из сценария вам нужно будет использовать тег a или метод $reactions.answer. Разметка синтеза речи Чтобы сделать речь бота более выразительной, вы можете использовать разметку синтеза речи. JAICP поддерживает специальный язык разметки синтеза речи (SSML), который позволяет настраивать тон, произношение, скорость, громкость речи и пр. Подробнее см. в разделе Разметка синтеза речи. Синтез речи с переменными Вы также можете использовать синтез речи с переменными, если хотите, чтобы бот озвучивал в диалоге переменные значения, зависящие от контекста. Подробнее см. в разделе Синтез речи с переменными.'
 'Перейдите на вкладку Сохранение в интенты на верхней панели, чтобы подтвердить добавление. Окно выбора интента По интентам Эта разметка позволяет разобрать фразы по интентам, которые уже существуют в проекте. Каждой распознанной фразе присваивается вес от 0 до 1 — это степень уверенности в том, что она действительно содержится в интенте. Чтобы отфильтровать фразы по весу, воспользуйтесь ползунком. С помощью опции Скрыть конфликтные вы можете скрыть фразы, которые подходят к нескольким интентам. По дубликатам Эта разметка позволяет выделить в датасете одинаковые фразы. Если вы удаляли дубликаты во время предобработки фраз, эту разметку проводить не нужно. По ключевым словам Эта разметка позволяет выделить во фразах ключевые слова и сгруппировать по ним датасет. Методы выделения ключевых слов: Частотный на основе меры TF-IDF. Синтаксический, который использует парсер UDPipe. Не для всех параметров можно определить универсальные оптимальные значения. Подбирайте значения параметров, опираясь на содержание вашего датасета. Частотный метод Мера TF-IDF позволяет оценить значимость слова в контексте фразы и всего датасета. Чем важнее слово для определения тематики фразы внутри датасета, тем больше значение меры. Значение меры — это произведение двух множителей: TF (term frequency) — частота слова во фразе. IDF (inverse document frequency) — число всех фраз в датасете, разделенное на число фраз с нужным словом. IDF слова повышается, если оно встречается в небольшом числе фраз.'
 'Инструменты для разметки При помощи кнопок в текстовом окне вы можете применять разные стили к тексту:'
 'Расширенные элементы паттернов $pattern_name $название-паттерна — ссылка на именованный паттерн. Подробнее об именованных паттернах Использование в сценарии Объявление паттерна: Использование паттерна в сценарии: ~lemma ~lemma проверяет все формы слова. Слово после тильды должно стоять в словарной форме. Например, в паттерн ~яблоко попадут слова: яблоки, яблок и др. Правило срабатывает на всех словоформах всех омонимов: слов, которые звучат и пишутся одинаково, но имеют разные значения или морфологическую форму. Например, паттерн ~печь сработает на словоформах существительного печь (печи, печью) и глагола печь (пеку, печешь). Из-за морфологического разнообразия языка использование этого паттерна может приводить к ложноположительным результатам. Использование в сценарии $morph Элемент $morph&lt;свойство> проверяет совпадение по слову с определенными грамматическими свойствами. Список поддерживаемых свойств зависит от того, какой диалоговый движок использует проект. botEngine: v1 На первой версии диалогового движка для морфологического анализа используется парсер AOT. Используйте для грамматических свойств условные обозначения для русского и английского языка. Указывайте их внутри угловых скобок через пробел. Кроме того, на этой версии $morph позволяет проверить совпадение по одному или сразу по нескольким свойствам.'
 '$reactions.answer Метод выводит простой текстовый ответ. Синтаксис Метод может принимать в качестве аргумента объект или строку. Строка Укажите строку, определяющую текстовый ответ: В тексте ответа вы можете использовать подстановки в скобках {{}}, внутри которых может находиться любое допустимое выражение на JavaScript. Также в тексте ответа можно задать упрощенную разметку синтеза речи для провайдеров Яндекс и Google: Объект Помимо строки метод также принимает объект, в котором кроме обычного текста ответа вы можете передать текст с HTML-разметкой или разметкой для синтеза речи. Примеры использования Текст ответа с упрощенной разметкой синтеза речи: Текст ответа с SSML-разметкой: Текст ответа с HTML-разметкой: HTML-разметку поддерживают только чат-виджет, Chat API и Telegram. В других каналах клиент получит обычное сообщение без разметки.'
 'YAML-справочники YAML-справочники используются для хранения различных структурированных данных для проекта. Примеры использования YAML-справочников: Вы можете вынести в YAML-справочник тексты ответов бота, чтобы хранить их в одном месте и поддерживать отдельно от кода бота. Следует хранить в отдельных справочниках параметры конфигурации бота, которые часто используются и могут изменяться: ключи к внешним API, ограничения на различные счетчики и т. д. Формат YAML-справочники хранятся в файлах с расширением .yaml или .yml. YAML — простой формат для записи типизированных значений и стандартных структур данных: последовательностей и пар вида «ключ — значение» произвольной степени вложенности. Например: Если вы хотите использовать строки из YAML-словаря после тегов реакций или действий, вы можете использовать в них строковые подстановки. Внутри скобок {{}} может находиться любое допустимое выражение на JavaScript. Во время работы бота оно будет вычислено и подставлено в строку. Подключение Для подключения YAML-справочника к сценарию воспользуйтесь тегом require с параметром var: При подключении справочник будет преобразован в эквивалентный объект JavaScript, который будет доступен из кода сценария по имени переменной, указанному после var. Использование в сценарии Воспользуемся справочником выше, чтобы вывести случайный ответ на нераспознанный текст. Для генерации случайного числа воспользуемся методом $reactions.random.']"	Aimyvoice предлагает два способа разметки текста для управления звучанием: использование SSML-тегов и упрощенной разметки. SSML-теги позволяют задавать правила произношения отдельных слов, управлять паузами, ударениями, тоном и другими характеристиками речи. Упрощенная разметка, поддерживаемая провайдерами Яндекс и Google, позволяет использовать специальные символы и знаки препинания для задания пауз и ударений.	['Чтобы расставлять в тексте ударения и паузы, используйте упрощенную разметку при помощи специальных символов и знаков препинания.\nЧтобы задавать правила произношения отдельных слов, управлять громкостью, стилем и другими характеристиками речи, используйте SSML-теги.\nУпрощенная разметка\nПоддерживаемые SSML-теги &lt;break> Добавляет в текст паузу.\n&lt;emphasis> Задает место фразового ударения в предложении.\n&lt;p> Добавляет паузу, по длительности равную паузе между абзацами.\n&lt;prosody> Задает громкость, темп и тон речи.\n&lt;s> Добавляет паузу, по длительности равную паузе после точки.\n&lt;say-as> Задает словесное ударение и другие правила озвучивания текста.\n&lt;style> Изменяет манеру (стиль) речи диктора.\nОсновные стили Чтобы использовать один из основных стилей, укажите у тега &lt;style> атрибут name.\nСлучайные стили В Aimyvoice вы также можете использовать случайные стили.']	0.966841880070432	0.6666666666444444	1.0
Как настроить внешний вид чат-виджета в Aimylogic?	"['Как добавить ChatGPT в бота из конструктора'
 'В появившемся окне вы можете настроить графический интерфейс чат-виджета. Здесь вы можете изменить следующие элементы внешнего вида и поведения: Общие настройки Оформление Заголовок чата Окно чата Отправка сообщений Расположение Вовлечение в диалог Звуковые уведомления Установка Общие настройки Название — название канала, отображается в списке каналов. Токен — уникальный идентификатор бота. Используется в ссылке скрипта для встраивания чат-виджета на сайт. Ветка — ветка проекта, которая будет развернута в канал. Оператор — операторский канал, в который при необходимости будут направляться запросы клиентов. Публикация — способ публикации канала: автоматически после сохранения изменений в проекте или вручную. Показывать % пользователей — процент пользователей, которые увидят виджет на сайте. Показывать кнопку закрытия виджета — при включенной опции у иконки виджета появится кнопка, с помощью которой пользователь сможет закрыть виджет. Чтобы виджет появился вновь, нужно обновить страницу. Копировать настройки проекта — вы можете применить настройки из уже созданного канала к текущему. Если у вас был ранее опубликованный чат-виджет с темой По умолчанию, то его настройки не будут доступны для копирования. Для применения настроек замените тему на По умолчанию (beta). Оформление В этом разделе вы можете настроить: Тип шрифта Размер шрифта Размер аватаров бота и пользователя Цветовую тему На выбор представлены несколько цветовых тем.'
 'Как изменить стиль чат-виджета В Aimylogic есть удобный графический редактор, в котором вы можете настроить внешний вид вашего чат-виджета. При настройке внешнего вида разных элементов окна чат-виджета вы сразу увидите изменения в чат-виджете на этой же странице. Чтобы перейти к настройкам стилей, на странице Каналы нажмите на иконку напротив подключенного канала чат-виджет. Aimylogic позволяет настраивать следующие элементы внешнего вида и поведения чат-виджета: Оформление Заголовок чата Окно чата Отправка сообщений Расположение Вовлечение в диалог Звуковые уведомления Дополнительные настройки Установка Оформление В разделе Оформление вы можете: Выбрать шрифт. Установить размер шрифта. Настроить цветовую тему. Выбрать размер для аватаров бота и пользователя. На выбор представлено несколько цветовых тем. Вы также можете создать собственную цветовую тему — для этого выберите любую тему и внесите изменения в поля ниже. Новая тема сохранится под иконкой кастомизированной темы, и вы сможете вернуться к ней в любой момент. Заголовок чата В разделе Заголовок чата вы можете настроить: Название для чат-бота, которое будет размещаться в заголовке чат-виджета. Аватар чат-бота. Окно чата В разделе Окно чата вы можете настроить: Имена участников диалога: Будут ли показываться имена участников чата. Какое имя будет отображаться для бота, клиента и оператора. Если вы включите опцию Показывать имена, но не укажете имена, они отображаться не будут.'
 'Настройка параметров чат-виджета при установке в iframe Для настройки параметров чат-виджета при установке в iframe: При установке в iframe с использованием внешнего скрипта: в обработчике событий onWidgetReady вызовите метод addJuswidgetVariables(), например: При установке в iframe с использованием кастомных обработчиков: измените добавляемый на страницу скрипт на скрипт с методом addJuswidgetVariables: Для настройки параметров чат-виджета после инициализации вызовите метод justWidgetApi.addJuswidgetVariables, например:'
 'Если настройка выключена, новое сообщение отображается только на активной вкладке с чат-виджетом. Звуковые уведомления В данном разделе вы можете настроить: Наличие звукового уведомления: При получении сообщения от клиента и бота. При получении сообщения от бота. При получении сообщения от клиента. Ни для каких сообщений. Звук для уведомления: Juntos. For sure. Just maybe. Дополнительные настройки В разделе Дополнительные настройки вы можете: Включить кнопку закрытия виджета. Если пользователь закрыл виджет, ему потребуется обновить страницу, чтобы виджет появился вновь. Указать процент клиентов, которым будет показываться чат-виджет. Скопировать настройки из другого проекта: если у вас уже есть все нужные настройки чат-виджета в другом проекте, вы можете перенести их в текущий проект. Для этого выберите из выпадающего списка название проекта, настройки которого вы хотите скопировать. Установка В разделе Установка вы можете: Скопировать код чат-виджета, чтобы вставить его на ваш сайт. Активировать опцию встраивания виджета в контейнер на странице и указать идентификатор нужного элемента страницы, в который вы хотите встроить чат-виджет.'
 'Чат-виджет: установка в iframe Вам может потребоваться установить чат-виджет в iframe. В Aimylogic это можно сделать двумя способами: с использованием внешнего скрипта с использованием кастомных обработчиков С использованием внешнего скрипта Для встраивания на сайт чат виджета в iframe необходимо: Добавить на страницу иконку чат виджета, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-button"" по клику на кнопку должен вызыватьjustWidgetApi.open() Добавить на страницу кнопку закрытия, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-close""; по клику на кнопку должен вызывать justWidgetApi.close() Добавить на страницу iframe, который должен быть скрыт на момент загрузки страницы. Элемент: должен иметь id=""justwidget--iframe"" пустой атрибут src (src="""") Добавить на страницу скрипт: Имплементировать обработчики событий: Например: После инициализации виджета вы можете подключить к нему стили. Для этого вызовите: После полной загрузки страницы вызовите С использованием кастомных обработчиков Для встраивания на сайт чат-виджета в iframe необходимо: Добавить на страницу иконку чат-виджета, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-button""; по клику на кнопку должен вызывать justWidgetApi.open() Добавить на страницу кнопку закрытия, на момент загрузки страницы должна быть скрыта.'
 'Оформление графического интерфейса чат-виджета Вы также можете создать собственную цветовую тему. Для этого внесите изменения в любую готовую цветовую тему. Новая тема сохранится под иконкой кастомизированной темы, и вы сможете вернуться к ней в любой момент. Все внесённые изменения сразу применяются к чат-виджету, который расположен в правом углу экрана. Нажмите на него и оцените внешний вид чат-виджета. Заголовок чата Название — название чат-виджета, которое будет отображаться в заголовке. Аватар — загрузка пользовательского аватара для чат-виджета вместо изображения по умолчанию. Аватар бота — изображение, которое отображается, когда виджет свернут. Окно чата Имена — выбор имени участников чата: пользователя, бота и оператора. Сообщения, отправленные оператором, подписываются именем оператора из операторского канала. Если из операторского канала имя не удалось получить, то используется имя, указанное в конфигурации чат-виджета. Аватарки — загрузка аватара для участников чата. Предварительный просмотр ссылок — в сообщении бота будет отображаться содержимое ссылки. Анимация при ожидании ответа бота — бот будет имитировать набор текста, если ожидание ответа длится дольше 2 секунд. Отправка сообщений Пользователи отправляют сообщения — выбор способа отправки сообщений: по нажатию Enter и по нажатию на кнопку в окне чата или только по нажатию Enter.'
 'Условия открытия чата: Спустя какое количество времени пребывания клиента на сайте открывать чат-виджет. Спустя какое количество времени пребывания клиента на странице открывать чат-виджет. Приветствие в окне чата: Показывать ли приветствие в начале диалога. Текст приветствия. Показывать ли кнопки меню. Текст кнопок меню. Используя опцию Приветствие в окне чата, вы можете экономить уникальных пользователей. Если опция отключена, уникальный пользователь спишется сразу после открытия клиентом чат-виджета. Если опция включена, уникальный пользователь спишется только после того, как клиент ответит боту на приветствие. При включенном параметре Показать кнопки меню вы сможете добавить в чат-виджет до 12 кнопок, чтобы помочь клиенту выбрать тему разговора до начала диалога. При выключенном параметре кнопки не будут отображаться в чате, но настройки не пропадут. Вы также можете сделать инлайн-кнопку и передать в нее ссылку на любой источник. Для этого нажмите на иконку на выбранной кнопке. Отображение кнопок только над формой ввода: Если настройка активна, инлайн-кнопки будут отображаться рядом с обычными кнопками над формой ввода. Если настройка неактивна, инлайн-кнопки будут отображаться в поле чата. Отображение нового сообщения миганием вкладки (по умолчанию включено). Если настройка включена, оповещение о новом сообщении от бота или оператора отображается на вкладке, когда она неактивна.'
 'Как настроить внешний вид чат-виджета с помощью CSS В Aimylogic есть удобный графический конструктор, в котором вы можете настроить внешний вид вашего виджета, не прибегая к программированию. Мы написали отдельную статью о том, как им пользоваться. Но также вы можете использовать CSS для настройки внешнего вида чат-виджета. Далее мы приводим примеры того, как можно изменить разные элементы с помощью CSS. Размер логотипа Размер диалогового окна Текст сообщений Кнопки Размер кнопок Изменить кнопку отправки Имена клиента и бота Имя и сообщения бота Имя и сообщения пользователя Аватары Аватар бота Аватар пользователя Аватар пользователя фон Быстрые ссылки Ссылки Заголовок виджета Поле ввода сообщения Сместить виджет Все или часть этих стилей вы можете описать в своем CSS файле на сайте.'
 'Чат-виджет: установка в iframe Установить чат-виджет в iframe можно с использованием: внешнего скрипта; кастомных обработчиков. Установка в iframe с использованием внешнего скрипта Для встраивания на сайт чат-виджета в iframe необходимо: Добавить на страницу иконку чат-виджета, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-button""; по клику на кнопку должен вызывать justWidgetApi.open(). Добавить на страницу кнопку закрытия, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-close""; по клику на кнопку должен вызывать justWidgetApi.close(). Добавить на страницу &lt;iframe>, на момент загрузки страницы должен быть скрыт. Элемент: должен иметь id=""justwidget--iframe""; пустой атрибут src (src=""""). Добавить на страницу скрипт: Имплементировать обработчики событий: Например: После инициализации виджета вы можете подключить к нему стили. Для этого вызовите: justWidgetApi.addCustomStyles(&lt;url\\_внешнего\\_css\\_файла>). После полной загрузки страницы вызывать justWidgetApi.init(""&lt;токен\\_виджета>""). Установка в iframe с использованием кастомных обработчиков Для встраивания на сайт чат-виджета в iframe необходимо: Добавить на страницу иконку чат-виджета, на момент загрузки страницы должна быть скрыта. Элемент: должен иметь id=""justwidget--asst-button""; по клику на кнопку должен вызывать justWidgetApi.open(). Добавить на страницу кнопку закрытия, на момент загрузки страницы должна быть скрыта.']"	В Aimylogic есть удобный графический конструктор, в котором вы можете настроить внешний вид вашего чат-виджета. Вы можете изменить элементы внешнего вида и поведения, такие как оформление, заголовок чата, окно чата, отправка сообщений и другие. Вы можете выбрать шрифт, размер шрифта, размер аватаров, цветовую тему и настроить другие параметры. Вы также можете создать собственную цветовую тему и применить её к чат-виджету. Для более детальной настройки внешнего вида чат-виджета вы можете использовать CSS.	['- В Aimylogic есть удобный графический редактор, в котором вы можете настроить внешний вид вашего чат-виджета.\n- Aimylogic позволяет настраивать следующие элементы внешнего вида и поведения чат-виджета: Оформление, Заголовок чата, Окно чата, Отправка сообщений, Расположение, Вовлечение в диалог, Звуковые уведомления, Дополнительные настройки.\n- В разделе Оформление вы можете: Выбрать шрифт, Установить размер шрифта, Настроить цветовую тему, Выбрать размер для аватаров бота и пользователя.\n- В разделе Заголовок чата вы можете настроить: Название для чат-бота, которое будет размещаться в заголовке чат-виджета, Аватар чат-бота.\n- В разделе Окно чата вы можете настроить: Имена участников диалога, Аватарки участников диалога, Предварительный просмотр ссылок, Анимацию при ожидании ответа бота.\n- В разделе Отправка сообщений вы можете настроить: Отправку сообщения клиентом, Блокировку ввода текста при использовании кнопок, Отображение кнопки прикрепления файлов в поле ввода текста, Подсказку в поле ввода текста.\n- В разделе Расположение вы можете настроить: Для десктопа - отступ виджета от правого края страницы и отступ виджета от нижнего края страницы, Для мобильных устройств - место страницы, где будет размещаться значок чат-виджета.\n- В разделе Вовлечение в диалог вы можете настроить: Всплывающее сообщение, Условия открытия чата, Приветствие в окне чата, Показывать ли кнопки меню.\n- В разделе Звуковые уведомления вы можете настроить: Наличие звукового уведомления и звук для уведомления.\n- В разделе Дополнительные настройки вы можете включить кнопку закрытия виджета.']	0.9562413311479284	0.7198412698322718	1.0
На каких языках можно создавать бота, чтобы включить испанский, португальский или казахский в проект?	"['Как добавить ChatGPT в бота из конструктора'
 'На каких языках можно создавать бота? Вы можете создавать ботов на русском или на английском языках. Для чат-ботов также доступен испанский, португальский и казахский языки. Вы не сможете изменить язык бота после того, как создадите проект.'
 'Поддержка других языков Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов Поддержка русского языка Поддержка других языков (вы находитесь здесь) Публикация в канал В следующем разделе пошагового сценария мы создадим бота на английском языке в составе многоязычного бота. Создайте новый проект, в качестве языка NLU выберите английский. Наполнение интентов Бот на английском языке должен поддерживать ровно те же интенты /hello и /book, что и бот на русском языке, с отличиями только в языке тренировочных фраз и вопросов для слот-филлинга. Интент для бронирования Сценарий Код англоязычного бота будет практически полностью совпадать с русскоязычным: изменения затронут только конфигурацию и тексты ответов. В разделе injector файла chatbot.yaml потребуется указать ISO-код английского языка вместо русского: В файле main.sc переведите все тексты ответов бота на английский язык, а также измените путь к зависимости на справочник имен на английском языке: Файл routerClient.js скопируйте из русскоязычного бота без изменений. Подключение к роутеру Так же, как и для русского языка, опубликуйте созданного бота в любом канале, скопируйте идентификатор бота и зарегистрируйте его в injector бота-роутера: Другие языки В многоязычного бота, построенного по приведенной схеме, легко добавить поддержку произвольного числа других языков.'
 'Поддержка русского языка Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов Поддержка русского языка (вы находитесь здесь) Поддержка других языков Публикация в канал В этом разделе мы создадим бота на русском языке — второй составляющей бота, который будет понимать несколько языков одновременно. В JAICP вновь создайте новый проект, в качестве языка NLU для данного проекта выберите русский. Перейдите в раздел CAILA. Наполнение интентов Бот для данного пошагового сценария будет запрашивать имя клиента и номер комнаты для бронирования. Создайте через интерфейс CAILA два интента: /hello — интент для обработки приветствия. Добавьте для него такие тренировочные фразы, как добрый день, здравствуйте, привет. /book — интент, обрабатывающий запросы о бронировании комнаты по номеру. Включите для данного интента слот-филлинг, после чего настройте по образцу того, как показано ниже. Интент для бронирования Сценарий Дескриптор сценария Перейдите на вкладку Редактор для написания кода сценария. В конфигурации каждого одноязычного бота необходимо задать ISO-код языка, который он поддерживает. Добавьте этот параметр в раздел injector файла chatbot.yaml, чтобы он стал доступен из сценария. Функции Создайте в папке src файл routerClient.js. Функции из этого файла будут отвечать за взаимодействие с ботом-роутером.'
 'Бот для маршрутизации запросов Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов (вы находитесь здесь) Поддержка русского языка Поддержка других языков Публикация в канал В этом разделе мы напишем реализацию бота-роутера, предназначенного для маршрутизации запросов клиента в одноязычного бота на нужном языке. Перейдите в JAICP и создайте новый проект. Язык NLU и другие настройки данного проекта могут быть любыми. Перейдите в раздел Редактор. Дескриптор сценария В соответствии с предложенной схемой многоязычного бота роутер должен иметь доступ к следующим конфигурируемым параметрам: Язык основного одноязычного бота, на который по умолчанию будет посылаться первый запрос. Текст сообщения в случае, если поступил запрос на неподдерживаемом языке. Идентификаторы всех одноязычных ботов, между которыми необходимо переключать контекст. Зададим данные параметры в разделе injector дескриптора сценария chatbot.yaml: Значение поля defaultLanguage и ключи в словаре bots должны соответствовать ISO-кодам языков, которые будет поддерживать бот. Значения словаря bots временно оставьте пустыми. Заданные параметры будут доступны из сценария через объект $injector. Функции Создадим в папке src файл router.js и поместим туда код, реализующий функциональность бота-роутера. Рассмотрим используемые функции. Все функции в числе аргументов принимают объект $context, представляющий собой текущий контекст обработки запроса.'
 'Португальский язык Теперь вы можете создавать чат-ботов на португальском языке. В сценарии будут доступны готовые интенты: Согласие Отказ Дата и время Подробнее о создании чат-ботов'
 'Релиз Aimylogic 1.10.17 Казахский язык для чат-ботов. Список языков, на которых вы можете создавать чат-ботов, пополнился казахским языком. В сценарии будут доступны следующие готовые интенты: Согласие, Отказ, Дата и время. Подробнее о создании чат-ботов'
 'Далее мы перейдем к созданию первого одноязычного бота.'
 'Функция detectLanguage определяет язык запроса при помощи метода $caila.detectLanguage. Исключение составляет первый запрос /start — для него функция возвращает язык по умолчанию, заданный в дескрипторе сценария. Функция redirectToBot переключает контекст в нужного одноязычного бота при помощи context-switch. По умолчанию делается переход в стейт /Hello. В качестве данных, общих между ботами, передается все содержимое объекта $session. Функция processRequest используется для обработки всех запросов, которые принимает бот-роутер: она определяет язык запроса и переключает контекст на нужного одноязычного бота. Если бот для языка запроса не задан в дескрипторе, выдается сообщение о том, что язык не поддерживается. Код сценария В файле main.sc необходимо подключить файл router.js при помощи тега require, а также предусмотреть два стейта: стейт /Request для приема всех запросов, переданных в роутер; стейт-заглушку /Redirect, который будет использоваться для маршрутизации запросов. К обоим стейтам следует привязать в качестве обработчика функцию processRequest. Далее мы перейдем к созданию первого одноязычного бота.'
 'Подробнее о том, как учесть это при разработке, вы можете узнать в пошаговом сценарии многоязычного бота.']"	Вы можете создавать ботов на русском, английском, испанском, португальском и казахском языках.	['Для чат-ботов также доступен испанский, португальский и казахский языки.']	0.9514983520993942	0.629523809511219	1.0
Какие элементы структуры чат-бота описывает декларативный тег?	"['Термины Декларативный тег — описывает структуру чат-бота, задает зависимость между файлами, правила перехода между состояниями и теги реакций. Дерево разбора ($parseTree) — формальная структура текста, получаемая в результате парсинга. Процесс сопоставления текста с паттерном позволяет получить дерево разбора текста, элементами которого становятся фрагменты текста, попавшие в именованные паттерны. Дескриптор сценария — содержит списки всех файлов сценариев, справочников и скриптов, а также общие параметры работы чат-бота, определяется в файле chatbot.yaml. Именованные сущности — элементы справочника именованных сущностей. Именованный паттерн — часть паттерна, выделенная в отдельную сущность, которая может быть использована несколько раз. Интент — ключевая единица NLU-сервиса, объединяющая в себе набор фраз, намерение пользователя и другую метаинформацию. Канал — тип канала коммуникации: Telegram, Viber, Google Assistant и пр. Класс — состояние или стейт. Конвертер — вспомогательный скрипт для интерпретации значений текста в каждом токене, позволяет преобразовать данные для последующего использования в скриптах. Матчер — модуль, выполняющий сопоставление паттернов тексту. Паттерн — формальные правила, описывающие ключевые понятия, выражения и структуру фразы. С помощью паттернов происходит отнесение реплики человека к одному из существующих в системе стейтов, чтобы затем выполнить соответствующие стейту реакции.'
 'require Описание require — тег служит для загрузки зависимых файлов и, по сути, является альтернативой указанию всех зависимых файлов в chatbot.yaml. Тип значения string — задает имя подключаемого файла Параметры type (string) — опциональный параметр, определяет тип файла; по умолчанию определяется из расширения. from (string) — имя модуля, из которого импортируется файл; версия и репозиторий модуля указываются в chatbot.yml. rootTheme (string) — базовая тема для всех состояний, определенных в подключаемом файле. provide (multiline json) — набор параметров, передаваемый подключаемому модулю. name (string) — имя паттерна для справочников сущностей. var (string) — определяет имя js-переменной с данными из справочника. injector (string) — через объект $injector в скрипт могут передаваться метапараметры. module (string) — имя модуля, из которого загружается файл. Имя модуля либо задается в секции dependecies конфигурационного файла chatbot.yaml, либо соответствует имени папки в папке системных модулях. Подробнее о работе с module Вложенные данные named parametrs Примеры использования параметр varName; параметры from, rootTheme, provide; параметры type, patternName; параметр injector; параметр module; в значениях параметров возможны подстановки.'
 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.'
 'По последовательности стейтов С помощью фильтра Маршрут вы можете отсортировать сессии, фразы и маршруты по указанной последовательности стейтов. При настройке фильтра используйте: \\> — чтобы указать несколько стейтов. \\* — чтобы заменить символы или стейты. По параметрам диалогов По рассылкам Если вы создавали текстовые рассылки в текущем проекте, вы можете отфильтровать диалоги по ID и результату рассылки. ID текстовой рассылки — отображает диалоги, начатые при запуске рассылки с указанными ID. Результат текстовой рассылки — фильтрует диалоги по значениям, которые были присвоены рассылкам. Включает в себя флаги: Не важно — все диалоги, в которых были запущены рассылки. Пусто — диалоги, в которых рассылкам не был присвоен результат. Не пусто — диалоги, в которых рассылкам был присвоен результат. Содержит — диалоги, в которых рассылкам был присвоен указанный результат. Не содержит — диалоги, в которых отсутствуют рассылки с указанным результатом. Отображение результата Сессии Отфильтрованные сессии диалогов отображаются в формате таблицы со следующими колонками: Начало — время и дата начала диалога. Бот — идентификатор бота. Кол-во — количество сообщений клиента. Стартовое сообщение не учитывается. ID пользователя/Тип звонка — идентификатор клиента. Нажмите на ID пользователя, чтобы открыть детализацию диалога. Результат сессии — результат сессии в диалогах с чат-ботами и в подключенных телефонных каналах. Последняя фраза — последняя фраза клиента.'
 'timeout — максимальное время обработки запроса в миллисекундах. По умолчанию ограничение включено со значением таймаута 10000 (10 секунд). Если запрос превысит ограничение, в сценарии возникнет событие timeLimit. XML-тесты XML-тесты сценариев позволяют проверить логику чат-бота, эмулируя запросы клиента и проверяя ответы от бота. По умолчанию выполняются все тесты из файлов в папке проекта test. Это поведение можно переопределить в секции tests, задав значения для подсекций include и/или exclude: include — будут выполнены тесты только из тех файлов, которые попадают под шаблоны, перечисленные в этой подсекции. exclude — из выполнения будут исключены все файлы, которые попадают под шаблоны, перечисленные в этой подсекции. Шаблоны используют синтаксис Apache Ant. Поле caseSensitive определяет, должны ли шаблоны учитывать регистр названий файлов. Значение по умолчанию — true. Зависимости Секция dependencies позволяет задать список зависимостей проекта. Подробнее о зависимостях Теги действий Секция customTags задает список самостоятельно созданных тегов действий, которые используются в проекте. Пользовательские реакции Секция customBlocks задает список пользовательских реакций, которые используются в рассылках. Сообщения об ошибках Секция messages.onError позволяет задать текст сообщения, которое бот отправит при возникновении какой-либо ошибки. В подсекции locales могут быть заданы тексты сообщений, локализованные исходя из данных о пользователе.'
 'JS-код в проекте чат-бота JAICP DSL использует вставки JavaScript-кода спецификации ECMAScript 5 для описания бизнес-логики и интеграции с внешними системами. Бот может производить вычисления, проверять ранее сохраненную информацию и реагировать в зависимости от результата диалога Например, бот может хранить в переменных определенную информацию и в дальнейшем её переиспользовать в течение диалога. Или бот может проверить канал общения, и в зависимости от результата отображать подходящие элементы графического интерфейса. Структура JS-кода в проекте JS-код в проекте: Выражения в тегах if, else, elseif — функции-условия, используемые для описания правил условных переходов. Тег script — скриптовые вставки для произведения любых вычислений и вызова внешних систем. Тег init — скрипты инициализации, выполняются только один раз при загрузке сценария и используются для создания глобальных переменных и привязки pre/post-процессов. Подключаемые JS-файлы — файлы подключаются посредством require. Содержат объекты и функции, доступные к использованию в любых других скриптах. Встроенные функции — специальные объекты и функции, предоставляемые платформой. Например, предоставляют функционал для вызова матчера или внешних сервисов. Встроенные библиотеки — JS-библиотеки, загружаемые автоматически вместе с каждым ботом. Подробнее о встроенных переменных, функциях и сервисах JS-файлы Вы можете прописать логику непосредственно в файле сценария .sc.'
 'Длительность — длительность диалога с момента его начала и до последней фразы клиента. Статусы сообщений Если бот подключен в Telegram, Viber или ВКонтакте, в детализации диалога вы увидите статусы сообщений. Возможные значения: Отправлено Не отправлено Доставлено Не доставлено Прочитано Статус Отправлено доступен только в каналах Telegram и ВКонтакте, а статус Прочитано — в Viber и ВКонтакте. Фразы Для того чтобы отобразить поля Ответ и Разметка, переведите переключатели Выводить ответы и Выводить форму в активное положение. Отфильтрованные фразы отображаются в формате таблицы со следующими колонками: Вопрос — фраза клиента. Класс — название стейта, в котором была обработана фраза клиента. Стейт — название стейта, в котором бот сгенерировал ответ. Ответ — ответ бота. Разметка: Метки — проставьте метки для выбранной фразы. Комментарий — оставьте комментарий к выбранной фразе. Задача — создайте задачу на доработку проекта. Интенты — добавьте выбранную фразу в новый или уже существующий интент. Графики Здесь отфильтрованные фразы и сессии отображаются в виде графиков. Статистические графики помогут вам наглядно оценить динамику использования бота. Маршруты На вкладке Маршруты отображаются все последовательности стейтов, которые прошел клиент в рамках одной сессии. Информация о пройденных маршрутах позволяет понять, на каком этапе клиент прекращает взаимодействие с ботом. Проанализировав такую информацию, вы сможете изменить ваш сценарий и сравнить конверсию.'
 '$reactions.ttsWithVariables Метод задает аудио и шаблон текста для синтеза речи с переменным на базе технологии Yandex SpeechKit Brand Voice Adaptive. В настройках телефонного канала должны быть активны переключатели Включить Yandex v3 и Использовать переменные. В противном случае вызов метода приведет к ошибке. Синтаксис Метод принимает объект с полями audioTemplate и textTemplate. audioTemplate audioTemplate — описание аудио, в которое будет вставлена переменная. Содержит поля: audio — ссылка на аудиофайл с шаблоном фразы. Файл должен быть публично доступен по протоколу httpS и удовлетворять требованиям, предъявляемым к аудиозаписям. textTemplate — описание расшифровки аудиофайла: template — текст шаблона. Переменные должны быть обозначены соответствующими именами в фигурных скобках. textVariables — массив объектов, описывающих использованные переменные. Каждый объект содержит поля: name — название переменной. value — расшифровка переменной, использованной в шаблоне. audioVariables — массив объектов, описывающих расположение переменных в аудиозаписи. Каждый объект содержит поля: name — название переменной. startMs — время от начала аудиозаписи до начала воспроизведения переменной в миллисекундах. lengthMs — длительность воспроизведения переменной в миллисекундах. textTemplate textTemplate — описание фразы, которую должен синтезировать бот в диалоге с клиентом. Содержит поля: template — текст шаблона.'
 'Релиз JAICP 1.10.9 Интеграция с таблицами Google. Фиксация результата диалога во всех каналах. Новые фильтры в аналитике по диалогам. Метод POST /addPhone в Calls API. Ограничение количества звонков на номер. Поддержка приема файлов в канале Slack. Возможность изменения почты пользователя. Ограничения на число и объем ответов чат-бота. Некорректно работает тег if при числовом значении в теле тега, близком к 0. В аналитике по диалогам вместо имени интента отображается имя стейта. Ответы бота не попадают в логи диалогов, если не заполняется поле $response.answer. Дублируется файл nlu.json в репозитории с несколькими ботами. При планировании обзвонов некорректно отображается время начала. В канале Telegram создается лишняя сессия при вызове $pushgate.createEvent. Добавлен пошаговый сценарий бота для отправки напоминаний. Добавлено общее описание редактора сценариев. Обновлена статья о передаче параметров в чат-виджет. Обновлена OpenAPI-спецификация Calls API. В релизе 1.10.9 у JAICP появились новые возможности для интеграции с внешними системами. Теперь в настройках проекта на вкладке Каналы доступен новый раздел Интеграции, где вы можете создать подключение к нужной внешней системе и, получив его идентификатор, легко взаимодействовать с системой из сценария. На данный момент поддерживается интеграция с таблицами Google. Мы продолжаем развивать новую версию аналитики: в этом релизе добавлена возможность фиксировать результат диалога во всех каналах, а также ряд новых фильтров.'
 'Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.']"	Декларативный тег описывает структуру чат-бота, задает зависимость между файлами, правила перехода между состояниями и теги реакций.	['- Термины Декларативный тег — описывает структуру чат-бота, задает зависимость между файлами, правила перехода между состояниями и теги реакций.\n- Дерево разбора ($parseTree) — формальная структура текста, получаемая в результате парсинга.\n- Дескриптор сценария — содержит списки всех файлов сценариев, справочников и скриптов, а также общие параметры работы чат-бота, определяется в файле chatbot.yaml.\n- Именованные сущности — элементы справочника именованных сущностей.\n- Именованный паттерн — часть паттерна, выделенная в отдельную сущность, которая может быть использована несколько раз.\n- Интент — ключевая единица NLU-сервиса, объединяющая в себе набор фраз, намерение пользователя и другую метаинформацию.\n- Канал — тип канала коммуникации: Telegram, Viber, Google Assistant и пр.\n- Класс — состояние или стейт.\n- Конвертер — вспомогательный скрипт для интерпретации значений текста в каждом токене, позволяет преобразовать данные для последующего использования в скриптах.\n- Матчер — модуль, выполняющий сопоставление паттернов тексту.\n- Паттерн — формальные правила, описывающие ключевые понятия, выражения и структуру фразы.\n- Реакция — набор действий, выполняемый в ответ на какую-либо фразу пользователя.\n- Сессия — последовательность взаимодействий клиентом с ботом, использующая единый контекст беседы.\n- Скилл — навык бота.\n- Скрипт — код на JavaScript.\n- Справочник именованных сущностей — необходим для обработки в паттернах большого количества каких-либо названий, например, городов, стран, имен, валют и т.п.\n- Стейт (состояние) — это элемент сценария, описывающий поведение бота в определенном контексте.']	0.9342284087360916	0.9999999999	1.0
Как декларативный тег связан с деревом разбора и именованными паттернами?	"['theme Декларативный тег theme объявляет тему в сценарии бота. Темы служат для группировки стейтов сценария, которые каким-либо образом связаны между собой. Темы никак не связаны с возможностью разделять код на несколько файлов сценариев. Любая тема может быть объявлена в любом файле с расширением .sc, а в одном файле может быть сколько угодно тем. Значение После тега записывается название темы. Оно всегда должно начинаться с / и может содержать любые символы Unicode. Тема, состоящая только из символа /, называется корневой. Вложенные данные На уровне вложенности, следующем после объявления темы, можно создавать стейты — состояния, в которых может находиться контекст диалога. Для этого используется тег state. Примеры использования Корневая тема: Темы для группировки общих стейтов:'
 'Объявите именованный паттерн при помощи специального элемента $entity, после которого в угловых скобках записывается название справочника, а как атрибут после || — имя конвертера: Использование Рассмотрим пример стейта, который будет срабатывать на запросы с упоминанием сущности $city: При попадании в данный стейт, например, по запросу мой регион Санкт Петербург в $parseTree будет доступна информация по сущности: По ключу &lt;имя\\_паттерна> доступна подробная информация по всем распознанным сущностям, а по ключу \\_&lt;имя\\_паттерна> — значение value первой распознанной сущности. Значение value отличается в зависимости от того, задан ли для сущности конвертер: Если конвертер задан, берется значение, которое возвращает конвертер. Если конвертер не задан, записывается только идентификатор сущности.'
 'Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.'
 'require Описание require — тег служит для загрузки зависимых файлов и, по сути, является альтернативой указанию всех зависимых файлов в chatbot.yaml. Тип значения string — задает имя подключаемого файла Параметры type (string) — опциональный параметр, определяет тип файла; по умолчанию определяется из расширения. from (string) — имя модуля, из которого импортируется файл; версия и репозиторий модуля указываются в chatbot.yml. rootTheme (string) — базовая тема для всех состояний, определенных в подключаемом файле. provide (multiline json) — набор параметров, передаваемый подключаемому модулю. name (string) — имя паттерна для справочников сущностей. var (string) — определяет имя js-переменной с данными из справочника. injector (string) — через объект $injector в скрипт могут передаваться метапараметры. module (string) — имя модуля, из которого загружается файл. Имя модуля либо задается в секции dependecies конфигурационного файла chatbot.yaml, либо соответствует имени папки в папке системных модулях. Подробнее о работе с module Вложенные данные named parametrs Примеры использования параметр varName; параметры from, rootTheme, provide; параметры type, patternName; параметр injector; параметр module; в значениях параметров возможны подстановки.'
 'Для тега можно задать необязательные атрибуты: strictMatch — строгость сопоставления мок-объекта телу запроса. Значение по умолчанию: false. При нестрогом сопоставлении (false) проверяется, что все значения полей, указанные в теге &lt;body>, равны соответствующим значениям полей из тела запроса. При строгом сопоставлении (значение true) проверяется полное совпадение объекта в теге &lt;body> и тела запроса. field — JsonPath-выражение, указывающее на поле для сопоставления. Если атрибут указан, сопоставление производится не по всему объекту из тела запроса, а только по его части. Ответ &lt;response> — описание ответа, который вернет мок-объект в качестве ответа сервера. Обязательный элемент. В теле элемента указывается строка с ответом. Возвращаемое значение метода $http.query помимо HTTP-ответа в поле data содержит ряд служебных полей: isOk, status и другие. Данные поля не следует помещать в &lt;response>. Указывайте только ответ от сервера — то, что приходит в поле data. Возможные атрибуты для тега: status — код ответа на HTTP-запрос, по умолчанию 200. type — тип ответа, по умолчанию json. Если тип ответа json или xml, ответ парсится и возвращается в сценарий в виде JS-объекта. В противном случае ответ передается в виде строки. Если формат тела &lt;response> не соответствует указанному типу, при публикации бота возникнет синтаксическая ошибка.'
 'Например, элемент $morph&lt;С им ед> (существительное в именительном падеже и единственном числе) даст совпадения со словами кошка, банк, условие и т. д. botEngine: v2 На второй версии диалогового движка через элемент $morph можно указать только совпадение по частям речи. Другие грамматические свойства не поддерживаются. Формат обозначений для частей речи зависит от того, какой движок токенизации использует проект. Обозначения, указанные под один движок, в большинстве случаев не будут работать для другого. Использование в сценарии Элемент $morph обычно используется для поиска совпадений по специфическим словосочетаниям. Их сложно описать простым перечислением слов или корней слов, которые могут в них входить. $regexp/regexp_i $regexp/regexp_i&lt;литералы и метасимволы> — регулярное выражение — шаблон, описывающий некий набор строк. Шаблон состоит из литералов и метасимволов — символов со специальным, а не буквальным значением. В $regexp или $regexp_i будут попадать строки, соответствующие шаблону. $regexp — чувствительный к регистру букв, $regexp_i — нечувствительный. Оба элемента нечувствительны к использованию буквы е вместо ё и наоборот. Синтаксис регулярных выражений соответствует синтаксису, используемому в Java. Использование в сценарии Объявление паттерна для обнаружения любого слова в запросе: Объявление паттерна для обнаружения процентного значения: $entity $entity&lt;именованная сущность> преобразует в паттерн именованную сущность.'
 'Подробнее о декларативном теге patterns'
 'Расширенные элементы паттернов $pattern_name $название-паттерна — ссылка на именованный паттерн. Подробнее об именованных паттернах Использование в сценарии Объявление паттерна: Использование паттерна в сценарии: ~lemma ~lemma проверяет все формы слова. Слово после тильды должно стоять в словарной форме. Например, в паттерн ~яблоко попадут слова: яблоки, яблок и др. Правило срабатывает на всех словоформах всех омонимов: слов, которые звучат и пишутся одинаково, но имеют разные значения или морфологическую форму. Например, паттерн ~печь сработает на словоформах существительного печь (печи, печью) и глагола печь (пеку, печешь). Из-за морфологического разнообразия языка использование этого паттерна может приводить к ложноположительным результатам. Использование в сценарии $morph Элемент $morph&lt;свойство> проверяет совпадение по слову с определенными грамматическими свойствами. Список поддерживаемых свойств зависит от того, какой диалоговый движок использует проект. botEngine: v1 На первой версии диалогового движка для морфологического анализа используется парсер AOT. Используйте для грамматических свойств условные обозначения для русского и английского языка. Указывайте их внутри угловых скобок через пробел. Кроме того, на этой версии $morph позволяет проверить совпадение по одному или сразу по нескольким свойствам.'
 'Термины Декларативный тег — описывает структуру чат-бота, задает зависимость между файлами, правила перехода между состояниями и теги реакций. Дерево разбора ($parseTree) — формальная структура текста, получаемая в результате парсинга. Процесс сопоставления текста с паттерном позволяет получить дерево разбора текста, элементами которого становятся фрагменты текста, попавшие в именованные паттерны. Дескриптор сценария — содержит списки всех файлов сценариев, справочников и скриптов, а также общие параметры работы чат-бота, определяется в файле chatbot.yaml. Именованные сущности — элементы справочника именованных сущностей. Именованный паттерн — часть паттерна, выделенная в отдельную сущность, которая может быть использована несколько раз. Интент — ключевая единица NLU-сервиса, объединяющая в себе набор фраз, намерение пользователя и другую метаинформацию. Канал — тип канала коммуникации: Telegram, Viber, Google Assistant и пр. Класс — состояние или стейт. Конвертер — вспомогательный скрипт для интерпретации значений текста в каждом токене, позволяет преобразовать данные для последующего использования в скриптах. Матчер — модуль, выполняющий сопоставление паттернов тексту. Паттерн — формальные правила, описывающие ключевые понятия, выражения и структуру фразы. С помощью паттернов происходит отнесение реплики человека к одному из существующих в системе стейтов, чтобы затем выполнить соответствующие стейту реакции.'
 'Параметры с типом integer приводятся к числу через parseInt или parseFloat. Параметры с типами stringArray, nameValueList, json приводятся к объекту через JSON.parse. Настройки отображения в J‑Graph В графическом редакторе J‑Graph тегам действий соответствуют блоки действий. Поля ниже позволяют настроить их отображение в J‑Graph. Все эти поля необязательны. В качестве значения все поля принимают объект с ключами ru и eng. Значение ru используется при отображении интерфейса JAICP на русском языке, eng — на английском. Пример настроек Пример JSON-файла для сценария по сложению двух чисел, разработанного на шаге 1: Шаг 3. Укажите путь к JSON-файлу в chatbot.yaml В конфигурационном файле chatbot.yaml создайте секцию customTags, если ее еще нет. Укажите в ней путь к JSON-файлу относительно корневой директории проекта. Если вы хотите использовать тег как действие в J‑Graph, обязательно сохраните изменения, сделанные в редакторе кода. Для этого нажмите . Шаг 4. Используйте тег в сценарии Через редактор кода Перейдите в нужный файл сценария бота, например main.sc. Создайте новый стейт для вашего тега действия и укажите его параметры, например: Стейт срабатывает на запросы наподобие два плюс три. Через сущность @duckling.number из запроса извлекаются два числа, которые передаются в тег. SumTwoNumbers — название тега действия. Оно соответствует значению параметра tagName в JSON-файле с настройками.']"	Декларативный тег служит для объявления структуры чат-бота и задания зависимостей между файлами. Дерево разбора получается в результате парсинга текста и содержит фрагменты текста, которые попали в именованные паттерны. Именованные паттерны являются частью паттерна и могут быть использованы несколько раз. Таким образом, декларативный тег связан с деревом разбора и именованными паттернами через процесс сопоставления текста с паттерном.	['- Термины Декларативный тег — описывает структуру чат-бота, задает зависимость между файлами, правила перехода между состояниями и теги реакций.\n- Дерево разбора ($parseTree) — формальная структура текста, получаемая в результате парсинга.\n- Процесс сопоставления текста с паттерном позволяет получить дерево разбора текста, элементами которого становятся фрагменты текста, попавшие в именованные паттерны.\n- Именованный паттерн — часть паттерна, выделенная в отдельную сущность, которая может быть использована несколько раз.']	0.975380383005541	0.1111111110999999	0.5
Какие системные сущности и справочники доступны в Aimylogic?	"['Системные сущности и справочники В Aimylogic есть набор наиболее часто используемых системных справочников и сущностей. Это позволяет вам не создавать их вручную каждый раз. Вы можете использовать системные сущности в блоке Интенты, чтобы бот извлекал из фразы клиента ту или иную сущность и создавал переменную с ее языконезависимым представлением. Среди таких сущностей и справочников: $TEXT, $NUMBER, $FLOATNUMBER, $PHONE, $CITY, $CAPITAL, $COUNTRY, $NAME. Системные сущности Эти сущности позволяют извлечь из фразы клиента данные, которые соответствуют определенным шаблонам. $TEXT Данная сущность позволяет извлечь из фразы клиента произвольный текст. Сущность $TEXT можно использовать только в шаблонах. В примерах фраз ее использовать нельзя. Для того чтобы добавить шаблон для интента, в окне создания интента нажмите на иконку в строке, где собираетесь добавить шаблон. На ее месте появится иконка : :size=500 Например, если вы добавили шаблон вида Я ищу $TEXT, то бот извлечет из фразы клиента «Я ищу интересную работу» сущность $TEXT. Он сохранит часть фразы «интересную работу» в переменной $TEXT. $NUMBER Эта сущность извлекает из фразы клиента целые числа. Клиент может указать их как цифрами, так и словами. В результате бот создаст переменную $NUMBER, в которую поместит целое число.'
 'Сущности Сущность — это часть пользовательского запроса, которую можно выделить из фразы в виде каких-либо языконезависимых данных. Дата и время, Число, Номер телефона, Название города — все это примеры сущностей, которые Aimylogic может автоматически обнаружить во фразе клиента. Всякий раз, когда бот должен выделить из фразы важные данные, используйте сущности. Какие есть сущности в Aimylogic В Aimylogic есть как системные сущности, доступные «из коробки», так и пользовательские сущности, которые вы можете добавить самостоятельно. Как работают сущности Когда бот анализирует фразу клиента, он пытается распознать в ней сущности. Как только сущность найдена, бот создает переменную и называет ее именем сущности, а затем сохраняет в нее значение, полученное от клиента. Предположим, в примере или шаблоне фразы вы указали, что во фразе клиента должно присутствовать число. В Aimylogic есть системная сущность $NUMBER, при помощи которой можно распознавать числа. Если клиент напишет боту фразу, в которой присутствует число, бот сможет распознать в числе сущность $NUMBER, даже если клиент напишет число словами, а не цифрами. После этого созданную переменную можно использовать в сценарии бота так же, как и любую другую. Например, добавлять ее в условия или передавать в HTTP-запросе. Как указать сущность во фразе Чтобы бот смог выделить сущность из фразы, ее нужно указать в примере или шаблоне фразы в блоке Интенты.'
 'Справочники именованных сущностей .csv — справочники именованных сущностей. Справочники именованных сущностей необходимы для обработки большого набора именованных сущностей через паттерны. Именованная сущность — слово или словосочетание, выделяющее определенный предмет или явление из ряда однотипных предметов или явлений. Например, это названия городов, стран, валют. Структура справочника Справочники задаются в файлах с расширением .csv. Каждая строка имеет следующую структуру: ID Идентификатор сущности. Идентификаторы в пределах одного справочника должны быть уникальны. Имя Слово или набор слов для обозначения сущности. Внутри имени вы можете перечислить ряд синонимов через запятую. При подключении справочника к сценарию бот будет распознавать сущность в запросах, где упомянут один из перечисленных синонимов. Значение Данные, ассоциированные с сущностью. Данные могут быть представлены в виде строки без кавычек либо объекта JavaScript. Вы можете добавить в значения любую информацию, которая относится к сущности, чтобы воспользоваться ей в сценарии. Например, в имени сущности вы можете перечислить все синонимы, а в одном из полей значения — ее основное, нормализованное наименование. Пример В качестве примера рассмотрим фрагмент справочника личных имен: Подключение справочника Для подключения справочника используется тег require. Укажите путь к файлу, а также значения параметров name и var.'
 'Релиз Aimylogic 1.11.0 Удаление данных из Google Таблиц. Пользовательские справочники с вложенными сущностями. Удаление данных из Google Таблиц Мы доработали функциональность блока Интеграция с Google Таблицами. Теперь вы можете: удалять содержимое конкретных ячеек или их диапазонов; удалять строки, столбцы или диапазоны строк либо столбцов. Подробнее об удалении данных из Google Таблиц Пользовательские справочники с вложенными сущностями Теперь при загрузке пользовательского справочника вы можете активировать опцию Добавлять значения сущностей в формате JSON и загружать справочники, содержащие не только синонимы сущностей, но и их значения в формате JSON. Благодаря этой опции вы сможете извлекать данные из значения сущности — например, характеристики вашего товара, которые будут храниться в полях объекта JSON. Эти поля можно использовать в сценарии. Подробнее об использовании вложенных сущностей'
 'Подробнее о пользовательских справочниках и о том, как загрузить сразу много сущностей'
 'Duckling Системные сущности duckling.&lt;name> извлекаются платформой с помощью сервиса Duckling. Версии В платформе поддерживаются две версии интеграции сервиса Duckling: 1.0 и 2.0. В новых проектах по умолчанию используется версия 2.0. В версии 2.0 расширены возможности сервиса Duckling 1.0, а также оптимизировано распознавание вводимых пользователем фраз. Дата и время Рассмотрим сущности @duckling.time, @duckling.date и @duckling.time-of-day. Ожидаемое поведение: @duckling.time извлекает дату и время совместно, только дату, только время. @duckling.date извлекает дату и время совместно, только дату, только время. @duckling.time-of-day извлекает дату и время совместно, только время. Например, мы обращаемся 19 июня 2020 года к боту, в сценарии которого используются все три сущности: Обратите внимание, что в случае, когда требуется извлечь дату и время, поведение сущностей не отличается.'
 'Пользовательские справочники Наряду с системными сущностями и справочниками, Aimylogic предоставляет возможность создавать пользовательские справочники, чтобы бот мог извлекать из фразы клиента сущности, которые в них добавлены. Сущности Каждая сущность — это некий идентификатор записи в вашем справочнике. Для каждой записи нужно указать хотя бы один синоним на естественном языке, чтобы бот понимал, какие именно слова клиента относятся к этой сущности. Синонимы нужно указывать в словарной форме слова, то есть в именительном падеже единственного числа. Бот будет распознавать эти синонимы в других формах во время работы. Как создать справочник Управлять пользовательскими справочниками можно на странице Сущности в редакторе бота. Здесь находится список системных справочников и кнопка Создать справочник синонимов. Нажатие на кнопку открывает окно создания справочника. Здесь нужно придумать имя для справочника. В качестве имени справочника можно использовать только латинские буквы в нижнем регистре, цифры и знак подчеркивания. После создания справочника вы попадете на его страницу, где можно управлять его сущностями. Как использовать справочники В примере на видео мы создали справочник с именем $product и добавили в него несколько сущностей. Например, сущность iphone с синонимами айфон и ай фон. Теперь можно добавить в сценарий бота блок Интенты и указать Хочу заказать $product в качестве примера фразы.'
 'В первую очередь, мы подробно рассказываем про самые важные понятия Aimylogic: Сценарий бота Экран Блоки и их разновидности Справочники и сущности Также мы объясняем, кто такие уникальные пользователи в Aimylogic.'
 'Продвинутые инструменты В этом разделе мы расскажем о том, как работать с Aimylogic на более продвинутом уровне. При этом вам все равно не понадобятся навыки программирования: следуя нашим инструкциям, вы справитесь с любой задачей! Что есть в этом разделе Работа с переменными HTML-разметка сообщений Вебхуки Функции для работы с массивами Работа с Google Таблицами База данных База знаний Разметка синтеза речи Чтение RSS-ленты'
 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.']"	В Aimylogic есть набор системных сущностей и справочников. Системные сущности включают $TEXT, $NUMBER, $FLOATNUMBER, $PHONE, $CITY, $CAPITAL, $COUNTRY, $NAME. Справочники могут быть созданы пользователем и использоваться для извлечения сущностей из фразы клиента.	['- В Aimylogic есть набор наиболее часто используемых системных справочников и сущностей.\n- Среди таких сущностей и справочников: $TEXT, $NUMBER, $FLOATNUMBER, $PHONE, $CITY, $CAPITAL, $COUNTRY, $NAME.\n- Системные сущности позволяют извлечь из фразы клиента данные, которые соответствуют определенным шаблонам.\n- $TEXT Данная сущность позволяет извлечь из фразы клиента произвольный текст.\n- $NUMBER Эта сущность извлекает из фразы клиента целые числа.\n- $FLOATNUMBER Данная переменная аналогична переменной $NUMBER, только она позволяет извлечь из фразы клиента дробные числа.\n- $PHONE Извлекает из фразы клиента мобильный номер телефона.\n- Статичные сущности называются справочниками. Сюда входят, например, города, страны или имена людей.\n- $CITY Эту сущность можно использовать, чтобы извлечь из фразы клиента название какого-либо города мира.\n- $CAPITAL Если во фразе клиента есть столица, бот создаст переменную $CAPITAL.\n- $COUNTRY Все страны мира. Если во фразе клиента есть страна, то бот создаст переменную $COUNTRY.\n- $NAME Эта сущность позволяет извлечь из фразы клиента самые популярные имена.\n- $DATETIME Системная сущность, которая принимает значения даты и времени.']	0.9553918812267698	0.9107142856991072	1.0
Как бот может запросить у пользователя произвольный текст?	"['То есть по сути мы складываем значения переменных, которые получили в ходе сценария, с текстом, который будет пояснять их значение. Также мы используем переменную $rawRequest.user_info.id, которая будет содержать значение id страницы пользователя. И добавляем переносы строк с помощью знака \\\\n. После присвоения значения переменной $text, мы ставим запятую, пробел и создаем переменную $num. Этой переменной мы присваиваем случайное значение от 1 до 9223372036854775808 с помощью метода \\_.random. Этот параметр нужен для идентификации сообщения при отправке в ВКонтакте. Если вы используете в сценарии другие переменные, то измените, соответственно, и текст условия в соответствии с вашим сценарием. Напоминаем, что бот может отправлять сообщения только тем пользователям, с которыми он уже общался. Поэтому, чтобы менеджер, который обрабатывает заявки пользователей, мог получать сообщения, он должен для начала написать любое сообщение самому сообществу. :size=400 Оформите HTTP-запрос От блока Условие создайте связь с блоком HTTP-запрос. :size=400 метод POST в BODY скопируйте и вставьте: {""response"": 484045} :size=400 Вкладки RESPONSE и HEADERS заполнять не нужно. Составим URL запроса. Он может выглядеть примерно так: Разберем его по частям.'
 'Это связано с тем, что в CAILA невозможно создать сущность, которая бы обрабатывала произвольный текст. Разработка сценария В сценарии нам будут полезны возможности для обработки времени, которые предоставляет библиотека Moment.js. Вы можете импортировать ее из системного модуля dateTime, объявив в начале файла main.sc следующую зависимость: Далее продолжим разработку сценария. Рассмотрим предполагаемое взаимодействие бота с клиентом: Клиент просит поставить напоминание и по интенту /SetReminder попадает в соответствующий стейт. Слот-филлинг гарантирует, что бот попадет в обработчик стейта лишь после того, как клиент назовет время напоминания. Распознанное время сохраняется в поле $session.reminderTime. Бот запрашивает у клиента текст напоминания. Поскольку ответ клиента может быть любым, для его обработки используется системное событие noMatch, которое срабатывает при любом нераспознанном вводе. Ответ клиента обрабатывается в стейте GetReminder. В обработчике стейта планируется новое событие при помощи метода $pushgate.createEvent. В качестве времени наступления события передается ранее распознанное время в формате yyyy-MM-ddTHH:mm:ss, а в объекте с дополнительными данными — распознанный текст. Метод $pushgate.createEvent возвращает объект с идентификатором созданного события, который мы сохраняем в поле $session.reminderId — позже он нам пригодится.'
 'Если запрос пользователя слишком сильно отличается от заданной формулировки, бот может не понять его или понять неправильно. Чтобы повысить качество распознавания вопроса: Под основной формулировкой нажмите Добавить формулировки. В раскрывшемся списке вы можете ввести любое число дополнительных формулировок. Заполнение формулировок вопроса Вместо текстовых фраз, близких по смыслу к основной формулировке, вы также можете использовать паттерны — формальные правила для сопоставления запросов специальным шаблонам. Такие правила могут быть полезны, когда обычных текстовых фраз недостаточно. Чтобы переключиться на режим ввода паттернов или переделать текст в паттерн, нажмите . Для переключения обратно на ввод текста нажмите . В статье Как обучать интенты вы можете более подробно узнать о том, каковы преимущества и недостатки фраз по сравнению с паттернами и как подготовить хороший набор формулировок. Ответ на вопрос В поле Ответ введите текст или загрузите изображение, аудиозапись или файл. К ответу можно прикрепить до 20 сообщений с данными разного формата. При ответе на вопрос бот отправит их пользователю по порядку. Не все каналы поддерживают сообщения с изображениями или аудио-файлами. Убедитесь, что подключенные к боту каналы поддерживают нужный формат. Объединение вопросов в группы Нажмите на боковой панели, чтобы создать новую группу. С помощью групп можно объединить несколько вопросов на общую тему и лучше структурировать модуль.'
 'Для этого: Перейдите в BotFather Напишите команду /mybots Выберите нужного бота Перейдите в Bot Settings → Group Privacy Выберите Turn off Должна появиться фраза Privacy mode is disabled for Bot Удалите $rawRequest Вернитесь в сценарий бота. Теперь можно удалить блок, который содержит $rawRequest.message.chat.id. Опубликуйте бота Опубликуйте бота в Telegram и дождитесь публикации: Протестируйте бота Теперь напишите в Telegram боту (не в группу). Ссылка на бота есть в BotFather, в сообщении, в котором вы получали токен бота. :size=400 Запустите новую сессию с помощью /start, пришлите боту сообщение и убедитесь, что оно приходит в группу: :size=300 :size=300 Если ваши пользователи напишут боту, сообщения от них также будут публиковаться в группу в Telegram. Что сделать, чтобы бот отвечал пользователям? Чтобы бот отвечал пользователям в группе в Telegram, вам нужно добавить бота в администраторы группы. Если этого не сделать, бот будет реагировать только если пользователь напишет / и затем название интента. Например, /привет. Вам также может быть интересно Как отправить сообщение в Telegram Как валидировать городской номер телефона Авторизация в Telegram Инлайн-кнопки'
 'Если его не будет, то при запуске бот найдет состояние, реагирующее на любой текстовый ввод, либо выведет ошибку обработки запроса. Клиент вводит сообщение Привет или Пока и получает соответствующий ответ от бота Привет привет или Пока пока. Глобальный тег intent! позволяет осуществить переход диалога в данный стейт из любого другого стейта. Например, клиент ввёл сообщение Пока, запрос попадет в стейт Bye, так как был активирован интент /пока. Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение клиента не подходит ни под один описанный стейт. При вводе клиентом сообщения, например Как дела?, активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Бот посылает сообщение Я не понял. Вы сказали: Как дела?. Подробнее ознакомьтесь с тегами в разделе DSL. Теперь перейдем к тестированию бота и созданию канала.'
 'В данной подсекции ключи представляют собой ISO-коды языков, а значения — тексты сообщений. В поле defaultMessage указывается текст сообщения по умолчанию, которое отправляется в случае, если секция locales не задана или в ней не задан нужный язык. Также можно задать список сообщений по умолчанию в поле defaultMessages — тогда при ответе будет выбрано случайное из них. Если секция messages.onError не заполнена, то в случае возникновения ошибки бот не ответит клиенту. Для настройки более гибкого поведения при внештатных ситуациях используйте обработчики ошибок. Injector Секция injector позволяет задать параметры конфигурации чат-бота. Заданные параметры будут доступны в скриптах чат-бота через переменную $injector. Подробнее об $injector Настройки SMTP-сервера Секция injector.smtp позволяет задать настройки SMTP-сервера, через который будут отправляться email-сообщений при помощи метода $mail.sendMessage. Другие настройки Возможность изменения запроса Поле nlp.modifyRequestInPreMatch включает возможность изменять содержимое запроса в обработчике preMatch — например, редактировать текст запроса. Токенизация слов в паттернах Поле tokenizeWordsInPatterns включает токенизацию слов в паттернах для языков без разделителей между словами. Поле обязательно для корректной работы паттернов в проектах на китайском языке. Порядок загрузки файлов Поле scenarioLoadStrategy задает порядок загрузки файлов в сценарий, состоящий из множества файлов.'
 'Поисковый запрос Нажмите на Сохранить и добавьте на тот же экран блок Интенты Добавьте в него шаблон $TEXT. Под этот шаблон подходит любая фраза. Когда пользователь скажет что-нибудь, то бот сохранит всю фразу в переменную $TEXT. Не забудьте поставить галочку ""Глобальный блок"". Нажмите на Сохранить. Хитрость 2. Чтобы использовать шаблон $TEXT во фразах, нужно переключить переключатель ""кавычки"" на ""@"" Ищем навыки Теперь давайте научим нашего бота искать что-нибудь в каталоге навыков. Кликните на блоке фраз с шаблоном $TEXT и на новом экране добавьте блок HTTP запрос В поле URL пропишите такой адрес https&#x3A;//dialogs.yandex.ru/store/api/dialogs/search?q=${TEXT} Когда пользователь говорит фразу, бот автоматически сохраняет ее в переменную $TEXT (как указано в шаблоне) и подставляет в URL запроса. И таким образом получает навыки, которые подходят под запрос. Также добавьте переменную items $httpResponse.result.items Так бот разберет ответ от поискового сервиса и сохранит в переменную items массив найденных навыков. Показываем результаты поиска Итак, наш бот поприветствовал пользователя, попросил его сказать, что он ищет, и сделал запрос к поисковому сервису Яндекса. Теперь нужно показать пользователю результаты поиска. Так как результатов может быть много, то нужно научить бота выдавать информацию порционно, рассказывая о каждом навыке отдельно. Для этого нужно, чтобы бот умел перемещаться по массиву с найденными навыками.'
 'Блок text to $var Блок text to $var позволяет боту получить текст от клиента и сохранить его в переменную. Блок доступен через меню Добавить экран → Еще блоки → text to $var. Полученные значения переменной можно использовать в последующих шагах сценария (например, обращение по имени), выгружать в .csv или отправлять в стороннюю систему (например, в свою базу данных). Подробнее о переменных Параметры При добавлении этого блока нужно указать текст, который бот будет показывать клиенту в качестве приглашения к вводу текста, а также имя переменной, в которую нужно сохранить введенный клиентом текст. Здесь бот напишет клиенту Введите текст и будет ожидать ввода произвольного текста. После того как клиент введет текст, бот сохранит его в переменную text и перейдет к следующему экрану сценария. Бот не будет каким-либо образом интерпретировать ввод, а просто сохранит все, что клиент ввел в переменную. Если вам нужно, чтобы бот реагировал на определенные фразы, используйте блок Интенты. HTML-разметка Вы можете использовать HTML-разметку в текстовых сообщениях. Для этого активируйте переключатель Использовать в сообщении HTML разметку. Не все каналы поддерживают HTML-разметку. Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений.'
 'Блок Текст Используйте этот блок, когда бот должен вывести текстовое сообщение в чате с клиентом. В сценариях для звонков вместо блока Текст используйте блок Синтез речи. Параметры В параметрах блока можно указать один или несколько вариантов реплик, одну из которых бот будет выводить клиенту. Если нажать на кнопку Добавить другую реплику, то можно указать другой вариант реплики бота. В процессе диалога с клиентом бот будет случайным образом выбирать одну из реплик в этом блоке и выводить ее клиенту. После сохранения блока с несколькими репликами, вы будете видеть, сколько всего реплик вы добавили в этот блок. Использование переменных Вы можете подставлять переменные в выводимый текст. Например, если написать «Привет, $name!», то бот подменит $name на значение переменной name перед выводом. Вы также можете подставить несколько переменных в поле Реплика бота. Каждую переменную необходимо добавлять с новой строки. Если вы разместите несколько переменных на одной строке, то в боте появится ошибка. Несколько текстов подряд Можно поставить несколько блоков Текст подряд. Тогда бот выведет несколько реплик подряд, либо «склеит» тексты в одну реплику — зависит от канала, в котором работает бот. Разметка синтеза речи Вы можете добавить разметку синтеза речи для навыков голосовых ассистентов. Разметку синтеза речи нужно добавлять именно в поле Разметка синтеза речи. Настройка голосового синтеза При оформлении реплик бота вы можете при помощи разметки управлять синтезируемыми звуками.'
 'Справочник $NAME В текущем сценарии, если имя клиента не содержится в системном справочнике $NAME, бот будет снова спрашивать имя у клиента. Чтобы избежать этой ситуации и научить бота принимать любые имена с первого раза, дополните сценарий. От готового интента Имена и от ветки Любая другая фраза на первом экране создайте связь с новым экраном. Добавьте на него блок Условия со следующим содержанием: $name = $NAME ? $NAME.name : $queryText Любой введенный клиентом текст сохранится в переменную $queryText до следующего запроса. Если бот найдет в сообщении клиента сущность $NAME, он присвоит переменной $name значение из справочника. Если бот не найдет сущность в сообщении, в переменную $name он запишет значение $queryText. Получение любого имени Свяжите условие с экраном, на котором вы запрашиваете номер телефона клиента. Получение номера телефона Отредактируйте HTTP-запрос. Вкладка BODY должна содержать следующий JSON-объект: HTTP-запрос Не забудьте повторно опубликовать сценарий. Теперь бот будет принимать за имя любой текст, набранный клиентом в ответ на запрос имени. Пример диалога с клиентом: Пример диалога Сообщение, которое бот отправит на указанный chat_id: Сообщение с chat_id Вы также можете использовать регулярные выражения для валидации имени. Например, выражение $regexp&lt;^\\[а-яА-Я]{2,15}$> будет принимать слова длиной от двух до пятнадцати символов, состоящие из букв русского алфавита. Готовый сценарий Так выглядит весь сценарий: Готовый сценарий']"	"Бот может запросить у пользователя произвольный текст с помощью блока ""text to $var"". В этом блоке бот указывает клиенту приглашение к вводу текста, сохраняет введенный текст в переменную и переходит к следующему шагу сценария."	['- InputText позволяет боту запросить у пользователя произвольный текст и сохранить его в переменную.']	0.788614317034496	0.3901785714188169	1.0
Как можно сохранить введенный пользователем текст в переменную с помощью действия InputText?	"['И, наконец, добавим еще одну строку: $TEXT::isname Данная строка будет отрабатывать только в том случае, если ни один из других примеров не отработал. Введенное на данном экране сообщение клиента будет попадать в нее полностью. Этот $TEXT нам нужен на случай, если клиент добавил необычное имя одним словом. По умолчанию, когда вы переходите в редактирование блока Интенты и начинаете добавлять строки, они добавляются как примеры фраз, а не как шаблоны. Об этом свидетельствует иконка . Нажмите Сохранить. Теперь можно удалить экран с текстом Вас правда зовут $queryText?, так как у вас есть сущность $TEXT, которая будет принимать любую строку. Если в интентах есть $TEXT, то ветка Любая другая фраза отрабатывать не будет. Далее нам нужно сделать связь от интента \\* меня \\* зовут $TEXT::isname и создать блок Условия: В блок Условия вставьте следующее выражение: $name = $NAME ? $NAME.name : $isname С помощью этого условия вы создаете переменную $name. = — это оператор языка программирования JavaScript, с помощью которого присваивается значение переменной $name. Далее идет логическое выражение. Если у вас ранее что-то попало в системную сущность $NAME, то переменная $NAME.name будет записываться в переменную $name. Если же в системную сущность $NAME ничего не попало, то в $name запишется значение $isname. В итоге в переменной $name окажется имя из словаря или принятое необычное имя.'
 'То есть по сути мы складываем значения переменных, которые получили в ходе сценария, с текстом, который будет пояснять их значение. Также мы используем переменную $rawRequest.user_info.id, которая будет содержать значение id страницы пользователя. И добавляем переносы строк с помощью знака \\\\n. После присвоения значения переменной $text, мы ставим запятую, пробел и создаем переменную $num. Этой переменной мы присваиваем случайное значение от 1 до 9223372036854775808 с помощью метода \\_.random. Этот параметр нужен для идентификации сообщения при отправке в ВКонтакте. Если вы используете в сценарии другие переменные, то измените, соответственно, и текст условия в соответствии с вашим сценарием. Напоминаем, что бот может отправлять сообщения только тем пользователям, с которыми он уже общался. Поэтому, чтобы менеджер, который обрабатывает заявки пользователей, мог получать сообщения, он должен для начала написать любое сообщение самому сообществу. :size=400 Оформите HTTP-запрос От блока Условие создайте связь с блоком HTTP-запрос. :size=400 метод POST в BODY скопируйте и вставьте: {""response"": 484045} :size=400 Вкладки RESPONSE и HEADERS заполнять не нужно. Составим URL запроса. Он может выглядеть примерно так: Разберем его по частям.'
 'Блок text to $var Блок text to $var позволяет боту получить текст от клиента и сохранить его в переменную. Блок доступен через меню Добавить экран → Еще блоки → text to $var. Полученные значения переменной можно использовать в последующих шагах сценария (например, обращение по имени), выгружать в .csv или отправлять в стороннюю систему (например, в свою базу данных). Подробнее о переменных Параметры При добавлении этого блока нужно указать текст, который бот будет показывать клиенту в качестве приглашения к вводу текста, а также имя переменной, в которую нужно сохранить введенный клиентом текст. Здесь бот напишет клиенту Введите текст и будет ожидать ввода произвольного текста. После того как клиент введет текст, бот сохранит его в переменную text и перейдет к следующему экрану сценария. Бот не будет каким-либо образом интерпретировать ввод, а просто сохранит все, что клиент ввел в переменную. Если вам нужно, чтобы бот реагировал на определенные фразы, используйте блок Интенты. HTML-разметка Вы можете использовать HTML-разметку в текстовых сообщениях. Для этого активируйте переключатель Использовать в сообщении HTML разметку. Не все каналы поддерживают HTML-разметку. Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений.'
 'От варианта Завершен успешно протяните связь и создайте блок условий с текстом: $items.first() От $items.first() сделайте связь и создайте блок Текст с текстом: заметка$items.current().noteбыла сделана в следующую дату:$items.current().date Таким образом, мы будем доставать из переменной item элементы note и date. Создайте на этом экране блок Переход. Протяните от него связь и создайте новый блок условий с текстом: $items.next() От $items.next() сделайте связь с новым текстовым блоком: Читать дальше? и добавьте на него кнопки Читать дальше и Записать. Соедините кнопку Читать дальше с блоком, на котором есть следующий текст: Шаг 8. Создайте глобальный блок фраз Создайте новый экран, поместите на него блок Интенты. Обязательно поставьте галочку ""Глобальный блок"". Добавьте следующие шаблоны фраз: \\* \\*чит\\* \\* – свяжите этот вариант с блоком чтения из Google Таблиц \\* \\*пис\\* \\* – свяжите этот вариант с блоком, на котором есть текст Что записать? Можете также добавить другие подобные шаблоны. Таким образом, вы можете из любого места сценария попросить бота записать или прочитать заметки, и он среагирует соответствующе на разные формулировки. После добавления глобального блока фраз вам больше не нужно связывать кнопки, на которых есть текст, попадающий в шаблон. Шаг 9. Завершите сценарий Добавьте в конец сценария последний текстовый блок: Больше заметок нет! Записать еще одну или читать с начала? Добавьте на этот экран кнопки Писать и Читать.'
 'Запись должна появиться в первой пустой строке таблицы. Каждая переменная будет записана в отдельную ячейку строки. Строка не появилась Если строка не добавилась, возможно, вы указали другое название таблицы или папки в настройках апплета, и IFTTT создал для вас другую таблицу. Перейдите на главную страницу IFTTT, выберите свой апплет и нажмите Settings под вашим профилем в правом верхнем углу. На странице редактирования апплета нажмите Edit в блоке Then. Проверьте, правильно ли вы указали название таблицы и название папки. Содержимое полей должно совпадать с названиями таблицы и папки, которые находятся у вас на Google Диске. Строка появилась Если строка добавилась в Google Таблицу, вернитесь на страницу тестирования вебхука. Если ячейка с названием события очистилась, укажите его там снова. Ниже появится ссылка на вебхук. Скопируйте и сохраните ее. Подключение события к боту Добавление HTTP-запроса Перейдите в сценарий вашего бота в Aimylogic. Чтобы передать данные в таблицу, нужно записать их в какую-либо переменную. Для этого добавьте блок $text to var и напишите переменную $message. Все что клиент напишет на данном экране, будет помещено в эту переменную. Свяжите ветку Переход после ввода $message с блоком HTTP-запрос. Заполните поля блока: В качестве метода выберите POST. В поле URL вставьте адрес вебхука, который вы скопировали ранее. Вкладку RESPONSE оставьте без изменений.'
 'Здесь используется встроенная функция first, чтобы вывести первый элемент массива. Присвоение нуля От условия $items.first() сделайте связь со следующим блоком Условия, в котором напишите $index = 0. Свяжите оба варианта — и true, и else — со следующим экраном. Так как здесь переменной присваивается 0, нужно связывать оба варианта. Подробнее о присвоении нуля Вывод текущей заметки На следующем экране добавьте блок Текст и напишите в нем $items.current().note. Здесь вы выводите текущую заметку. На этот же экран добавьте блок Переход. Переход к следующей заметке От блока Переход создайте блок Условия, в котором напишите $items.next(). Проверка оставшихся элементов массива С помощью функции next проверьте, есть ли еще элементы массива. От else сделайте связь с новым экраном, на который добавьте блок Текст с сообщением Заметок больше нет. От $items.next() сделайте связь с блоком Условия, в котором напишите $index = $index + 1. Если есть еще один элемент массива, то к переменной $index прибавится 1. Таким образом будет осуществляться подсчет числа выведенных элементов. От $index = $index + 1 сделайте связь с блоком Условия, в котором напишите $index % 5 == 0. Здесь используется оператор Остаток от деления языка JavaScript. Этот оператор возвращает остаток от деления левого операнда на правый — то есть, остаток деления $index на 5. Также здесь используется оператор сравнения ==, который сравнивает остаток от деления с 0.'
 'Сохранить результат последнего ввода клиента Когда клиент пишет или говорит что-то, что попадает под какой-либо интент, вся реплика клиента сохраняется в системную переменную $queryText. Когда срабатывает новый интент, данные в переменной $queryText перезаписываются. Чтобы сохранить ответ клиента и иметь к нему доступ на любом этапе сценария, вы можете создать новую переменную, присвоив ей значение переменной $queryText через блок Условия: Пример сценария: Пример диалога: Подробнее о сохранении в переменную последнего ввода клиента Сохранить результат HTTP-запроса Aimylogic автоматически сохраняет результат выполнения HTTP-запроса в системную переменную $httpResponse. При выполнении нового запроса данные в переменной $httpResponse перезаписываются. Чтобы не потерять данные определенного запроса, вы можете присвоить значение $httpResponse новой переменной через блок HTTP-запрос: Блок HTTP-запрос Подробнее о сохранении результата HTTP-запроса в переменную Как дать имя переменной У переменной должно быть имя, чтобы бот мог обращаться к ней в сценарии. Когда вы создаете переменную любым способом, вы указываете имя переменной самостоятельно. Системные переменные имеют свои зарезервированные имена. Имя переменной: Может содержать цифры, латинские буквы любого регистра и знаки нижнего подчеркивания. Должно начинаться с буквы. Не должно совпадать с зарезервированными словами языка JavaScript.'
 'Системные переменные Системные переменные создаются Aimylogic автоматически. Вы можете оперировать ими точно так же, как и переменными, которые вы добавили в блоках. $queryText В переменной $queryText хранится полный текст текущего пользовательского запроса. С помощью переменной $queryText вы можете передавать введенный пользователем текст. Например, если вы используете блок Интенты, вы можете передать попавший туда текст с помощью HTTP-запроса и собирать все реакции пользователя, например, в свою Google Таблицу. Для этого добавьте блок Условие и в нем напишите: $reply = $queryText Таким образом, мы создаем новую переменную $reply, которая будет содержать ввод пользователя. Далее, вы можете передать ее с помощью сервиса IFTTT. В блоке Условия вы можете использовать любые Javascript выражения. В Javascript знак равенства используется для присвоения, поэтому мы в этом случае не уравниваем содержание этих переменных, а превращаем содержание системной переменной $queryText в содержание переменной $reply. Затем вы можете выводить эту созданную переменную или передавать ее сообщением в Telegram, письмом или отправлять в Google Таблицу. И все благодаря системной переменной $queryText. $userId Уникальный идентификатор пользователя, который не меняется со временем. Этот идентификатор является уникальным только для пары бот-пользователь. То есть, если тот же самый пользователь обратится к другому вашему боту, то идентификатор уже будет другим.'
 'Далее мы можем уже работать с этой переменной. Нажмите Сохранить. От варианта ""Завершен с ошибкой"" добавьте связь с блоком Текст. Скопируйте и вставьте в него: Ошибка $httpStatus Если в процессе тестирования вы увидите это сообщение об ошибке, значит вы сделали что-то не так шагом ранее. Проверьте, не допустили ли опечатку в запросе. От варианта ""Завершен успешно"" создайте новый блок Условия. Скопируйте и вставьте в него: $items.first() Здесь мы используем встроенную функцию Aimylogic для того чтобы вывести первый элемент массива. Подробнее о функциях Aimylogic можете почитать здесь. От блока Условия сделайте связь с новым блоком Текст. Скопируйте и вставьте в него: $items.current().question Сохраните сценарий. Перейдите на вкладку Сущности. Нажмите ""Создать справочник"". Скопируйте и вставьте название справочника: answers Нажмите Продолжить. Теперь будьте внимательны. Перейдите в вашу Google Таблицу с ответами на вопросы. Перенесите ответы из колонки ""answer"" в справочник в колонку ""Сущность"". Названия сущностей должны быть полностью идентичны ответам из вашей таблицы. Если в них будет ошибка, ответ не будет сходиться. Поэтому копируйте и вставляйте названия сущностей из колонки ""answer"" вашей Google Таблицы. В нашем случае у сущностей будут следующие названия: 4 Земля Как и в Google Таблице. В колонку ""синонимы"" можно добавить другие варианты написания. Например, для сущности ""4"" добавим синоним ""четыре"" и ""четверочка"".'
 'Здесь можно указывать данные в любом формате (JSON, XML, произвольный текст), а также добавлять переменные. Настройка тела HTTP-запроса В примере тело запроса указано в формате JSON. Бот автоматически подставит в тело запроса значения переменных $client.name и $client.age. При добавлении переменных в объект JSON необходимо учитывать, какой тип данных содержится в переменной. В примере переменная $client.name указана в кавычках, потому что она содержит данные строкового типа, а $client.age без кавычек, потому что содержит число. Обработка ответа В ответ на запрос сервер обычно возвращает данные, которые можно обработать или вывести клиенту. Для этого на вкладке Response вы можете указать, какие данные из ответа вы хотите сохранить в новые переменные. Например, по адресу https&#x3A;//api.forismatic.com/api/1.0/?method=getQuote&format=json&lang=ru сервер возвращает следующий ответ: JAICP сохраняет этот ответ в переменную $httpResponse. Поскольку это ответ в формате JSON, JAICP автоматически конвертирует его в JavaScript-объект, с которым сценарий может далее работать. Ответы в формате XML также конвертируются в JavaScript-объекты. Если же сервер вернул ответ в другом формате, он сохранятся в $httpResponse как строка без какой-либо обработки. Чтобы сохранить данные из определенного поля объекта, на вкладке Response укажите: Имя переменной. Значение будет сохранено в сценарии как $session.&lt;имя переменной>.']"	"Вы можете сохранить введенный пользователем текст в переменную с помощью блока ""text to $var"". При добавлении этого блока вы указываете текст, который будет отображаться клиенту в качестве приглашения к вводу текста, а также имя переменной, в которую нужно сохранить введенный текст. После ввода текста клиентом, он будет сохранен в указанную переменную и вы сможете использовать его в последующих шагах сценария."	['- Действие InputText позволяет боту запросить у пользователя произвольный текст и сохранить его в переменную.\n- Параметры Использование в сценарии.']	0.9210175702629014	0.6926190476051952	1.0
Какой статус возвращает метод $http.checkUrls для внешнего URL, если ни один из них не вернул статус 200 OK?	"['$http.check Метод проверяет, что HTTP-запрос к одному из внешних URL возвращает статус 200 OK. Синтаксис Метод принимает два аргумента. Метод возвращает массив с одним элементом — первым URL, который вернул статус 200 OK. Если ни один из них не вернул статус 200 OK, метод возвращает \\[null]. Также существует метод $http.checkUrls. Он принимает те же аргументы, что и $http.check, но возвращает массив со всеми URL, которые вернули статус 200 OK. Пример использования Метод полезно использовать, например, для интеграции в бота стриминговых аудиосервисов. В конфигурации можно указать основной URL сервиса и его зеркал, а для стриминга использовать первый доступный.'
 '$http.query Это основной метод встроенного HTTP-клиента JAICP. Он выполняет HTTP-запрос к внешнему ресурсу. Метод принимает два аргумента: строку с URL запроса и объект с настройками. URL запроса URL запроса может быть абсолютным и относительным. Абсолютный URL начинается с протокола http&#x3A;// или https&#x3A;// и задает полный путь до ресурса, к которому будет отправлен запрос. Относительный URL задает путь до ресурса относительно базового URL. Базовый URL должен быть предварительно задан в сценарии через $http.config. Настройки запроса Установка HTTP-метода Чтобы задать HTTP-метод, укажите в настройках запроса поле method. Кроме того, для наиболее часто используемых операций вы можете использовать альтернативные методы сервиса $http&#x3A; $http.get $http.post $http.put $http.delete Сигнатура и поведение этих методов такие же, как у $http.query. При этом они автоматически устанавливают поле method в нужное значение. Подстановка URL-параметров URL запроса может содержать выражения внутри последовательности символов ${}. При выполнении запроса они будут заменены на значения соответствующих полей из объекта query. Отправка HTML-форм Чтобы обратиться к ресурсу, который принимает запросы в формате HTML-форм, передавайте параметры формы в поле form вместо body. Такому запросу автоматически устанавливается заголовок Content-Type со значением application/x-www-form-urlencoded. Поля формы соответствующим образом кодируются в теле запроса.'
 'В итоге получится URL такого вида: https&#x3A;//tools.aimylogic.com/api/csv2json?url=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vT7n6-f8i4fD0Dlithvh06d5UsffCrZ6fl8O4CE_UVYPxN3rMy2NJkwRlllDs2g3IhsfCV3cY270H4k%2Fpub%3Fgid%3D0%26single%3Dtrue%26output%3Dcsv От сущности $DATETIME делаем новый экран с блоком Http-запрос и вставляем туда наш URL. Выглядеть запрос будет так. Под изображением вы найдете описание запроса, которое можете скопировать. Разберем переменные, которые мы создаем в http-запросе на вкладке Response:\\* time $DATETIME.hour + "":"" + ""00"" - берем из DATETIME только часы и прибавляем строку ""00"", чтобы часы соответствовали формату, который у нас в таблице; result \\_.where($httpResponse, {""time"": $time}) - метод из библиотеки Underscore; index 0 - нужен для прохода по всем элементам массива в дальнейшем; day $DATETIME.day &lt; 10 ? ""0"" + $DATETIME.day : $DATETIME.day - пишем условие: если день меньше 10, то прибавляем к дню 0, чтобы формат дня был таким, как в нашей таблице, иначе оставляем день таким, какой пришел; month $DATETIME.month &lt; 10 ? ""0"" + $DATETIME.month : $DATETIME.month - то же самое, что и с переменной $day, только месяц; date $day + ""."" + $month - формируем дату, складываем день и месяц. Далее от блока Http-запрос завершен успешно создаем блок Условие, в нем пишем:\\_.property($date)($result\\[$index]) === false \\_.property - возвращает функцию, которая вернет ключ key любого переданного ей объекта.'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get в url используйте ссылку, которую получили шагом выше на вкладке RESPONSE напишите название переменной: check и значение: \\_.findWhere($httpResponse, {""number"": 1}) где 1 - число, соответствующее порядковому номеру кода для соответствующего задания. В этом месте сценария, например, мы будем принимать за правильный ответ код 4444, который стоит в строке 1: Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный ли код. Он только делает запрос к url. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел код неверно. Поэтому мы будем проверять код на следующих шагах. Сам факт успешного завершения http-запроса не говорит о том, что введенный код был верным. Также, http-запрос получает информацию из соответствующей строки с помощью \\_.findWhere($httpResponse, {""number"": 1}) и записывает все, что есть в строке, которая соответствует номеру ""1"" в переменную $check. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите: Ошибка чтения кода $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи.'
 'С их помощью вы можете просматривать статусы сообщений, которые бот отправил в канале Chat API: GET /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message-statuses GET /chatapi/{token}/client/{clientId}/message-not-read-count Подробнее о статусах сообщений Строковые подстановки в YAML-справочниках В JAICP DSL всегда была поддержка шаблонных строк после тегов тегов реакций и действий. Например, вы можете написать: Внутри скобок {{}} может находиться любое допустимое выражение на JavaScript: например, ссылка на переменную. Во время работы бота оно будет вычислено и подставлено в строку. Часть пользователей предпочитает хранить ответы бота в отдельном YAML-справочнике. Однако если вы раньше пытались хранить в них шаблонные строки, то их вложенные JavaScript-выражения не вычислялись: Мы исправили это поведение: теперь строковые подстановки правильно вычисляются и в YAML-справочниках.'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get; в URL используйте ссылку, которую получили шагом выше. на вкладке RESPONSE напишите название переменной:userи значение:\\_.findWhere($httpResponse, {login: $entry}) вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный логин или нет. Он только делает запрос к URL. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел логин неверно. Поэтому мы будем проверять логин на следующих шагах. А сейчас же мы просто запрашиваем всю информацию из Google Таблиц. Также, http-запрос ищет в Google Таблицах введенный вами логин с помощью \\_.findWhere($httpResponse, {login: $loginentry}). Если логин присутствует в таблице, он помещает его в переменную $user. Но успешное завершение запроса вовсе не означает, что логин действительно был в таблице. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите:Ошибка чтения логина $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи. От варианта Завершен успешно сделайте связь с блоком Условие и напишите в него:$user Это условие будет проверять, записалось ли что-либо в переменную $user, то есть, был ли найден введенный пользователем логин.'
 'Хочешь еще раз? и совершит переход в стейт /Правила/Согласен?. Подсказки Если введенное число меньше, то бот посредством функции $reactions.answer() выдаст соответствующую фразу из массива selectRandomArg(). Например: Попробуй число больше. Функция selectRandomArg() предназначена для случайного выбора ответов из предложенных вариантов. Чтобы воспользоваться этой функцией, подключите JS-файлы common.js посредством require в начале файла main.sc. Затем перечислите в selectRandomArg() через запятую возможные варианты ответов. Например: Если введенное число не подошло под первые два условия, то сработает последний else и бот напишет случайно одно из сообщений массива. Таким образом, пользователь будет находиться в стейте Проверка до тех пор, пока не отгадает загаданное число. NoMatch Управление контекстом Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение пользователя не подходит ни под один описанный стейт. Предположим, что пользователь ввел следующее сообщение Сегодня солнечно. Такое сообщение не попадет ни под один интент, поэтому активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Если мы попадем в этот стейт, например, из стейта Правила, и пользователь затем введет сообщение хочу, то бот отправит сообщение я вас не понял.'
 'Функция first Кликните на Завершен успешно в блоке HTTP запрос, чтобы создать экран, на который бот перейдет, если поисковый сервис отработал корректно. На новом экране добавьте блок Условия Добавьте единственное условие вида $items.first() Функция first вернет первый элемент из массива, если массив не пуст. Таким образом бот пытается вытащить первый навык из результатов поиска, и если там что-то есть, то условие сработает, и бот перейдет на следующий экран. Нажмите на Сохранить и кликните на условие $items.first, чтобы связать его с новым экраном, на котором бот должен рассказать о навыке. Функция current На новом экране нужно рассказать о навыке, который мы нашли. Для этого добавьте блок Текст Тут бот вызывает функцию current, чтобы получить данные о текущем навыке из массива items. Из поля name можно получить название навыка. В поле examples хранится массив с примерами запросов. $items.current().name. Просто скажите Алисе - ""$items.current().examples\\[0]"". Так бот формирует строку ответа, например Футбольная игра Яндекса. Просто скажите Алисе - ""запусти навык футбольная игра"". Функция next Теперь нужно дать пользователю возможность послушать информацию о следующем найденном навыке. Для этого добавьте на этот же экран кнопку ""Еще варианты"". Кликните на нее, чтобы создать новый экран. На нем добавьте блок Условия Здесь тоже только одно условие $items.next() Функция next переместит бота на следующий элемент в массиве items, если там еще есть элементы.'
 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.'
 'От варианта Завершен успешно сделайте связь с блоком Условие и напишите в него: $entry === $check.code Это условие будет проверять, соответствует ли число, которое ввел пользователь, числовому коду, который содержится в строчке 1 колонки code. От else блока Условие сделайте связь с текстовым блоком, в котором напишите: Код неверный. Попробуйте еще раз. Добавьте на этот экран кнопку ""попробовать еще"" и свяжите ее с экраном запроса логина. От условия сделайте связь с текстовым блоком, в котором напишите: Код введен верно. Все, готово! Для других заданий можете повторять эту часть сценария, заменяя только число в Http запросе. Например, вместо \\_.findWhere($httpResponse, {""number"": 1}) для первого задания можете писать \\_.findWhere($httpResponse, {""number"": 2}) для второго задания. Ознакомьтесь с другими уроками по использованию Google Таблиц: Как сохранять информацию о пользователе Бронирование Как посмотреть статистику самого популярного запроса от пользователя Авторизация в Telegram']"	Метод $http.checkUrls возвращает массив с URL-адресами, которые вернули статус 200 OK. Если ни один из URL-адресов не вернул статус 200 OK, метод возвращает пустой массив.	['- Метод возвращает массив с одним элементом — первым URL, который вернул статус 200 OK.\n- Если ни один из них не вернул статус 200 OK, метод возвращает \\[null].\n- Он принимает те же аргументы, что и $http.check, но возвращает массив со всеми URL, которые вернули статус 200 OK.']	0.9051963327785204	0.9999999999	0.5
Какой элемент содержит массив, возвращаемый методом $http.check, если первый URL вернул статус 200 OK?	"['$http.check Метод проверяет, что HTTP-запрос к одному из внешних URL возвращает статус 200 OK. Синтаксис Метод принимает два аргумента. Метод возвращает массив с одним элементом — первым URL, который вернул статус 200 OK. Если ни один из них не вернул статус 200 OK, метод возвращает \\[null]. Также существует метод $http.checkUrls. Он принимает те же аргументы, что и $http.check, но возвращает массив со всеми URL, которые вернули статус 200 OK. Пример использования Метод полезно использовать, например, для интеграции в бота стриминговых аудиосервисов. В конфигурации можно указать основной URL сервиса и его зеркал, а для стриминга использовать первый доступный.'
 '+ $cart\\[$index].name + "" "" + $cart\\[$index].details + "" "" + ""по цене "" + $cart\\[$index].price + "" рублей"" : $str = """" Что здесь происходит: $cart\\[$index] - здесь мы проверяем элемент массива, номер которого соответствует index. То есть, мы смотрим, есть ли в массиве элемент под номером, который содержится в переменной $index. Так как ранее мы присвоили $index значение 0, то, если мы пришли к этому условию оттуда, то будем проверять нулевой элемент массива. Если же мы в другом условии увеличим $index, то будем проверять первый или второй элемент массива и т.д. Если элемент под номером $index есть, то выполняем первое условие - $str = ""&lt;br/>"" + $number + "". "" + $cart\\[$index].name + "" "" + $cart\\[$index].details + "" "" + ""по цене "" + $cart\\[$index].price + "" рублей"". В этом условии мы присваиваем переменной $str значения, которые содержат: - перенос строк - , - $number - порядковый номер элемента (создали ранее) - $cart$index.details - прибавляем фразу ""по цене "" - нужно обязательно поставить в кавычки. Чтобы значение переменной и эта фраза были разделены пробелом, его нужно добавить прямо во фразу - $cart$index.price - значение цены из Google Таблицы, которое будет выводиться для соответствующего товара - "" рублей"" - пробел и слово рублей Если элемента под номером $index нет, то выполняем $str = """", то есть, присваиваем переменной $str значение """". Это нужно будет для удаления товара из корзины. Затем, свяжите условие $cart\\[$index] ? $str = ""&lt;br/>"" + $number + "". ""'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get в url используйте ссылку, которую получили шагом выше на вкладке RESPONSE напишите название переменной: check и значение: \\_.findWhere($httpResponse, {""number"": 1}) где 1 - число, соответствующее порядковому номеру кода для соответствующего задания. В этом месте сценария, например, мы будем принимать за правильный ответ код 4444, который стоит в строке 1: Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный ли код. Он только делает запрос к url. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел код неверно. Поэтому мы будем проверять код на следующих шагах. Сам факт успешного завершения http-запроса не говорит о том, что введенный код был верным. Также, http-запрос получает информацию из соответствующей строки с помощью \\_.findWhere($httpResponse, {""number"": 1}) и записывает все, что есть в строке, которая соответствует номеру ""1"" в переменную $check. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите: Ошибка чтения кода $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи.'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get; в URL используйте ссылку, которую получили шагом выше. на вкладке RESPONSE напишите название переменной:userи значение:\\_.findWhere($httpResponse, {login: $entry}) вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный логин или нет. Он только делает запрос к URL. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел логин неверно. Поэтому мы будем проверять логин на следующих шагах. А сейчас же мы просто запрашиваем всю информацию из Google Таблиц. Также, http-запрос ищет в Google Таблицах введенный вами логин с помощью \\_.findWhere($httpResponse, {login: $loginentry}). Если логин присутствует в таблице, он помещает его в переменную $user. Но успешное завершение запроса вовсе не означает, что логин действительно был в таблице. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите:Ошибка чтения логина $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи. От варианта Завершен успешно сделайте связь с блоком Условие и напишите в него:$user Это условие будет проверять, записалось ли что-либо в переменную $user, то есть, был ли найден введенный пользователем логин.'
 '$http.query Это основной метод встроенного HTTP-клиента JAICP. Он выполняет HTTP-запрос к внешнему ресурсу. Метод принимает два аргумента: строку с URL запроса и объект с настройками. URL запроса URL запроса может быть абсолютным и относительным. Абсолютный URL начинается с протокола http&#x3A;// или https&#x3A;// и задает полный путь до ресурса, к которому будет отправлен запрос. Относительный URL задает путь до ресурса относительно базового URL. Базовый URL должен быть предварительно задан в сценарии через $http.config. Настройки запроса Установка HTTP-метода Чтобы задать HTTP-метод, укажите в настройках запроса поле method. Кроме того, для наиболее часто используемых операций вы можете использовать альтернативные методы сервиса $http&#x3A; $http.get $http.post $http.put $http.delete Сигнатура и поведение этих методов такие же, как у $http.query. При этом они автоматически устанавливают поле method в нужное значение. Подстановка URL-параметров URL запроса может содержать выражения внутри последовательности символов ${}. При выполнении запроса они будут заменены на значения соответствующих полей из объекта query. Отправка HTML-форм Чтобы обратиться к ресурсу, который принимает запросы в формате HTML-форм, передавайте параметры формы в поле form вместо body. Такому запросу автоматически устанавливается заголовок Content-Type со значением application/x-www-form-urlencoded. Поля формы соответствующим образом кодируются в теле запроса.'
 'Здесь используется встроенная функция first, чтобы вывести первый элемент массива. Присвоение нуля От условия $items.first() сделайте связь со следующим блоком Условия, в котором напишите $index = 0. Свяжите оба варианта — и true, и else — со следующим экраном. Так как здесь переменной присваивается 0, нужно связывать оба варианта. Подробнее о присвоении нуля Вывод текущей заметки На следующем экране добавьте блок Текст и напишите в нем $items.current().note. Здесь вы выводите текущую заметку. На этот же экран добавьте блок Переход. Переход к следующей заметке От блока Переход создайте блок Условия, в котором напишите $items.next(). Проверка оставшихся элементов массива С помощью функции next проверьте, есть ли еще элементы массива. От else сделайте связь с новым экраном, на который добавьте блок Текст с сообщением Заметок больше нет. От $items.next() сделайте связь с блоком Условия, в котором напишите $index = $index + 1. Если есть еще один элемент массива, то к переменной $index прибавится 1. Таким образом будет осуществляться подсчет числа выведенных элементов. От $index = $index + 1 сделайте связь с блоком Условия, в котором напишите $index % 5 == 0. Здесь используется оператор Остаток от деления языка JavaScript. Этот оператор возвращает остаток от деления левого операнда на правый — то есть, остаток деления $index на 5. Также здесь используется оператор сравнения ==, который сравнивает остаток от деления с 0.'
 'Функция first Кликните на Завершен успешно в блоке HTTP запрос, чтобы создать экран, на который бот перейдет, если поисковый сервис отработал корректно. На новом экране добавьте блок Условия Добавьте единственное условие вида $items.first() Функция first вернет первый элемент из массива, если массив не пуст. Таким образом бот пытается вытащить первый навык из результатов поиска, и если там что-то есть, то условие сработает, и бот перейдет на следующий экран. Нажмите на Сохранить и кликните на условие $items.first, чтобы связать его с новым экраном, на котором бот должен рассказать о навыке. Функция current На новом экране нужно рассказать о навыке, который мы нашли. Для этого добавьте блок Текст Тут бот вызывает функцию current, чтобы получить данные о текущем навыке из массива items. Из поля name можно получить название навыка. В поле examples хранится массив с примерами запросов. $items.current().name. Просто скажите Алисе - ""$items.current().examples\\[0]"". Так бот формирует строку ответа, например Футбольная игра Яндекса. Просто скажите Алисе - ""запусти навык футбольная игра"". Функция next Теперь нужно дать пользователю возможность послушать информацию о следующем найденном навыке. Для этого добавьте на этот же экран кнопку ""Еще варианты"". Кликните на нее, чтобы создать новый экран. На нем добавьте блок Условия Здесь тоже только одно условие $items.next() Функция next переместит бота на следующий элемент в массиве items, если там еще есть элементы.'
 'Пример Вызов JSON.stringify($jsapi.version()) вернет объект следующего вида:'
 'Подробнее об отправке переменных в HTTP-запросах'
 'Сценарий: .js-файл: Правило $entity записывает в value только идентификатор сущности, а список ассоциированных значений содержится в справочнике.']"	Метод $http.check возвращает массив с одним элементом — первым URL, который вернул статус 200 OK.	['- $http.check Метод проверяет, что HTTP-запрос к одному из внешних URL возвращает статус 200 OK.\n- Метод возвращает массив с одним элементом — первым URL, который вернул статус 200 OK.\n- Если ни один из них не вернул статус 200 OK, метод возвращает \\[null].\n- Он принимает те же аргументы, что и $http.check, но возвращает массив со всеми URL, которые вернули статус 200 OK.']	0.8421876505227629	0.9999999999	1.0
Какие способы взаимодействия с ботом поддерживает JAICP в ожидании события?	"['События Сценарии в JAICP поддерживают два способа взаимодействия с ботом: Запросы — сообщения, которые пользователь отправляет боту текстом или голосом. Их обрабатывает движок понимания естественного языка (NLU), после чего бот переходит в подходящий стейт и выполняет его реакции. События — действия, которые происходят в сценарии бота, в аккаунте JAICP или в канале, который подключен к проекту. В обработке событий не участвует NLU. Если бот может попасть в стейт, который ожидает событие, он сразу переходит в стейт и выполняет реакции. События могут иметь произвольную природу, например: Когда пользователь отправляет в чат файл, канал отправляет событие о получении файла. Сам движок NLU генерирует событие, если он не смог распознать запрос. Внешний сервис при помощи события может оповестить бота, что пользователь вошел в аккаунт. Типы событий Системные события Системные события по умолчанию доступны во всех сценариях JAICP. Подробнее о доступных событиях вы можете узнать в справочнике системных событий. Пользовательские события Разработчик может предусмотреть в сценарии обработку событий с произвольными именами. Такие события обычно используются для интеграции бота во внешние сервисы, например чат-приложения или CRM. Если бот подключен к каналу Chat API, внешний сервис может отправить в чат произвольное событие с помощью методов /chatapi/{token} и /chatapi/{token}/async.'
 'Обновления JAICP в октябре 2023 Интеграция с ChatGPT. Новая проектная аналитика: Переработанный раздел Обзор проекта. Новые методы сервиса $analytics. Настройка метрик аналитики. Новые подробные отчеты. Встроенный сервис $conversationApi. Оператор по умолчанию в Aimychat. Получение данных о воспроизведении реплики. Интеграция с ChatGPT В JAICP появилась интеграция с ChatGPT от OpenAI. Вы можете использовать ее, например, для генерации ответов на нераспознанные фразы пользователя или создания креативных решений. Вы можете обращаться к модели напрямую из сценария бота через встроенный сервис $gpt. Для этого вам не нужно иметь собственный API-ключ и токены от OpenAI. MLP-токены уже входят в тарифы JAICP. Чтобы модель генерировала ответы на фразы пользователей, вызовите в нужном стейте метод $gpt.createChatCompletion. В запросе вы можете передавать дополнительную информацию о контексте диалога и истории сообщений с пользователем. Тогда ответы ChatGPT будут более точными. Новая проектная аналитика В этом месяце мы полностью переработали инструменты проектной аналитики в JAICP. Интерфейс раздела Обзор проекта Теперь в разделе Обзор проекта представлена подробная статистика по работе бота. На графиках вам доступны сводные данные по количеству пользователей, сессий и сообщений, а также их изменения по периодам. Вы можете фильтровать значения по нужным периодам и каналам. Также вы можете анализировать метрики работы бота: Процент автоматизированных диалогов.'
 'Если клиент вел диалог в нескольких чатах одновременно, при выводе всех событий в канале и при отсутствии в запросе параметра cid метод может возвращать дубликаты сообщений. Параметр ts задает время, начиная с которого нужно фильтровать события. При его отсутствии запрашиваются все события с момента последнего обращения к серверу. Получение истории переписки Метод GET /chatapi/{token}/client/{clientId}/history позволяет получить историю переписки с клиентом за указанный период либо за все доступное время. Сохранение и загрузка состояния чат-приложения Следующие методы позволяют сохранить и загрузить состояние чат-приложения во время диалога с клиентом: GET /chatapi/{token}/client/{clientId}/state POST /chatapi/{token}/client/{clientId}/state В теле запроса к методу POST передается произвольный объект. Последующий запрос к методу GET вернет ранее переданный объект. Его содержимое не проверяется. Управление статусами сообщений Вы можете просматривать статусы сообщений, которые бот отправил в канале Chat API. В Chat API поддерживаются следующие статусы сообщений: Получение статуса сообщения Метод GET /chatapi/{token}/client/{clientId}/message/{questionId}/status позволяет получить статус сообщения. Параметры: token — токен канала Chat API. Перейдите в раздел Каналы, выберите канал Chat API и нажмите → Редактировать. Сохраните токен. clientId — идентификатор клиента. Вы можете найти идентификатор в разделе Аналитика → Клиенты. Выберите клиента и сохраните его ID.'
 'Встроенный сервис $conversationApi Новый встроенный сервис $conversationApi позволяет мгновенно отправлять сообщения бота в канал, не дожидаясь окончания обработки запроса пользователя. Раньше бот не мог отправлять сообщения пользователю во время выполнения внешнего запроса. Он сначала дожидался, пока внешний запрос вернет ответ, и только тогда мог отправить сообщения в канал. Теперь вы можете вызвать методы этого сервиса, например, для отправки мгновенных ответов бота в канал во время: Ожидания ответа от LLM-модели. Обработки или генерации файлов. Получения информации из CRM-системы. Оператор по умолчанию в Aimychat Теперь вы можете назначить оператора по умолчанию в группе операторов в Aimychat. В сценарии JAICP вы можете задать логику перевода диалога на этого оператора, если он не в сети. Получение данных о воспроизведении реплики Новый метод $dialer.getBotSpeech позволяет получать информацию о воспроизведении реплики бота в телефонном канале. Вы можете увидеть, в какой момент абоненты прекращают прослушивание реплик, проанализировать результаты и сократить некоторые реплики. Данные можно использовать в сценарии или фиксировать в виде комментариев в аналитике.'
 'Релиз JAICP 1.10.8 Управление часовым поясом клиента через методы $reactions. Запланированная отправка событий посредством сервиса $pushgate. Колонка Причина окончания звонка в отчетах по обзвонам. Поддержка поля segmentationInfo при переводе на оператора в канале edna.chatCenter. При регистрации через Google интерфейс отображается на русском языке. Ошибки при редактировании операторского канала и добавлении группы операторов. При большом количестве кнопок в чат-виджете кнопки не прокручиваются. Текст в квадратных скобках в чат-виджете не подсвечивается как кликабельный. Обновлены статьи о зависимостях и системных модулях. Расширено описание дополнительных настроек для сущностей CAILA. Дополнен пошаговый сценарий бота с обращением к API. С релизом 1.10.8 мы внесли крупное обновление в сервис $pushgate. Раньше в данном сервисе был реализован единственный метод createPushback, который используется для отправки событий в сценарий при каких-либо действиях во внешней системе. Теперь же сервис поддерживает методы для запланированной отправки событий по наступлении заданного времени. Таким образом, отправка событий больше не требует обязательной интеграции с внешними системами, что значительно упрощает создание исходящих рассылок через бота. В связи с появлением данной функциональности сервис $reactions был расширен методами для управления часовым поясом клиента, чтобы планировать новые события максимально точно.'
 'Событие будет отправлено на вебхук, если: Вы отправили асинхронный запрос. Вы провели рассылку. Клиент получил ответ от оператора. Время ожидания между ответами на запрос было превышено. Если запрос не был успешно выполнен, запрос будет отправлен повторно еще три раза. Время ожидания между ответами при асинхронных запросах составляет три секунды. На вебхук придет массив JSON-объектов: Расширение ответов настраиваемыми полями Вы можете расширить ответ бота с помощью настраиваемых полей. Используйте в сценарии объект $response: Поле foo и другие поля, которые вы зададите, будут доступны в ответе бота как вложенные в поле data. Получение асинхронных событий в чате Метод GET /chatapi/{token}/events предназначен для получения асинхронных событий от сервера, например: Ответ от оператора. Изменение состояния виджета на другой странице браузера. Запрос клиента, отправленный на другой странице. Ответ бота на запрос с другой страницы. Метод реализует стратегию long polling: если нет подходящих событий, он блокируется в ожидании следующего события. Максимальное количество событий в ответе на запрос — 250. Если нужно обработать больше, используйте метод для получения истории переписки. Фильтрация событий Параметр all данного метода определяет, нужно ли выводить все события в канале или только ответы от оператора (поведение по умолчанию).'
 'Исходящие коммуникации Боты в JAICP обычно работают во входящем режиме: пользователь инициирует общение, а бот обрабатывает запросы и отправляет ответы в том же канале. Однако вы можете спроектировать бота так, чтобы он самостоятельно вступал в диалог с пользователями и рассылал им сообщения. Исходящие рассылки и обзвоны Рассылки и обзвоны — основные инструменты для автоматизации исходящих коммуникаций. Они работают на основе списков клиентов, загруженных в JAICP. Ознакомьтесь с пошаговым сценарием Исходящий обзвон, чтобы подробно узнать, как разрабатывать и запускать исходящие рассылки в телефонном канале. Действия бота в ответ на внешние события Встроенный JavaScript-сервис $pushgate позволяет активировать сценарий бота не только по запросам от пользователей, но и по внешним событиям. Такими событиями могут быть: HTTP-запрос от внешней системы на определенный адрес — используйте метод $pushgate.createPushback. Наступление определенного времени — используйте метод $pushgate.createEvent. Пройдите пошаговый сценарий Бот для напоминаний, если хотите научиться обрабатывать в сценарии наступление событий, запланированных на определенное время. Отправка сообщений из сценария бота В ходе диалога бот может отправлять сообщения и с помощью других инструментов общения.'
 'Преимущество такого способа в том, что вы сможете подключить каналы и CRM-системы, доступные на стороне бизнес-канала, хранить в бизнес-канале не только диалоги операторов с клиентами, но и диалоги бота, а также использовать другие инструменты, доступные в бизнес-канале. При составлении сценария бота вам необходимо учитывать ограничения платформы, через которую будет общаться бот. Такой способ взаимодействия доступен со следующими платформами онлайн-чатов: Битрикс24 edna.chatCenter Jivo LiveTex (как бизнес-канал) Webim (External Bot API 2.0) Через чат-виджет платформы Бот может общаться с клиентами в чат-виджете платформы онлайн-чатов. Чтобы бот общался с клиентами в стороннем чат-виджете: Создайте сценарий бота. Подключите и настройте бизнес-канал. Добавьте в сценарий блок Перевод на оператора. Настройте чат-виджет платформы и разместите его на вашем сайте. Бот будет общаться с клиентами в чат-виджете бизнес-канала. Все диалоги бота с клиентами будут храниться и в рабочем месте оператора на платформе, и в логах бота в Aimylogic. Бот сможет при необходимости переводить диалоги на оператора, а оператор — обратно на бота, если такая возможность поддерживается платформой.'
 'Обновления JAICP в октябре 2022 Поддержка ECMAScript 6. Асинхронная работа канала Chat API. Изменение настроек ASR и TTS из сценария. Поддержка ECMAScript 6 До сих пор для сложной бизнес-логики ботов на JAICP поддерживался только устаревший диалект JavaScript согласно спецификации ECMAScript 5. В октябрьском обновлении JAICP мы запускаем бета-тестирование новой среды исполнения JavaScript, которая позволяет: Писать код проектов на JAICP с применением новых возможностей ECMAScript 2015 и более поздних стандартов: разбивать код на модули, использовать классы, асинхронные функции и многое другое. Для расширения функциональности бота не только обращаться к встроенному JS API, но и самостоятельно подключать внешние зависимости — npm-пакеты, написанные сторонними разработчиками. Подробнее о поддержке ECMAScript 6 в JAICP Если вы хотите принять участие в бета-тестировании, свяжитесь со своим аккаунт-менеджером или напишите нам на client@just-ai.com. Асинхронная работа канала Chat API В настройках подключения канала Chat API появилось поле для ввода вебхука. Вы можете получать на него сообщения бота или события при работе с асинхронными запросами. Асинхронность позволяет обрабатывать несколько запросов одновременно: вы можете отправлять новые запросы, не ожидая, пока сервер закончит обрабатывать предыдущие. Например, с асинхронными запросами вы сможете отправлять рассылки без задержек и получать асинхронные события без дополнительных запросов.'
 'Встроенный сервис $pushgate позволяет создавать из сценария события по расписанию, а также пушбэки — специальные сущности для обработки событий через Pushgate API. Пользовательские события также можно использовать в сценарии, чтобы активировать бота при запуске текстовых рассылок. Использование в сценарии Чтобы задать событие, по которому диалог может перейти в стейт, используйте глобальный тег event! или локальный тег event. После тега указывается название события. Некоторые события могут иметь вложенные данные. Их можно получить в стейте, который сработал по событию, через объект $request одним из способов: $request.data.eventData $request.rawRequest.eventData Набор данных зависит от типа события. Например, данные по событию stickerEvent содержат метаданные стикера: размер, наличие анимации, соответствующий эмодзи и другую информацию. Справочник системных событий События NLU События NLU работают только на второй версии диалогового движка. На первой версии событие match не актуально, а вместо event! : noMatch используется паттерн q! : \\*. События ограничений запроса События переполнения \\\\$session и \\\\$client События отправки SMS События аккаунта События входящих каналов События fileEvent и fileTooBigEvent поддерживаются во всех входящих каналах, кроме Jivo, Zendesk и Zendesk Chat. В чат-виджете поддерживается только событие fileEvent.']"	JAICP поддерживает два способа взаимодействия с ботом в ожидании события: запросы и события. Запросы - это сообщения, которые пользователь отправляет боту текстом или голосом, и их обрабатывает движок понимания естественного языка (NLU). События - это действия, которые происходят в сценарии бота, в аккаунте JAICP или в подключенном к проекту канале. В обработке событий не участвует NLU. Если бот может попасть в стейт, ожидающий событие, он сразу переходит в стейт и выполняет реакции. События могут быть системными или пользовательскими.	['События Сценарии в JAICP поддерживают два способа взаимодействия с ботом: Запросы — сообщения, которые пользователь отправляет боту текстом или голосом.\nСобытия — действия, которые происходят в сценарии бота, в аккаунте JAICP или в канале, который подключен к проекту.\nЕсли бот может попасть в стейт, который ожидает событие, он сразу переходит в стейт и выполняет реакции.\nСобытия могут иметь произвольную природу, например: Когда пользователь отправляет в чат файл, канал отправляет событие о получении файла.\nТипы событий Системные события Системные события по умолчанию доступны во всех сценариях JAICP.\nПользовательские события Разработчик может предусмотреть в сценарии обработку событий с произвольными именами.\nВстроенный сервис $pushgate позволяет создавать из сценария события по расписанию, а также пушбэки — специальные сущности для обработки событий через Pushgate API.\nПользовательские события также можно использовать в сценарии, чтобы активировать бота при запуске текстовых рассылок.\nЧтобы задать событие, по которому диалог может перейти в стейт, используйте глобальный тег event! или локальный тег event.\nСобытия NLU События NLU работают только на второй версии диалогового движка.\nСобытия fileEvent и fileTooBigEvent поддерживаются во всех входящих каналах, кроме Jivo, Zendesk и Zendesk Chat.\nСобытия telegramPaymentSuccessEvent, telegramPaymentFailedEvent и telegramPrecheckoutEvent нужно обрабатывать, только если вы настраиваете оплату в Telegram через тип ответа telegramPayment.\nКогда в канал Vonage WhatsApp приходит любое нетекстовое сообщение, в сценарий отправляется событие с названием его типа, например event: audio.']	0.974625166403566	0.7260912698321936	1.0
Какие поля принимает метод $mail.send для отправки email-сообщения и какой статус возвращает этот метод при успешной отправке?	"['Возможные значения: readDataFromCells writeDataToCells writeDataToLine deleteRowOrColumn clearCellData customRequest &lt;parameters> — список аргументов, передача которых ожидается при вызове метода. Содержит вложенные элементы, теги которых соответствуют названиям аргументов. Например, метод readDataFromCells принимает аргументы integrationId, spreadsheetId, sheetName и cells, поэтому элемент &lt;parameters> может быть заполнен так: &lt;response> — ответ в формате JSON, который будет принят за ответ от метода при выполнении теста. Пример Рассмотрим следующий фрагмент сценария. Бот принимает время и произвольный текст, которые он записывает в новую строку таблицы через метод writeDataToLine. Работу такого стейта можно проверить при помощи теста, приведенного ниже. Поскольку в примере используется сущность @duckling.time, для тест-кейса необходимо переопределить текущее время через тег &lt;dateTime>. В значении &lt;response> указаны не все поля, которые возвращает интеграция: достаточно перечислить лишь те поля, которые используются в коде сценария.'
 '$response Объект для заполнения поля $response в ответах системы. $response.replies — список ответов, выведенных в процессе обработки реакций. replies — массив реплик чат-бота, содержащий строго типизированные элементы. Предназначен для передачи ответов в различные каналы коммуникации, такие как Telegram, Google Assistant и др. Ниже представлен список replies, поддерживаемых платформой. Формат ответа бота, параметры и типы сообщений для каналов подробно описаны в статье Типы ответов. replies Поддерживаемые элементы replies: text — простой текстовый ответ, каждый элемент выводится отдельным сообщением. Параметр tts задаёт текст ответа с разметкой для синтеза речи. Параметр markup задаёт способ форматирования. buttons — вывод кнопки. inlineButtons — вывод инлайн-кнопки. Если заполнено поле inlineButtons\\[].url, по клику будет открыт указанный url. image — вывод изображения. raw используется для передачи методов, специфичных для определенного канала. Обязательный параметр body — тело ответа, которое будет передано в чат-систему. Параметры, идентифицирующие пользователя в чате, будут подставлены автоматически. switch — переключение диалога клиента с бота на оператора. location — вывод координат. Параметры: lat, lon. timeout задает переход в состояние, если от пользователя нет ответа. dtmf — запрос набора DTMF-сообщения (цифры/символы в тоновом режиме). Только для телефонных звонков. hangup — прерывание звонка. Только для телефонных звонков.'
 'Параметры Метод $dialer.redial принимает в качестве аргумента объект со следующими полями: Передаваемый объект обязательно должен содержать поля startDateTime или allowedTime. Если прочие поля не указаны, их значения будут взяты из настроек обзвона. Формат значений полей allowedDays и allowedTime полностью аналогичен одноименным полям в теле запроса к методу POST /addPhones API для звонков.'
 'С их помощью вы можете просматривать статусы сообщений, которые бот отправил в канале Chat API: GET /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message/{questionId}/status POST /chatapi/{token}/client/{clientId}/message-statuses GET /chatapi/{token}/client/{clientId}/message-not-read-count Подробнее о статусах сообщений Строковые подстановки в YAML-справочниках В JAICP DSL всегда была поддержка шаблонных строк после тегов тегов реакций и действий. Например, вы можете написать: Внутри скобок {{}} может находиться любое допустимое выражение на JavaScript: например, ссылка на переменную. Во время работы бота оно будет вычислено и подставлено в строку. Часть пользователей предпочитает хранить ответы бота в отдельном YAML-справочнике. Однако если вы раньше пытались хранить в них шаблонные строки, то их вложенные JavaScript-выражения не вычислялись: Мы исправили это поведение: теперь строковые подстановки правильно вычисляются и в YAML-справочниках.'
 '$mail.send Метод отправляет email-сообщение с передачей настроек SMTP-сервера. Если ваш сценарий предусматривает неоднократную отправку email, вы можете использовать более простой метод $mail.sendMessage. Синтаксис Метод принимает в качестве аргумента объект со следующими полями: Метод возвращает объект с полем status — статус отправки сообщения: OK — сообщение успешно отправлено. UNABLE_TO_CONNECT — не удалось подключиться к SMTP-серверу. INCORRECT_ADDRESS — в адресе отправителя или получателя передана пустая строка. Использование в сценарии'
 '$mail.sendMessage Метод отправляет email-сообщение через заранее настроенный SMTP-сервер. Чтобы использовать этот метод, сперва задайте настройки SMTP-сервера через chatbot.yaml или метод $mail.config. Синтаксис Метод принимает три аргумента: Метод возвращает объект с полем status. Возможные статусы отправки сообщений: OK — сообщение успешно отправлено. UNABLE_TO_CONNECT — не удалось подключиться к SMTP-серверу. INCORRECT_ADDRESS — в адресе отправителя или получателя передана пустая строка. Использование в сценарии'
 'timeout — максимальное время обработки запроса в миллисекундах. По умолчанию ограничение включено со значением таймаута 10000 (10 секунд). Если запрос превысит ограничение, в сценарии возникнет событие timeLimit. XML-тесты XML-тесты сценариев позволяют проверить логику чат-бота, эмулируя запросы клиента и проверяя ответы от бота. По умолчанию выполняются все тесты из файлов в папке проекта test. Это поведение можно переопределить в секции tests, задав значения для подсекций include и/или exclude: include — будут выполнены тесты только из тех файлов, которые попадают под шаблоны, перечисленные в этой подсекции. exclude — из выполнения будут исключены все файлы, которые попадают под шаблоны, перечисленные в этой подсекции. Шаблоны используют синтаксис Apache Ant. Поле caseSensitive определяет, должны ли шаблоны учитывать регистр названий файлов. Значение по умолчанию — true. Зависимости Секция dependencies позволяет задать список зависимостей проекта. Подробнее о зависимостях Теги действий Секция customTags задает список самостоятельно созданных тегов действий, которые используются в проекте. Пользовательские реакции Секция customBlocks задает список пользовательских реакций, которые используются в рассылках. Сообщения об ошибках Секция messages.onError позволяет задать текст сообщения, которое бот отправит при возникновении какой-либо ошибки. В подсекции locales могут быть заданы тексты сообщений, локализованные исходя из данных о пользователе.'
 ':size=400 Выберите метод POST В поле URL HTTP-запроса вставьте адрес вебхука, который вы скопировали в блокнот ранее Вкладку RESPONSE заполнять не нужно Вкладку Body нужно заполнять по-разному в зависимости от того, какое содержание запроса вы хотите получить Перейдите на вкладку Headers и добавьте там заголовок Content-Type со значением application/json Если вы не заполните вкладку HEADERS запрос будет завершен с ошибкой :size=400 Нажмите Сохранить Добавьте блоки ответа для успешной и неуспешной отправки данных От Завершен с ошибкой сделайте связь с блоком с текстом: ошибка отправки $httpStatus :size=400 От варианта Завершен успешно сделайте связь с текстовым блоком с текстом: Ваши данные отправлены! :size=400 Теперь, когда чат-бот дойдет до блока HTTP-запрос, он отправит нужные вам значения в сервис интеграции, который обработает их и отправит дальше в зависимости от настроек в самом сервисе. Нажмите Тестировать и проверьте, работает ли передача данных :size=400 Активируйте вебхук в сценарии После того, как вы прописали URL вашего вебхука, вы можете включать и выключать события на экранах в сценарии вашего бота. Для этого укажите название события в заголовке экрана: Вы можете выбрать любой цвет заголовка, а затем кликнуть на значок вебхука, чтобы он загорелся: Если событие на экране включено, то бот будет отправлять переменные и выбранное событие на сервер, а затем копировать переменные из ответа сервера. Только после этого бот будет выполнять блоки на экране.'
 'Формат значений полей allowedDays и allowedTime полностью аналогичен одноименным полям в теле запроса к методу POST /addPhones API для звонков.'
 'Ответы бота JAICP позволяет передавать различные сообщения бота в единообразном виде, например, картинки или кнопки. Переданные сообщения при этом будут преобразованы в вид, специфичный для каждого канала. Для некоторых перечисленных ниже ответов бота существуют эквивалентные DSL-теги или методы через встроенный сервис $reactions. Формирование ответов В сценарии ответы бота формируются с помощью системной переменной $response. Ответы бота собираются в массив $response.replies. Чтобы добавить новый ответ бота в массив, нужно вызвать метод push. Перед тем как добавить ответ в массив, нужно инициализировать поле replies в переменной $response. Если поле не инициализировано, значение в $response.replies будет undefined. В таком случае, когда бот начнет выполнять реакции, возникнет ошибка Cannot read property “push” from undefined. Поэтому если поле replies уже было ранее определено (например, если в стейте уже есть реакции, вызванные через DSL-теги или методы), то присваиваем ему это же значение. Иначе присваиваем пустой массив. Ограничения Один ответ бота может содержать не более 100 элементов в массиве $response.replies. Их суммарная длина не должна превышать 50 000 символов. Ответы бота специфичны для каждого канала: канал может иметь ряд собственных ограничений на передаваемые свойства или вовсе не поддерживать тип ответа. В каждой статье перечислены каналы, в которых поддерживается определенный тип ответа.']"	"Метод $mail.send принимает в качестве аргумента объект со следующими полями: 
- to (обязательное поле) - адрес получателя;
- from (обязательное поле) - адрес отправителя;
- subject (обязательное поле) - тема письма;
- text (обязательное поле) - текст письма;
- cc - адреса получателей копии;
- bcc - адреса получателей скрытой копии;
- replyTo - адрес для ответа на письмо;
- attachments - массив вложений.

Метод возвращает объект с полем status, которое указывает на статус отправки сообщения. При успешной отправке, поле status будет иметь значение ""OK""."	['- $mail.send Метод отправляет email-сообщение с передачей настроек SMTP-сервера.\n- Если ваш сценарий предусматривает неоднократную отправку email, вы можете использовать более простой метод $mail.sendMessage.\n- Метод принимает в качестве аргумента объект со следующими полями:\n- Метод возвращает объект с полем status — статус отправки сообщения: OK — сообщение успешно отправлено.\n- UNABLE_TO_CONNECT — не удалось подключиться к SMTP-серверу.\n- INCORRECT_ADDRESS — в адресе отправителя или получателя передана пустая строка.']	0.955927417328307	0.2666666666533333	0.3076923076923077
Какие услуги включены в тариф для звонков Aimylogic?	"['Для ваших клиентов звонки от ботов Aimylogic тарифицируются так же, как любые другие звонки.'
 'API для звонков Aimylogic предоставляет API для звонков — Calls API, чтобы вы могли интегрировать телефонию Aimylogic с любыми внешними системами. С помощью Calls API вы сможете: запускать обзвоны; добавлять номера в базу; получать отчеты по номерам телефона или задачам в обзвоне. Начало работы с Calls API Перед началом работы с Calls API необходимо: Настроить телефонию. Создать сценарий обзвона. Настроить и запустить обзвон. Методы API API предоставляет следующие методы. Добавление номеров в обзвон. POST https&#x3A;//app.aimylogic.com/api/calls/campaign/{token}/addPhones Добавление номеров из CRM в обзвон. GET https&#x3A;//app.aimylogic.com/api/crmCalls/campaign/{token}/addPhone POST https&#x3A;//app.aimylogic.com/api/crmCalls/campaign/{token}/addPhone Отмена созданных заданий на обзвон. POST https&#x3A;//app.aimylogic.com/api/calls/campaign/{token}/callJob/cancel Приостановление, возобновление и остановка обзвона. POST https&#x3A;//app.aimylogic.com/api/calls/campaign/{token}/control/pause POST https&#x3A;//app.aimylogic.com/api/calls/campaign/{token}/control/resume POST https&#x3A;//app.aimylogic.com/api/calls/campaign/{token}/control/stop Получение информации об обзвоне. GET /api/calls/campaign/{token} GET /api/calls/campaign/{token}/status Получение отчетов по ID задания на обзвон или по номеру телефона.'
 'Calls API Платформа JAICP предоставляет Calls API для работы с исходящей телефонией. Перед началом работы с Calls API необходимо: Настроить телефонию. Подключить телефонный канал. Создать обзвон. Методы API API предоставляет методы для следующих операций: Добавление телефонных номеров с параметрами в обзвон. POST /api/calls/campaign/{token}/addPhones GET /api/crmCalls/campaign/{token}/addPhone POST /api/crmCalls/campaign/{token}/addPhone Отмена созданных заданий на обзвон. POST /api/calls/campaign/{token}/callJob/cancel Получение отчетов по ID задания на обзвон или по номеру телефона. POST /api/calls/campaign/{token}/callJob/getReport POST /api/calls/campaign/{token}/callAttempt/getReport Получение информации об обзвоне. GET /api/calls/campaign/{token} GET /api/calls/campaign/{token}/status Приостановление, возобновление и остановка обзвона. POST /api/calls/campaign/{token}/control/pause POST /api/calls/campaign/{token}/control/resume POST /api/calls/campaign/{token}/control/stop Подробное описание Calls API: методы, параметры запроса, форматы ответа, примеры, возвращаемые ошибки Параметры запросов Обязательные параметры В строки запросов к Calls API подставляются следующие обязательные параметры: host_name — имя хоста, на котором запущен обзвон. token — уникальный токен для управления обзвоном. Получить токен можно на вкладке Обзвоны, нажав на иконку рядом с названием обзвона либо на > Скопировать API-токен.'
 'Релиз Aimylogic 1.11.4 Новый интерфейс раздела Звонки. Блок Оплата в Telegram. Обновление раздела Диалоги. Новый интерфейс раздела Звонки Мы полностью переработали интерфейс телефонии. При создании сценария для звонков теперь вам нужно выбрать, для чего вы будете использовать бота — для обзвонов или для приема входящих звонков. Исходящая телефония В сценариях для исходящей телефонии вы можете создавать обзвоны по списку номеров или по триггеру из CRM. Для каждого обзвона теперь можно выбрать дни недели и временные интервалы, когда бот будет обзванивать клиентов. На странице обзвона отображается аналитика по статусам звонков и количество минут, потраченных на обзвон. Здесь же вы можете запустить, приостановить или завершить обзвон. Подробнее об исходящей телефонии Входящая телефония В каждом сценарии для входящей телефонии вы можете выбирать SIP-подключение, запускать и завершать прием входящих звонков. Подробнее о входящей телефонии Блок Оплата в Telegram В палитре блоков появился блок Оплата в Telegram, при помощи которого вы можете получать оплату от клиентов через встроенный сервис платежей. Сервис поддерживает интеграцию с различными платежными системами. В нужный момент бот отправит клиенту в чат форму на оплату. При настройке бота вы можете добавить описание товара, выбрать валюту и указать, может ли клиент пересылать ссылку на оплату другим пользователям Telegram.'
 'Подробнее о тарифах Aimylogic'
 'Звонки Aimylogic предоставляет возможность создавать сценарии не только для общения с клиентами в чате, но и для звонков. Aimylogic поддерживает следующие типы звонков: исходящие звонки, которые осуществляет бот; входящие звонки от клиентов, которые принимает бот; перевод на оператора исходящего или входящего звонка. Вы можете создавать и запускать обзвоны, которые бот будет совершать по загруженному списку номеров или по триггеру из CRM. После запуска обзвона вам будут доступны отчеты по обзвонам и информация о статусах звонков. При обработке звонков расходуются пакеты минут исходящей телефонии, а также минуты понимания и синтеза речи. Вы можете прочитать про расходование минут в статье о тарификации минут. Что есть в этом разделе Мы собрали самую важную информацию о звонках, которая поможет вам быстро разобраться и начать создавать собственные обзвоны и принимать звонки. Обзвоны — как создать и разметить сценарий для обзвона, как запустить обзвон, какие статусы могут быть у звонков и обзвонов и что есть в отчетах по обзвонам. Входящие звонки — как настроить и использовать входящие звонки в Aimylogic. Настройка собственной телефонии — как использовать отдельную телефонную инфраструктуру в Aimylogic. Как обрабатывать больше звонков — как происходит распределение серверов при работе со звонками в Aimylogic, какие есть ограничения и как подключить дополнительные телефонные сервера.'
 'Релиз Aimylogic 1.10.2 Разделение счетчиков телефонии Канал edna.chatCenter Обновленная интеграция с Битрикс24 Разделение счетчиков телефонии Не так давно мы добавили в Aimylogic опцию подключения сторонней телефонии. Это решение оказалось очень популярным, и мы решили немного изменить тарификацию телефонии. Теперь в Aimylogic есть два счетчика минут: минуты, которые тратятся на понимание и синтез речи минуты, которые тратятся на телефонное соединение Поэтому, если вы используете собственное SIP-подключение, то в Aimylogic вы будете оплачивать только понимание и синтез речи. Если у вас закончатся минуты на одном из счетчиков, вы можете купить дополнительный пакет минут, не дожидаясь конца месяца. Обратите внимание: теперь пакеты минут для исходящей телефонии нужно будет покупать отдельно Как работает тарификация, сколько минут входит в разные тарифы, и всю остальную информацию о тарифах вы можете получить здесь. Канал edna.chatCenter К списку каналов Aimylogic добавилась edna.chatCenter – платформа для организации продаж и поддержки клиентов в цифровых каналах. Инструкцию по подключению канала к вашим ботам вы можете найти здесь. Обновленная интеграция с Битрикс24 В интеграции с Битрикс24 появилась новая переменная $bitrix.params, которая предоставляет информацию о текущем диалоге. Подробнее об интеграции с Битрикс24 и переменных читайте по ссылке.'
 'Релиз Aimylogic 1.11.2 Блок Расписание. Готовые интенты для телефонных сценариев. Перевод на группу операторов в канале LiveTex. Как обрабатывать больше звонков. Паттерны ответов клиента. Блок Расписание Мы добавили блок Расписание, с помощью которого вы можете настроить поведение бота в зависимости от дня недели и времени суток на момент общения бота с клиентом. Подробнее о блоке Расписание Готовые интенты для телефонных сценариев Список готовых интентов пополнился группой интентов Телефония, которая доступна в сценариях для звонков. Вам доступно шесть новых интентов: Запрос на повторный звонок Запрос на повтор фразы Плохо слышно Согласие прослушать предложение Отказ прослушать предложение Согласие получить SMS Подробнее об интентах для телефонии Перевод на группу операторов в канале LiveTex Для операторского канала LiveTex мы добавили возможность переводить диалоги на определенную группу операторов. Подробнее о переводе диалогов на группу операторов в канале LiveTex Как обрабатывать больше звонков Мы написали статью, из которой вы узнаете: Сколько звонков вы можете осуществлять одновременно. Как распределяются телефонные сервера в зависимости от тарифа. Как подключить дополнительные сервера, чтобы обрабатывать больше звонков. Подробнее о том, как обрабатывать больше звонков Паттерны ответов клиента Мы добавили информацию о паттернах, которые характеризуют определенные поведенческие реакции человека.'
 'Телефония Телефония — инструмент платформы JAICP, позволяющий комплексно автоматизировать исходящие и входящие звонки. В ходе звонка бот ведет диалог с пользователем на естественном языке. Результат звонка фиксируется в виде распознанного решения пользователя: согласие или несогласие, подтверждение, просьба больше не звонить и др. В результате обзвона предоставляется аналитика с детализацией по результатам каждого звонка. Чтобы запустить обзвон: Настройте телефонию. Загрузите список номеров для обзвона. Настройте телефонный канал. Создайте и запустите обзвон. Сценарий В возможности JS API, предоставляемого JAICP, входит встроенный сервис $dialer. Ознакомьтесь с его описанием, чтобы узнать обо всех возможностях работы с телефонией из сценария. Также при разработке учитывайте такие особенности, как: Обработка нераспознанной речи. Обработка тонального набора. Разметка речевого синтеза. Прерывание реплик бота. Обработка неудачного звонка. Перевод на оператора в телефонном канале. Воспроизведение аудио вместо синтеза реплик бота. Calls API Платформа JAICP предоставляет Calls API для работы с исходящей телефонией. API предоставляет возможность: Добавить телефонные номера с параметрами в обзвон. Отменять созданные задания на обзвон. Получать отчеты по ID задания на обзвон или по номеру телефона. Запускать, приостанавливать, возобновлять и останавливать обзвон.'
 'Релиз Aimylogic 1.10.9 Новый интерфейс разделов Чат-боты и Звонки. HTML-разметка в текстовых сообщениях бота. Поддержка анимированных изображений. Тестирование звонков из сценария. Смена текущего email аккаунта. Новый тариф Business Jivo. Снятие ограничения на использование канала i‑Digital: WhatsApp. Новый бизнес-кейс Умный IVR. В релизе 1.10.9 мы переработали интерфейс разделов Чат-боты и Звонки. Вы сможете сами выбрать наиболее удобное отображение проектов для вас: карточками или списком. Здесь вы также сможете отфильтровать только нужные сценарии с помощью тегов и отсортировать их по фильтрам. В текстовых сценариях мы реализовали возможность применить HTML-разметку к сообщениям бота, а также отправлять клиентам анимированные изображения. В сценариях для обзвона появилась возможность протестировать сценарий прежде, чем запустить обзвон по реальным клиентским номерам. В настройках аккаунта мы добавили возможность сменить электронную почту, поэтому вам больше не придется обращаться для этого в техподдержку. Помимо прочего, изменения коснулись тарифов нашей платформы. Мы добавили тариф Business Jivo для тех, кто использует только канал Jivo для коммуникации с клиентами. А также сняли ограничение на подключение канала i‑Digital: WhatsApp на других тарифах. Новый интерфейс В этом релизе мы обновили интерфейс разделов Чат-боты и Звонки.']"	"В тариф для звонков Aimylogic включены следующие услуги:

- Запуск обзвонов;
- Добавление номеров в базу;
- Получение отчетов по номерам телефона или задачам в обзвоне;
- Отмена созданных заданий на обзвон;
- Приостановление, возобновление и остановка обзвона;
- Получение информации об обзвоне;
- Получение отчетов по ID задания на обзвон или по номеру телефона.

Если вам нужна более подробная информация, обратитесь к документации по Calls API в Aimylogic."	['- Если вы хотите использовать собственное подключение телефонии, то у вас будут списываться только минуты распознавания и синтеза речи.\n- Если вы планируете использовать телефонию Aimylogic, то вам нужно приобрести дополнительный пакет минут, так как мы считаем: Время, которое было потрачено на распознавание и синтез речи. Время, которое было использовано на телефонные вызовы.\n- Неиспользованные минуты сгорают в конце расчетного периода.\n- Если вы находитесь на тарифе для звонков, но при этом хотите опубликовать чат-бота, вам нужно приобрести дополнительные пакеты с уникальными пользователями.\n- При этом вам станут доступны те же возможности, что и на тарифах для чат-ботов.\n- Вы также сможете подключить Aimychat в качестве операторского канала.\n- В таком случае будут распространяться ограничения: 2 оператора и 1 группа операторов для тарифа Calls Startup; 30 операторов и 5 групп для остальных тарифов.\n- Ограничение на количество операторов и групп не зависит от объемов дополнительных пакетов.\n- Если у вас закончились уникальные пользователи или минуты распознавания и синтеза речи или если вы хотите пользоваться телефонией Aimylogic для обзвонов, то вы можете купить дополнительные пакеты.\n- Дополнительные пакеты не сгорают в конце месяца.\n- На тариф Startup можно перейти, только если у вас подключен тариф Free.\n- Если вы переключаетесь с бесплатного тарифа на любой платный тариф или с платного тарифа на более дорогой платный тариф, вы будете переведены на новый тариф мгновенно.\n- Если вы переключаетесь с платного тарифа на бесплатный тариф или на более дешевый платный тариф, вы будете переведены на новый тариф со следующего расчетного периода.\n- Если у вас закончились тарифные минуты или уникальные пользователи, вы можете докупить дополнительные пакеты или подключить более дорогой тариф.']	0.8986489593811767	0.5666666666525	0.875
Можно ли использовать собственное подключение телефонии и опубликовать чат-бота?	"['Как подключить канал Aimychat'
 'Как описать проблему в службу поддержки?'
 'Как добавить ChatGPT в бота из конструктора'
 'Настройка собственной телефонии Телефонная инфраструктура, которую предоставляет Aimylogic, позволяет вам совершать обзвоны, не прилагая дополнительных усилий: мы предоставим вам и телефонные номера, и достаточное количество телефонных линий. Но в некоторых случаях нужно использовать стороннее подключение. Оно может пригодиться если: вы хотите не только обзванивать клиентов, но и принимать входящие звонки; вы хотите использовать собственный телефонный номер; вы находитесь не в России, но хотите пользоваться Aimylogic для обзвонов; номер, который вы верифицировали для тестовых звонков, не является российским номером. В таких случаях вы можете использовать SIP-подключение стороннего провайдера. С помощью него вы сможете звонить клиентам, используя собственные телефонные номера или те, которые предоставляет провайдер вашей телефонии. SIP (Session Initiation Protocol) – это один из протоколов передачи данных, который используется для телефонных вызовов. Настроив SIP-подключение у выбранного вами провайдера, вы сможете использовать его не только в Aimylogic, но и во многих других сервисах. При этом вам не нужно выбирать, будете вы пользоваться только своей телефонией или только телефонией Aimylogic: вы можете в нужный момент переключаться между разными опциями и даже разными SIP-подключениями. Если вы используете собственное SIP-подключение, то, при переводе звонка на оператора, тарификация приостанавливается. После возвращения диалога на бота тарификация возобновится.'
 'ВКонтакте Социальная сеть ВКонтакте уже давно позволяет владельцам сообществ общаться с подписчиками через сообщения сообществ. Теперь вы можете подключить к процессу бота, который снимет с вас часть нагрузки и будет отвечать на вопросы за вас. Подключить бота, созданного в конструкторе Aimylogic, к каналу ВКонтакте несложно, но у этой социальной сети есть своя специфика. Поэтому, прежде чем приступить к настройке, внимательно прочитайте эту инструкцию. Как подключить бота к сообществу ВКонтакте Если вы включаете параметр ""сообщения сообщества"" в первый раз, обязательно примите дисклеймер ВКонтакте о правилах использования ботов. Выберите сообщество или группу ВКонтакте, где будет работать ваш бот Бот может отвечать только на сообщения сообщества / страницы ВКонтакте. Он не может отвечать на сообщения, которые люди пишут лично вам. Бот также не может обрабатывать сообщения в комментариях. Включите сообщения и возможности ботов Перейдите в ваше сообщество ВКонтакте. Перейдите в Управление → Настройки → Сообщения сообщества → Включены. И нажмите Сохранить. В поле Приветствие вы можете поместить приветствие или инструкцию по взаимодействию с ботом. Пользователь увидит этот текст, когда нажмёт на кнопку ""Написать сообщение"". Также этот текст может быть отправлен пользователю, если доступ к боту был совершен по ссылке на диалог. Либо, если пользователь нажал Написать сообщение, а затем Перейти к диалогу с сообществом.'
 'Использование бота как оператора Для канала Chat2Desk вы можете использовать бота как оператора. Далее мы рассмотрим, как создать и подключить такого бота, а также его алгоритм работы с обращениями клиентов. Подключение бота как оператора Авторизуйтесь в сервисе Chat2Desk. На панели управления нажмите Настройки → Операторы. Здесь создайте оператора, которого далее планируется назначить ботом. Далее перейдите Операторы → Группы операторов. Здесь создайте группу операторов и добавьте в неё ранее созданного бота. Затем на панели управления нажмите Настройки → Общие. Здесь отключите параметр Назначать на последнего оператора данного чата, если он онлайн. Сценарий работы Сценарий работы канала Chat2Desk при подключении бота как оператора: Бот-оператор подключается к диалогу, если на него был переведен чат оператором, а также если клиент вводит определенную команду меню самообслуживания или при помощи макросов. Меню самообслуживания – это набор команд, отправив которые, клиент перейдет в подменю или сразу получит заданные вами ответы. С помощью меню клиент может получить нужную информацию без участия оператора. Для настройки меню самообслуживания авторизуйтесь в сервисе Chat2Desk. Далее на панели управления нажмите Настройки → Меню самообслуживания. В пункте меню укажите бота, как оператора, на которого будет переведён чат.'
 'ВКонтакте как входящий канал Для использования ВКонтакте как входящего канала: Настройте доступ. Создайте канал. Протестируйте бота. Настройка доступа Для подключения чат-бота вы можете использовать любое свое сообщество — группу, встречу или публичную страницу. Укажите, что в сообществе будет работать бот. Для этого перейдите Управление сообществом → Сообщения → Настройки для бота. Включите пункт Возможности ботов. Далее включите сообщения в сообществе Управление сообществом → Сообщения. Чтобы пользователи могли добавлять бота в беседы, необходимо включить эту возможность в настройках. Перейдите Управление сообществом → Сообщения → Настройки для бота и поставьте галочку в пункте Разрешать добавлять сообщество в беседы. После этого в сообществе появится кнопка Пригласить в беседу, открывающая модальное окно со списком бесед. Получение ключа доступа Откройте раздел Управление сообществом (Управление станцией, если публичная страница) → вкладка Работа с API → Создать ключ доступа. Отметьте необходимые права доступа и подтвердите выбор. Не размещайте ключи в публичном доступе! Если ключ был скомпрометирован, удалите его из списка — после этого он станет недействителен. Создание канала Нажмите на панели управления Каналы → Входящие → Подключить канал. В разделе Мессенджеры и соцсети выберите ВКонтакте. Заполните поля: Название — укажите название для канала или оставьте по умолчанию. Токен — введите готовый ключ доступа.'
 'Преимущество такого способа в том, что вы сможете подключить каналы и CRM-системы, доступные на стороне бизнес-канала, хранить в бизнес-канале не только диалоги операторов с клиентами, но и диалоги бота, а также использовать другие инструменты, доступные в бизнес-канале. При составлении сценария бота вам необходимо учитывать ограничения платформы, через которую будет общаться бот. Такой способ взаимодействия доступен со следующими платформами онлайн-чатов: Битрикс24 edna.chatCenter Jivo LiveTex (как бизнес-канал) Webim (External Bot API 2.0) Через чат-виджет платформы Бот может общаться с клиентами в чат-виджете платформы онлайн-чатов. Чтобы бот общался с клиентами в стороннем чат-виджете: Создайте сценарий бота. Подключите и настройте бизнес-канал. Добавьте в сценарий блок Перевод на оператора. Настройте чат-виджет платформы и разместите его на вашем сайте. Бот будет общаться с клиентами в чат-виджете бизнес-канала. Все диалоги бота с клиентами будут храниться и в рабочем месте оператора на платформе, и в логах бота в Aimylogic. Бот сможет при необходимости переводить диалоги на оператора, а оператор — обратно на бота, если такая возможность поддерживается платформой.'
 'Подробнее о создании чат-ботов' 'Подробнее о создании чат-ботов']"	Да, вы можете использовать собственное SIP-подключение телефонии и опубликовать чат-бота. С помощью SIP-подключения вы сможете звонить клиентам, используя собственные телефонные номера или те, которые предоставляет провайдер вашей телефонии. Вы также сможете переключаться между разными опциями и даже разными SIP-подключениями.	['- Если вы хотите использовать собственное подключение телефонии, то у вас будут списываться только минуты распознавания и синтеза речи.\n- Если вы планируете использовать телефонию Aimylogic, то вам нужно приобрести дополнительный пакет минут, так как мы считаем: Время, которое было потрачено на распознавание и синтез речи. Время, которое было использовано на телефонные вызовы.\n- Если вы находитесь на тарифе для звонков, но при этом хотите опубликовать чат-бота, вам нужно приобрести дополнительные пакеты с уникальными пользователями.\n- При этом вам станут доступны те же возможности, что и на тарифах для чат-ботов.\n- Вы также сможете подключить Aimychat в качестве операторского канала.\n- Если у вас закончились уникальные пользователи или минуты распознавания и синтеза речи или если вы хотите пользоваться телефонией Aimylogic для обзвонов, то вы можете купить дополнительные пакеты.\n- Дополнительные пакеты не сгорают в конце месяца.\n- Если у вас закончились тарифные минуты или уникальные пользователи, вы можете докупить дополнительные пакеты или подключить более дорогой тариф.']	0.9734087108164674	0.3194444444337962	0.8
Какой метод используется для записи данных в таблицу Google, если предыдущие данные в непустых ячейках будут перезаписаны?	"['$integration.googleSheets.writeDataToCells Метод используется для записи данных в ячейки таблицы Google. Синтаксис Метод принимает 4 обязательных аргумента. Объекты, передаваемые в массиве values, в свою очередь должны иметь следующие поля: Пример вызова метода: Действие Метод записывает переданные значения в соответствующие ячейки на нужном листе. Если для записи в ячейку передается несколько значений, второе и последующие значения записываются в столбцы, следующие за нужной ячейкой. В отличие от googleSheets.writeDataToLine, при использовании данного метода для записи данных в непустые ячейки предыдущие данные будут перезаписаны. Пример Рассмотрим пример использования метода для обновления базы клиентов.'
 '$integration.googleSheets.writeDataToLine Метод используется для записи данных в строку таблицы Google. Синтаксис Метод принимает 4 обязательных аргумента. Пример вызова метода: Действие Метод записывает значения, переданные в values, в начало первой строки нужного листа, в которой необходимое число ячеек свободно. Таким образом, метод не перезаписывает данные, уже содержащиеся в таблице, а дозаписывает новые данные к существующим. Пример Рассмотрим пример использования метода для добавления нового клиента в базу.'
 'В данном случае это отправка данных клиента в Google Таблицу. Нажмите Then That. Наберите в поиске sheets и выберите Google Sheets. Нажмите Add row to spreadsheet. Зайдите на свой Google Диск и создайте в его корне папку My folder или любую другую. В этой папке создайте таблицу с названием NewSpreadsheet. Вернитесь на вкладку с IFTTT. Сейчас у вас открыта страница настройки сервиса Google Таблиц. Удалите содержимое поля Spreadsheet name и укажите в нем название созданной таблицы. В данном случае напишите NewSpreadsheet. Если вы дали своей таблице другое название, то напишите его. Поле Formatted row можно оставить без изменений. Оно содержит следующие параметры: OccuredAt — дата и время добавления строки в таблицу. Если вы не хотите отправлять дату и время срабатывания события в таблицу, удалите этот параметр. EventName — название события, которое вы создали ранее. В одну таблицу можно записывать данные с помощью разных событий. Если вы не хотите записывать в таблицу название события, удалите этот параметр. Value1, Value2, Value3 — переменные, полученные ботом от пользователя в ходе диалога. Наличие хотя бы одной переменной в данном поле является обязательным. IFTTT позволяет отправлять не более трех переменных. Если нужно отправлять большее количество переменных, вы можете воспользоваться каким-либо платным аналогом сервиса IFTTT, например, Zapier. Удалите содержимое поля Drive folder path. Вместо него напишите название папки, в которой находится таблица.'
 'writeDataToLine Действие writeDataToLine сохраняет данные в начало первой строки с необходимым количеством свободных ячеек. Уже существующие в таблице данные не перезаписываются — к ним добавляются новые. В параметре body передайте объект с полем values. Оно должно содержать массив значений для записи в строку, например: Для таблицы ниже данные из примера будут добавлены в шестую строку, поскольку в четвертой и пятой строках не хватает свободных ячеек. Пример таблицы deleteRowOrColumn Действие deleteRowOrColumn удаляет из таблицы строку, столбец или диапазон ячеек. При удалении строки данные смещаются вверх, а при удалении столбца — влево. В параметре body передайте объект с полем values. Оно должно содержать массив диапазонов ячеек, которые нужно удалить: clearCellData Действие clearCellData удаляет содержимое отдельных ячеек или их диапазона. Строки и столбцы таблицы при этом не смещаются. В параметре body передайте объект с полем values. Оно должно содержать массив диапазонов ячеек, которые нужно очистить: Использование в сценарии Получение данных из таблицы. Удаление данных из таблицы.'
 'В данном случае это отправка данных клиента в Google Таблицу. Нажмите Then That. Наберите в поиске sheets и выберите Google Sheets. Нажмите Update cell in spreadsheet. Зайдите на свой Google Диск и создайте в его корне папку My folder или любую другую. В этой папке создайте таблицу с названием NewSpreadsheet. Вернитесь на вкладку с IFTTT. Сейчас у вас открыта страница настройки сервиса Google Таблиц. Удалите содержимое поля Drive folder path. Вместо него укажите название папки, в которой находится таблица. В данном случае напишите My folder. Если вы оставите поле Drive folder path пустым, IFTTT создаст на вашем Google Диске папку с названием IFTTT и поместит таблицу туда. Сервис IFTTT не может поместить таблицу в корень диска. Поэтому лучше укажите папку самостоятельно, чтобы было проще найти таблицу. Удалите содержимое поля Spreadsheet name и укажите в нем название созданной таблицы. В данном случае напишите NewSpreadsheet. Если вы дали своей таблице другое название, то напишите его. В поле Which cell? укажите название ячейки, в которую хотите записывать данные. Указывайте только одну ячейку. Если вы укажете несколько ячеек, событие не будет работать. В поле Value добавьте значения, которые вы хотите отправлять в ячейку. Нажмите Add ingredient под полем Value и добавьте значение. Обязательно добавьте переменные: Value1, Value2 и Value3. Если вы хотите, чтобы IFTTT добавлял в ячейку название события, дополнительно добавьте EventName.'
 '$caila.setClientEntityRecords Перезаписывает все записи сущности для определенного клиента. Синтаксис Метод принимает в качестве аргумента название сущности, записи которой будут переопределены, а также параметры обновленных записей: Использование в сценарии Переопределение текущих записей сущности:'
 'Лист таблицы Действие Получить значение Сохранить в ячейку Сохранить в строку Удалить строку/столбец Очистить ячейки Список параметров для записи Введите номера ячеек или значения, которые хотите передать в таблицу Google. Методы Google Таблицы ограничивают количество запросов к API в минуту. Подробнее об ограничениях Получить значение Метод позволяет выбрать ячейку из таблицы и получить ее текущее значение. В поле Из ячейки укажите номер ячейки, а в Значение или переменная — переменную, в которую будут сохранены данные из нее. Эту переменную можно будет использовать в других блоках сценария. Рассмотрим пример использования метода для получения имени и отчества из базы клиентов. Сохранить в ячейку Метод позволяет выбрать ячейку в таблице и сохранить в нее значение. Номер ячейки и передаваемое значение можно указывать как явно, так и с помощью переменной. Вместо значения можно записать массив данных. В таком случае данные будут записаны в отдельные ячейки, следующие за указанной ячейкой. Если вы сохраните данные в заполненную ячейку, то ее содержимое будет перезаписано. Рассмотрим пример использования метода для обновления базы клиентов. Сохранить в строку Метод добавляет произвольные значения в начало первой строки, в которой необходимое число ячеек свободно. Метод не перезаписывает уже существующие данные в таблице, а добавляет новые к ним. В приведенном видеопримере мы добавляем нового клиента в таблицу.'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get; в URL используйте ссылку, которую получили шагом выше. на вкладке RESPONSE напишите название переменной:userи значение:\\_.findWhere($httpResponse, {login: $entry}) вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный логин или нет. Он только делает запрос к URL. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел логин неверно. Поэтому мы будем проверять логин на следующих шагах. А сейчас же мы просто запрашиваем всю информацию из Google Таблиц. Также, http-запрос ищет в Google Таблицах введенный вами логин с помощью \\_.findWhere($httpResponse, {login: $loginentry}). Если логин присутствует в таблице, он помещает его в переменную $user. Но успешное завершение запроса вовсе не означает, что логин действительно был в таблице. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите:Ошибка чтения логина $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи. От варианта Завершен успешно сделайте связь с блоком Условие и напишите в него:$user Это условие будет проверять, записалось ли что-либо в переменную $user, то есть, был ли найден введенный пользователем логин.'
 'Вывод информации о мероприятии Вывод даты От варианта Завершен успешно запроса на экране «читаем когда» создайте новый экран с блоком Текст: Дата и время мероприятия: $event.when. Назовите экран «вывод даты». Здесь используется переменная $event, в которую позже будет записываться содержание таблицы. От варианта Завершен с ошибкой запроса «читаем когда» создайте новый экран с блоком Текст: Произошла ошибка чтения даты и времени: $httpStatus. Попробуйте позже! Назовите экран «ошибка чтения даты». На экране «задача» нажмите , чтобы скопировать блок Интенты. Вставьте этот блок интентов на экран «вывод даты». Экран «вывод даты» будет выглядеть так: Вывод места От варианта Завершен успешно запроса на экране «читаем где» создайте новый экран с блоком Текст: Место проведения мероприятия: $event.where. Назовите этот экран «вывод места». Здесь также используется переменная $event, в которую позже будет записываться содержание таблицы. От варианта Завершен с ошибкой запроса на экране «читаем где» создайте новый экран с блоком Текст: Произошла ошибка чтения местоположения: $httpStatus. Попробуйте позже! Назовите этот экран «ошибка чтения места». Еще раз скопируйте интенты с экрана «задача» и вставьте на экран «вывод места». Экран «вывод места» будет выглядеть так: Добавление связей На экраны «ошибка чтения даты» и «ошибка чтения места» добавьте блоки Переход. Свяжите оба блока Переход с экраном «задача».'
 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get в url используйте ссылку, которую получили шагом выше на вкладке RESPONSE напишите название переменной: check и значение: \\_.findWhere($httpResponse, {""number"": 1}) где 1 - число, соответствующее порядковому номеру кода для соответствующего задания. В этом месте сценария, например, мы будем принимать за правильный ответ код 4444, который стоит в строке 1: Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный ли код. Он только делает запрос к url. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел код неверно. Поэтому мы будем проверять код на следующих шагах. Сам факт успешного завершения http-запроса не говорит о том, что введенный код был верным. Также, http-запрос получает информацию из соответствующей строки с помощью \\_.findWhere($httpResponse, {""number"": 1}) и записывает все, что есть в строке, которая соответствует номеру ""1"" в переменную $check. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите: Ошибка чтения кода $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи.']"	Метод $integration.googleSheets.writeDataToCells используется для записи данных в таблицу Google, при этом предыдущие данные в непустых ячейках будут перезаписаны.	['- Метод используется для записи данных в ячейки таблицы Google.\n- Если для записи в ячейку передается несколько значений, второе и последующие значения записываются в столбцы, следующие за нужной ячейкой.\n- В отличие от googleSheets.writeDataToLine, при использовании данного метода для записи данных в непустые ячейки предыдущие данные будут перезаписаны.']	0.9348697780222966	0.609523809503492	1.0
