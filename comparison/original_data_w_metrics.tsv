question	ground_truths	contexts	answers	faithfulness	answer_relevancy	context_precision
как настроить кайлу в проекте?	"[""'Чтобы создать новый проект CAILA и настроить его:  1) Создайте проект любым удобным вам способом. 2) Нажмите в карточке проекта → Настройки проекта. 3) Заполните поля на вкладке Классификатор: - выберите алгоритм классификации - настройте исправление орфографии - настройте поиск совпадений - укажите часовой пояс 4) Для использования CAILA в сторонних приложениях сохраните API ключ 5) Настройки NLU вы можете задать параметры в виде JSON-объекта, чтобы настроить NLU, а также подключить внешний NLU-сервис к вашему проекту'""]"	"['Как подключить канал Aimychat', 'Как добавить ChatGPT в бота из конструктора', 'В качестве Платформы выберите Скилл Маруси. Заполните Название. Оно будет использоваться для активации скилла. В поле Webhook URL вставьте вебхук, который вы скопировали при создании канала в JAICP. Нажмите Создать скилл. После модерации навык станет доступен для всех пользователей Маруси. Ознакомьтесь с дополнительной информацией о публикации скилла в документации ВКонтакте. Сервисный ключ доступа Для корректной отправки изображений необходимо настроить сервисный ключ доступа. В разделе для разработчиков ВКонтакте напротив созданного скилла нажмите Редактировать. Перейдите в раздел Настройки → Общая информация о скилле. В строке Сервисный ключ доступа нажмите . Скопируйте ключ. Перейдите в настройки канала Маруся на стороне JAICP. В поле Сервисный ключ доступа вставьте скопированный ключ. Нажмите Сохранить. Теперь ваш бот сможет отсылать изображения, предусмотренные в сценарии. Тестирование Вы можете протестировать сценарий бота на устройстве с голосовым помощником Маруся. Для этого вызовите навык активационной фразой.', 'Настройка проекта CAILA — NLU-ядро для разработки на базе JAICP разговорных ботов и ассистентов, понимающих естественный язык. Чтобы создать новый проект CAILA и настроить его: Создайте проект любым удобным вам способом. Нажмите в карточке проекта → Настройки проекта. Заполните поля на вкладке Классификатор: Алгоритм классификатора — выберите алгоритм классификатора: STS (Semantic Textual Similarity) — алгоритм, который сравнивает семантическую близость слов. Он учитывает инверсию, словарные формы слов, их синонимы и другую информацию. Рекомендуется использовать при обучении бота на незначительном наборе данных: 5–7 тренировочных фраз на интент, но не более 1 000 фраз во всей выборке. Classic ML — стандартный алгоритм машинного обучения для распознавания интентов на основе логистической регрессии. Он классифицирует данные по исходным словам, словарным формам и основам слов без учета семантической информации. Рекомендуется использовать при выборке объемом не менее 20 тренировочных фраз на интент. Deep Learning — алгоритм на основе сверточных нейронных сетей. Учитывает семантику слов при формировании гипотез. Рекомендуется использовать при значительном наборе данных: не менее 50 тренировочных фраз на интент. Transformer — мультиязычный алгоритм. Он оценивает семантическое сходство запроса клиента со всеми тренировочными фразами из интента. Рекомендуется использовать при выборке объемом не менее 10 тренировочных фраз на интент.', 'С чего начать Если вы только начинаете разработку своего первого сценария в J‑Graph, вот несколько советов: Для начала создайте на холсте несколько шагов — состояний, на основе которых будет строиться логика работы вашего бота. Наполните шаги блоками — «кирпичиками», описывающими поведение пользователя и бота в контексте шагов. Добавьте фразы клиента и события, чтобы соединить шаги связями, по которым диалог сможет переходить из одного шага в другой. Продолжайте расширять сценарий, объединяя связанные друг с другом шаги в группы, — или усложняйте его логику, например, воспользовавшись действиями. Пройдите пошаговый сценарий простого бота, чтобы начать разбираться с J‑Graph на практике.', 'Добавьте приложение наше в Битрикс24 Перейдите в личный кабинет Битрикс24. В боковом меню выберите Еще → Маркет. В списке приложений найдите и установите приложение Aimylogic. В процессе установки вам нужно будет авторизоваться в вашем аккаунте Aimylogic. После того как приложение будет установлено, в списке ваших чат-ботов Aimylogic появится шаблонный чат-бот Сбор информации о доставке. Шаблон будет сразу доступен в чатах и для Открытых линий Битрикс24. Опубликуйте сценарий в канал Битрикс24 Перейдите в Aimylogic. В проекте бота, которого вы хотите добавить в Битрикс24, перейдите на вкладку Каналы. Выберите из списка канал Битрикс24 и Открытые линии. В открывшемся окне настройте параметры: Имя бота в Битрикс24 — укажите имя, которое будет отображаться в чатах с клиентами. Аватар бота — загрузите изображение для бота, которое будет отображаться в чатах с клиентами. Открытые линии — включите опцию, если хотите использовать бота в Открытых линиях Битрикс24. Добавлять бота только вручную — включите опцию, если хотите подключать бота вручную, а не использовать его для обработки всех входящих сообщений. В этом случае бота нельзя будет использовать на первой линии поддержки. Название канала — укажите название канала или оставьте название по умолчанию. Нажмите Сохранить и дождитесь публикации бота. После успешной публикации чат-бот будет доступен в вашем аккаунте Битрикс24.', 'Создание интента geo Теперь добавьте в поле Тестовые фразы фразу @mystem.geo, чтобы бот мог распознавать название городов. Подробнее о настройке интентов и слот-филлинга Приведение к начальной форме Заполненный слот будет храниться в поле $parseTree.\\_geo. Присвоим это значение переменной city. Клиент может ввести фразу как угодно, например, Москва или в Москве. Значение в $parseTree.\\_geo будет записано именно так, как и ввел его клиент, но для выполнения запроса к API нам необходимо, чтобы значение было приведено к нормальной форме. Для этого будем использовать функцию $caila.inflect, которая умеет склонять текст в любой падеж. Вызовем функцию с аргументом \\[""nomn""], чтобы названия городов были приведены к именительному падежу: Вызов функции API Перейдем к обработке запроса. Вызываем функцию openWeatherMapCurrent, которую мы создали ранее. Функция принимает 3 аргумента: ""metric"" — параметр, использующийся для вывода температуры в градусах Цельсия; ""ru"" — параметр, указывающий на язык вывода данных; city — переменная, в которой хранится название города. Выполним асинхронный HTTP-запрос. Функция openWeatherMapCurrent возвращает объект promise. Чтобы вывести результат, обрабатываем promise при помощи then(function (res) {}). Здесь res — переменная, содержащая ответ на запрос. Получение ответа Допустим, клиента интересует погода в Москве. Из сообщения будет извлечена сущность В Москве и приведена к начальной форме Москва с помощью $caila.inflect.', 'Разработка сценария Это часть серии статей, посвященной созданию бота с обращением к API сервиса OpenWeatherMap. Настройка конфигурационного файла Работа с HTTP-запросом к OpenWeatherMap API Разработка сценария (вы находитесь здесь) Тестирование На этом шаге мы напишем сценарий для бота, который будет присылать текущую погоду в запрашиваемом городе. Этапы работы сценария: Бот посылает приветственное сообщение и просит клиента ввести название города. Клиент вводит название города. Например, Москва или Какая сегодня погода в Москве. Посредством сущности город будет выделено название города, которое затем будет приведено к начальной форме. Выделенный город будет передан в качестве аргумента в функцию обращения к API-сервису, написанную на предыдущем шаге. API-сервис вернет ответ. Полученные данные будут использованы для вывода сообщения о текущей погоде с рекомендациями. Создание сценария Создайте файл main.sc в папке src. В нем будет сценарий работы бота: В начале сценария под тегом require подключаем дополнительный файл functions.js, который мы создали ранее в разделе HTTP-запрос. Сценарий работы бота состоит из следующих стейтов: Start — начало работы. Здесь бот приветствует клиента и сообщает, чем он будет полезен. GetWeather — вывод информации о текущей погоде в запрашиваемом городе. CatchAll — стейт, предусмотренный для случаев, когда сообщение клиента не подходит ни под один описанный стейт. Структура сценария Приветствие В стейте Start запускается сценарий.', 'Конфигурационный файл chatbot.yaml chatbot.yaml — конфигурационный файл чат-бота. Файл содержит основную информацию о конфигурации проекта, например: имя главного файла сценария; данные о подключаемых зависимостях; конфигурацию NLU; перечень файлов с тестами. В данном разделе перечислены настройки, которые можно задать в chatbot.yaml, и их назначение. Подробнее о синтаксисе YAML Точка входа в сценарий Поле используется для указания файла, с которого начинается загрузка сценария чат-бота при публикации. Файл должен находиться в папке src и обычно называется main.sc или entryPoint.sc. Если код сценария состоит из нескольких файлов, все необходимые файлы должны быть прямо или опосредованно импортированы в основной файл. Для этого используйте тег require. entryPoint — обязательное поле. Имя бота Поле задает имя бота, которое будет использовано, например, в сообщениях о публикации бота в канал. Если поле отсутствует, в качестве имени используется системное название проекта. Настройки NLU Диалоговый движок Поле задает версию диалогового движка бота. Движок второй версии v2 позволяет использовать для понимания естественного языка (NLU) сервис CAILA. Это рекомендуемое значение поля для всех новых проектов. Если поле отсутствует или значение поля отличается от v2, будет использован движок первой версии v1. NLU на этом движке возможен только при помощи паттернов. Язык бота Поле задает язык, на котором общается бот. Значение поля должно быть ISO-кодом нужного языка.', 'Правила активации Для определения намерения клиента вы можете использовать в качестве правил активации стейтов паттерны и интенты CAILA. При совместном использовании в одном сценарии нескольких типов правил активации они срабатывают в порядке убывания приоритета: сначала паттерны, затем интенты. Порядок активации правил Следующая таблица иллюстрирует порядок срабатывания правил активации в различных вариантах их совместного использования: Таким образом, если на запрос клиента сработал паттерн, то произойдет переход в стейт с паттерном, даже если интент сработал бы с большим весом. Обработка нераспознанных запросов В проектах с несколькими типами правил активации не используйте паттерн \\* для обработки нераспознанных запросов: В такой стейт будут попадать все запросы, не распознанные при помощи других паттернов. При этом интенты будут игнорироваться, поскольку приоритет у паттерна будет выше. Для не предусмотренных сценарием запросов клиента используйте событие noMatch: Пример сценария Предположим, что в CAILA заданы интенты /паттерн и /интент, обученные на тренировочных фразах паттерн и интент соответственно. Рассмотрим следующий сценарий: Запустим тестовый виджет и проверим, в какие стейты попадут следующие запросы: Продвинутые возможности Если стандартный приоритет правил активации не подходит для вашего сценария, определите собственную логику для обработки результатов классификации: Чтобы изменить механизм выбора правил активации, используйте обработчик selectNLUResult.']"	"Для настройки CAILA в проекте вам необходимо выполнить следующие шаги:

1. Создайте проект CAILA и настройте его в соответствии с вашими потребностями. Для этого перейдите в карточку проекта и нажмите на вкладку ""Настройки проекта"". Заполните поля на вкладке ""Классификатор"" в соответствии с выбранным алгоритмом классификатора.

2. Укажите алгоритм классификатора, который будет использоваться для обучения бота. В поле ""Алгоритм классификатора"" выберите один из предложенных вариантов: STS (Semantic Textual Similarity), Classic ML, Deep Learning или Transformer. Каждый из этих алгоритмов имеет свои особенности и рекомендации по использованию.

3. Обучите бота на наборе тренировочных фраз, который соответствует выбранному алгоритму. Рекомендуется использовать определенное количество тренировочных фраз на интент, чтобы достичь наилучших результатов.

4. После настройки и обучения проекта CAILA вы можете использовать его в своем сценарии для понимания естественного языка и распознавания интентов клиентов.

Подробная информация о настройке проекта CAILA и его использовании приведена в документации JAICP."	0.5454545454545454	0.9025179807330931	0.14285714284285714
При использовании $caila в сценарии тратятся лимиты акка по запросам в caila api?	"['\'Да. При обращении к сервису классификации CAILA через сервис $caila расходуются запросы CAILA API. Из документации:  Лимит ""Запросы к CAILA API"" ограничивает количество запросов к сервису классификации CAILA при обращении через API, а также при обращении через сервис $caila.\'']"	['Обработка переполнения $session и $client в сценарии Существует ограничение на объем хранящихся данных в объектах $session и $client. При превышении лимита текущий сценарий прерывается, бот перестает отвечать клиенту. $client — объект для сохранения постоянных данных о клиенте. $session — объект для сохранения сессионных данных. Для того, чтобы сценарий не прерывался, необходимо обрабатывать переполнение данных объектов $session и $client в сценарии. Лимиты По умолчанию установлены лимиты: soft 100 Кб; hard 1000 Кб. Обратите внимание, что лимиты установлены для каждого объекта. Таким образом для данных объекта $client по soft лимиту доступно 100 Кб, для данных объекта $session также доступно 100 Кб. Обработка переполнения Если достигнут soft лимит, но при этом не превышен hard лимит, данные в объекты $session и $client будут сохраняться. При этом в сценарий приходят события о достижении soft лимита event: sessionDataSoftLimitExceeded и event: clientDataSoftLimitExceeded. Если новые данные превышают hard лимит, то эти данные не сохраняются в объекты $session и $client. При этом в сценарий приходят события о достижении hard лимита event: sessionDataHardLimitExceeded и event: clientDataHardLimitExceeded. Пример обработки переполнения данных в сценарии:', 'На второй версии диалогового движка поле является обязательным. Пороговые значения классификатора Поля phrases и patterns в секции nlp.intentNoMatchThresholds задают пороговые значения для классификатора интентов CAILA и его гипотез. Гипотеза — это результат работы классификатора. Во время формирования гипотезы классификатор определяет, насколько запрос пользователя соответствует тому или иному интенту. Так классификатор выражает степень своей уверенности в том, что этот интент действительно содержит фразу или паттерн из запроса пользователя. Рассмотрим поведение классификатора интентов: Пользователь отправляет запрос боту. При формировании гипотез классификатор сравнивает запрос с паттернами и тренировочными фразами по отдельности. Он вычисляет вероятность для каждой из гипотез. Если вероятность гипотезы меньше, чем порог у phrases или patterns, эта гипотеза не учитывается при дальнейшей обработке запроса и определении стейта в сценарии. Таким образом, intentNoMatchThresholds задает минимальную похожесть запроса на фразы или паттерны. Чем ближе значение к 1, тем строже классификатор и тем более точные требуются совпадения. Значение phrases и patterns по умолчанию — 0.2. Это значение используется, если не задать другое для любого из полей. В старых проектах вместо nlp использовалась секция caila. Она содержит поле noMatchThreshold, которое задает общее пороговое значение и для фраз, и для паттернов.', 'Когда лимиты будут исчерпаны, бот будет отвечать только на те вопросы, которые вы сами добавили в навык или в базу знаний. Если вы создали бота в редакторе навыков или не задали ответ при исчерпании лимитов в конструкторе, на неизвестный вопрос бот ответит Извините, непонятно. Чтобы пополнить лимиты, вы сможете приобрести дополнительные пакеты обращений.', 'Настройка конфигурационного файла Создайте конфигурационный файл бота chatbot.yaml и укажите следующие параметры: В этом туториале мы будем использовать процесс дозапроса информации слот-филлинг, поэтому настроим параметры его прерывания: maxSlotRetries — количество попыток для одного слота. Если клиент ответил указанное количество раз, и слот не был заполнен, процесс слот-филлинга будет прерван. Последняя фраза клиента будет обработана в сценарии бота. Установим две попытки. В дальнейшем, когда будем настраивать заполнение слотов, именно столько фраз будет использовано в поле Вопросы. stopOnAnyIntent — параметр прерывания процесса слот-филлинга по интенту. Если stopOnAnyIntent: true, то интент будет прерван тогда, когда пользователь захочет обработать другой интент. В нашем сценарии не предусмотрены случаи, когда нужно прервать интент со слот-филлингом по другому интенту. Поэтому установим stopOnAnyIntent: false. stopOnAnyIntentThreshold — параметр соответствия, задающий минимально необходимую похожесть фразы на один из классов. Является параметром прерывания процесса слот-филлинга по интенту. В ходе разработки NLU-сервиса было эмпирически определено, что оптимальное значение этого параметра 0.2. Теперь перейдем к разработке сценария бота.', 'В этом случае лимит минут Just AI не используется. Оптимизация Разметка логов Переименованы методы выделения ключевых слов при разметке логов. Теперь названия не привязаны к инструментам, а отражают методику. Заменены: TF/IDF на частотный; UDPipe на синтаксический. Исправлено', 'Правила активации Для определения намерения клиента вы можете использовать в качестве правил активации стейтов паттерны и интенты CAILA. При совместном использовании в одном сценарии нескольких типов правил активации они срабатывают в порядке убывания приоритета: сначала паттерны, затем интенты. Порядок активации правил Следующая таблица иллюстрирует порядок срабатывания правил активации в различных вариантах их совместного использования: Таким образом, если на запрос клиента сработал паттерн, то произойдет переход в стейт с паттерном, даже если интент сработал бы с большим весом. Обработка нераспознанных запросов В проектах с несколькими типами правил активации не используйте паттерн \\* для обработки нераспознанных запросов: В такой стейт будут попадать все запросы, не распознанные при помощи других паттернов. При этом интенты будут игнорироваться, поскольку приоритет у паттерна будет выше. Для не предусмотренных сценарием запросов клиента используйте событие noMatch: Пример сценария Предположим, что в CAILA заданы интенты /паттерн и /интент, обученные на тренировочных фразах паттерн и интент соответственно. Рассмотрим следующий сценарий: Запустим тестовый виджет и проверим, в какие стейты попадут следующие запросы: Продвинутые возможности Если стандартный приоритет правил активации не подходит для вашего сценария, определите собственную логику для обработки результатов классификации: Чтобы изменить механизм выбора правил активации, используйте обработчик selectNLUResult.', 'Обновления JAICP в декабре 2022 Разный порог активации для фраз и паттернов CAILA. Новые форматы ответов на вопросы из FAQ. Встроенный сервис $faq. Экспорт сценария из J‑Graph в PNG. Обновленная документация к тегам действий (специальным тегам). Разный порог активации для фраз и паттернов CAILA Раньше в конфигурационном файле chatbot.yaml часто использовалось поле caila.noMatchThreshold, которое задает общее пороговое значение и для тренировочных фраз, и для паттернов при работе с классификатором CAILA. Теперь вместо этого вы можете задавать разные пороговые значения для тренировочных фраз и паттернов. Для этого воспользуйтесь параметром nlp.intentNoMatchThresholds. Этот параметр содержит поля phrases и patterns со значениями по умолчанию 0.2. Подробнее о пороге активации для тренировочных фраз и паттернов Новые форматы ответов на вопросы из FAQ Теперь на вопросы из базы знаний можно отвечать не только в текстовом формате: загружайте изображения, аудиозаписи и файлы. К ответу на вопрос можно прикреплять сообщения, которые бот отправит пользователю по порядку. Подробнее о новом формате ответов на вопросы из FAQ Встроенный сервис $faq Встроенный сервис $faq упростит взаимодействие с FAQ. Теперь вы можете: Получать все сообщения из ответа на вопрос в формате JSON с помощью метода getReplies. Получать и сразу отправлять пользователю эти сообщения, используя метод pushReplies.', 'timeout — максимальное время обработки запроса в миллисекундах. По умолчанию ограничение включено со значением таймаута 10000 (10 секунд). Если запрос превысит ограничение, в сценарии возникнет событие timeLimit. XML-тесты XML-тесты сценариев позволяют проверить логику чат-бота, эмулируя запросы клиента и проверяя ответы от бота. По умолчанию выполняются все тесты из файлов в папке проекта test. Это поведение можно переопределить в секции tests, задав значения для подсекций include и/или exclude: include — будут выполнены тесты только из тех файлов, которые попадают под шаблоны, перечисленные в этой подсекции. exclude — из выполнения будут исключены все файлы, которые попадают под шаблоны, перечисленные в этой подсекции. Шаблоны используют синтаксис Apache Ant. Поле caseSensitive определяет, должны ли шаблоны учитывать регистр названий файлов. Значение по умолчанию — true. Зависимости Секция dependencies позволяет задать список зависимостей проекта. Подробнее о зависимостях Теги действий Секция customTags задает список самостоятельно созданных тегов действий, которые используются в проекте. Пользовательские реакции Секция customBlocks задает список пользовательских реакций, которые используются в рассылках. Сообщения об ошибках Секция messages.onError позволяет задать текст сообщения, которое бот отправит при возникновении какой-либо ошибки. В подсекции locales могут быть заданы тексты сообщений, локализованные исходя из данных о пользователе.', '$imputer.cacheAudio Метод $imputer.cacheAudio позволяет кэшировать реплику на сервере: на один час или навсегда. Вызов этого метода может потребоваться, чтобы избежать задержек — пауз во время диалога бота с абонентом. Реплику нужно кэшировать заранее — перед ее использованием в сценарии. Предусмотрите стейт в вашем сценарии, где это можно сделать. Синтаксис Метод $imputer.cacheAudio принимает аргументы: Если вы хотите, чтобы реплика была кэширована, аргументы replicaTemplateId, variables, voiceSpeed, переданные для метода $imputer.cacheAudio, должны совпадать с теми, что вы передаете для $imputer.generateAudioUrl. Примеры вызова Пример использования В этом примере реплики без переменных также были использованы в сценарии при помощи вызова метода $imputer.generateAudioUrl. Это было сделано, чтобы избежать разницы в звучании реплик: c переменными и без. Подробнее см. в разделе Гибридный синтез от Just AI.', 'Например, при общении в чат-виджете проставляется cookie, при помощи этих данных платформа отличает одного пользователя от другого. Если пользователь будет общаться с ботом в течение месяца и не очистит cookie, то он будет зачтен как один уникальный пользователь. Неиспользованный остаток дополнительного пакета уникальных пользователей переносится на следующий тарифный период. MLP-токены MLP-токены — единица тарификации обращений к ChatGPT из сценария. Они расходуются, когда бот отвечает с помощью LLM-модели. MLP-токены не равны токенам OpenAI. Количество потраченных MLP-токенов зависит от запроса. Когда лимит MLP-токенов будет достигнут, бот продолжит отвечать по сценарию и давать ответы из Базы знаний, но не сможет обращаться к ChatGPT. Чтобы пополнить лимиты, вы можете приобрести дополнительный пакет MLP-токенов или связаться с личным менеджером. NLU-минуты При совершении звонков расходуются NLU-минуты, услуги сервиса распознавания и генерации речи, а также услуги провайдера телефонии. NLU-минута — обработка запроса клиента и подготовка ответа бота в течение 1 минуты телефонного канала. Списание NLU-минут производится 15-секундными отрезками. Неполный отрезок всегда округляется до 15 секунд. ASR/TTS Just AI Минуты ASR/TTS — количество минут, которые будут использованы на распознавание и синтез речи во время обзвона. Just AI предоставляет пользователям JAICP доступ к услугам ASR/TTS провайдеров. Тарификация производится в соответствии с правилами провайдеров.']	Нет, при использовании $caila в сценарии не тратятся лимиты аккаунта по запросам в CAILA API. Лимиты аккаунта относятся только к обращениям к API провайдеров ASR/TTS и NLU-минутам, а не к использованию $caila.	0.0	0.9689605979223678	0.0
Вопрос от по использованию SalesForce - операторского канала:   что происходит при завершении чата со стороны клиента. Какой запрос отправляется в SalesForce и что отправляется в чат бота. Как JAICP понимает что чат завершен на стороне клиента (по какому событию)	"[""'Происходит событие closeChat'""]"	"['Остальная информация будет отправлена на вебхук, который вы можете указать в настройках канала Chat API. Событие будет отправлено на вебхук, если: Вы отправили асинхронный запрос. Клиент получил ответ от оператора. Время ожидания между ответами на запрос было превышено. Если запрос не был успешно выполнен, запрос будет отправлен повторно еще три раза. Время ожидания между ответами при асинхронных запросах составляет три секунды. На вебхук придет массив JSON-объектов: Получение асинхронных событий в чате Метод GET /chatapi/{token}/events предназначен для получения асинхронных событий от сервера, например: Ответ от оператора. Изменение состояния виджета на другой странице браузера. Запрос клиента, отправленный на другой странице. Ответ бота на запрос с другой страницы. Метод реализует стратегию long polling: если нет подходящих событий, он блокируется в ожидании следующего события. Максимальное количество событий в ответе на запрос — 250. Если нужно обработать больше, используйте метод для получения истории переписки. Фильтрация событий Параметр all данного метода определяет, нужно ли выводить все события в канале или только ответы от оператора (поведение по умолчанию). Если клиент вел диалог в нескольких чатах одновременно, при выводе всех событий в канале и при отсутствии в запросе параметра cid метод может возвращать дубликаты сообщений. Параметр ts задает время, начиная с которого нужно фильтровать события.', 'Обновления JAICP в октябре 2023 Интеграция с ChatGPT. Новая проектная аналитика: Переработанный раздел Обзор проекта. Новые методы сервиса $analytics. Настройка метрик аналитики. Новые подробные отчеты. Встроенный сервис $conversationApi. Оператор по умолчанию в Aimychat. Получение данных о воспроизведении реплики. Интеграция с ChatGPT В JAICP появилась интеграция с ChatGPT от OpenAI. Вы можете использовать ее, например, для генерации ответов на нераспознанные фразы пользователя или создания креативных решений. Вы можете обращаться к модели напрямую из сценария бота через встроенный сервис $gpt. Для этого вам не нужно иметь собственный API-ключ и токены от OpenAI. MLP-токены уже входят в тарифы JAICP. Чтобы модель генерировала ответы на фразы пользователей, вызовите в нужном стейте метод $gpt.createChatCompletion. В запросе вы можете передавать дополнительную информацию о контексте диалога и истории сообщений с пользователем. Тогда ответы ChatGPT будут более точными. Новая проектная аналитика В этом месяце мы полностью переработали инструменты проектной аналитики в JAICP. Интерфейс раздела Обзор проекта Теперь в разделе Обзор проекта представлена подробная статистика по работе бота. На графиках вам доступны сводные данные по количеству пользователей, сессий и сообщений, а также их изменения по периодам. Вы можете фильтровать значения по нужным периодам и каналам. Также вы можете анализировать метрики работы бота: Процент автоматизированных диалогов.', 'Оператор отвечает на сообщения клиента, при этом он также может перевести диалог обратно на бота. Вся переписка клиента сохраняется как в логах операторского чата, так и в логах бота. Такой способ взаимодействия доступен в каналах: Chat2Desk Jivo Webim (Custom Channel API) Диалог в стороннем канале Вы можете разместить бота не в виджете онлайн-чата, а в другом канале, например в Telegram. При этом вы дополнительно подключаете онлайн-чат, чтобы у операторов была возможность обрабатывать диалоги. Схема взаимодействия будет следующей: Вы создаете сценарий бота и публикуете его в любом входящем канале. Затем вы подключаете бота в онлайн-чат, в который диалог будет переводиться для обработки оператором. Для реализации в платформе JAICP подключите операторский канал к любому входящему. Например, входящий канал Telegram и операторский канал Webim (Custom Channel API). Клиент начинает диалог с ботом. При этом операторский канал не задействован, всё общение происходит исключительно между ботом и клиентом. Когда бот переводит диалог на оператора, активируется операторский канал. В нём создаётся новая сессия, о факте диалога узнаёт оператор. В зависимости от канала, оператор получает доступ к последним сообщениям бота и клиента, либо ко всему диалогу. Если оператор доступен, дальнейший диалог будет происходить между оператором и клиентом. При недоступности оператора бот в зависимости от сценария может предложить клиенту подождать или оставить контактные данные.', 'Разработка бота Это часть серии статей, посвященной созданию исходящего обзвона с использованием CAILA. Настройка подключения Разработка бота (вы находитесь здесь) Запуск обзвона Аналитика по диалогам Расширение сценария Тестирование На данном этапе создадим сценарий бота. В скриптовых вставках мы будем обращаться к различным методам объекта $dialer для взаимодействия с телефонией. Для понимания естественного языка воспользуемся CAILA. Конфигурационный файл Перейдите в Редактор и создайте стандартный для проектов на CAILA конфигурационный файл chatbot.yaml: Основная часть сценария Создайте файл src/main.sc и поместите в корневую тему theme основную логику сценария: Создайте также файл test/test.xml, но пока оставьте его пустым: Начало диалога Технический запуск бота при дозвоне происходит по команде /start, которую можно обработать паттерном для регулярных выражений. В обработчике данного активатора бот: Используйте спецсимвол + в словах, которые могут читаться по-разному, для корректной постановки ударения в контексте фразы: В связ+и. Помечает сессию как новую и очищает данные предыдущих сессий, если они были. Извлекает имя клиента из списка клиентов и сохраняет его в хранилище сессионных данных. Устанавливает результат звонка, соответствующий текущему шагу диалога. Если информация об имени клиента отсутствует, используется нейтральное обращение.', 'Работа с CRM из сценария чат-бота CRM (Customer Relationship Management System) — это система управления продажами. CRM оптимизирует работу с клиентами и сопровождает их от первого контакта до финальной сделки. Работа со сделками из сценария Для работы с CRM используется тип ответа crmIntegration, в который необходимо передать channelType, task и parameters: Здесь: channelType — для работы с CRM Битрикс24 укажите ""BITRIX"". task — укажите тип события для CRM, возможные значения: LEAD_CREATION — создание лида; DEAL_CREATION — создание сделки; DEAL_UPDATE — обновление сделки. parameters — дополнительные параметры для события. Параметр указывается в формате ""fields\\[имя\\_параметра]"": ""значение"". Подробнее о параметрах для лидов и сделок При успешном событии в сценарий приходит event: CRM_SUCCESS_EVENT, иначе event: CRM_FAILED_EVENT Обратите внимание, что будут обновлены только сделки, созданные из бота. Если было создано несколько сделок для одного клиента, будет обновлена последняя. Сценарий обновления сделки', 'Вопрос-Ответ (FAQ) В разделе Вопрос-Ответ (FAQ) находится база знаний вашего чат-бота. В нее можно внести вопросы, которые клиенты часто задают боту, и заполнить ответы на них. Клиент может задать боту внезапный вопрос, который не относится к текущему диалогу. Ответ на такой вопрос не предусмотреть в сценарии, но можно занести его в базу знаний. Например, если клиент оформляет заказ, он может спросить о графике работы компании или сколько стоит доставка. У бота уже будет заготовленный на этот случай ответ, который он сможет использовать. Как работает база знаний В общем случае, если клиент задает вопрос не по теме диалога, но ответ на него есть в базе знаний, бот прерывает сценарий и отвечает на вопрос. После этого бот возвращается к сценарию. Есть несколько частных случаев, которые полезно учитывать при работе с базой знаний: Если клиент задает вопрос после текстового блока, то бот ответит на вопрос и продублирует ответ из этого блока. Если клиент задает вопрос, когда бот ожидает ответа от клиента на блоке Интенты, то бот ответит на вопрос, но клиент все равно должен ввести текст ответа, чтобы диалог продолжился. То есть, если клиент задает вопрос после блока Текст, то бот инициирует продолжение разговора, а если после интента, то клиент должен сам написать в чат. Работа с базой знаний Если вы создали бота в конструкторе, вам доступна упрощенная база знаний.', 'Например, в чат-виджете пользователь определяется по файлу cookie waUserId\\_&lt;ID\\_проекта>. Если человек пообщался с ботом в виджете с двух разных браузеров, для бота это будут два разных пользователя, каждый со своей сессией. Ручное управление сессией В проекте могут быть предусмотрены различные условия завершения сессии, например: Истечение таймаута. Перевод на специалиста службы поддержки. Выключение устройства, на которое установлено чат-приложение. Разработчик бота должен самостоятельно определить, в каких случаях должна завершаться старая сессия и начинаться новая, и в нужных местах сценария вызвать один из методов управления сессией: Управление сессией в телефонном канале В телефонном канале управление сессией отличается от остальных каналов. JAICP автоматически управляет сессиями, исходя из принципа «одна сессия — один телефонный звонок»: Новая сессия всегда начинается в начале звонка. Это происходит независимо от того, звонит ли новый или существующий абонент и есть ли в сценарии вызов $jsapi.startSession. Сессия всегда завершается, когда абонент заканчивает звонок. Вызывается ли в сценарии метод $jsapi.stopSession или нет, также не учитывается. При этом ручное управление сессией в процессе звонка не ограничивается. Если один звонок нужно разбить на несколько сессий, JAICP позволяет это сделать.', '$dialer.hangUp Метод завершает звонок со стороны бота. Синтаксис Метод вызывается без аргументов либо с одним строковым аргументом: Если передана строка, она отправляется как сообщение бота при вызове метода в текстовом канале. Особенности При окончании разговора по запросу бота в сценарий приходит событие botHangup: Если разговор завершает сам клиент, приходит другое событие — hangup:', 'Управление сессией Сессия — последовательность запросов пользователя и ответов бота, которые имеют общий контекст. Разбиение диалогов на сессии используется в JAICP на нескольких уровнях: Разработка сценария: для хранения сессионных данных используется объект $session, чье время жизни ограничено длительностью сессии. При завершении сессии этот объект очищается. Аналитика: в сессиях собирается история диалогов бота с пользователями. По ним можно качественно оценить работу бота. Встроенный сервис $analytics позволяет программно размечать сессии для дальнейшей аналитики. Автоматическое управление сессией Первая сессия начинается для пользователя в тот момент, когда он впервые обращается к боту. Его дальнейшие запросы и ответы бота также попадают в эту сессию до тех пор, пока она не завершится. Во всех каналах JAICP, за исключением телефонного, сессии с одним и тем же пользователем не завершаются автоматически. Рассмотрим пример. Пользователь, авторизованный в Telegram, пообщался с ботом 18 мая, а затем снова обратился к нему 22 июня. Если разработчик сценария специально не предусмотрел логику завершения сессии по таймауту, JAICP отнесет второе обращение к той же сессии, что и первое. Длительность такой сессии будет считаться равной 35 дням. Сессии всегда привязаны к конкретному пользователю канала, но не все каналы требуют от пользователя авторизации. Такие каналы не всегда могут восстановить сессию.', 'Готовый сценарий Часть сценария, где бот запрашивает и обновляет информацию о мероприятии: Теперь создайте таблицу и настройте ее для чтения данных.']"	При завершении чата со стороны клиента в SalesForce отправляется запрос события hangup. Он содержит информацию о завершении чата, например, время завершения и идентификатор чата. JAICP понимает, что чат завершен на стороне клиента по событию hangup, которое приходит в сценарий.	0.5	0.9359026672097469	0.1249999999875
Можно ли так подменить $request в прематче, чтобы матчился тектовый запрос, а не event speechNotRecognized?	"[""'Включите эту опцию в конфигурационном файле chatbot.yaml. Поле nlp.modifyRequestInPreMatch включает возможность изменять содержимое запроса в обработчике preMatch — например, редактировать текст запроса.'""]"	"['Хочешь еще раз? и совершит переход в стейт /Правила/Согласен?. Подсказки Если введенное число меньше, то бот посредством функции $reactions.answer() выдаст соответствующую фразу из массива selectRandomArg(). Например: Попробуй число больше. Функция selectRandomArg() предназначена для случайного выбора ответов из предложенных вариантов. Чтобы воспользоваться этой функцией, подключите JS-файлы common.js посредством require в начале файла main.sc. Затем перечислите в selectRandomArg() через запятую возможные варианты ответов. Например: Если введенное число не подошло под первые два условия, то сработает последний else и бот напишет случайно одно из сообщений массива. Таким образом, пользователь будет находиться в стейте Проверка до тех пор, пока не отгадает загаданное число. NoMatch Управление контекстом Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение пользователя не подходит ни под один описанный стейт. Предположим, что пользователь ввел следующее сообщение Сегодня солнечно. Такое сообщение не попадет ни под один интент, поэтому активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Если мы попадем в этот стейт, например, из стейта Правила, и пользователь затем введет сообщение хочу, то бот отправит сообщение я вас не понял.', '$imputer.cacheAudio Метод $imputer.cacheAudio позволяет кэшировать реплику на сервере: на один час или навсегда. Вызов этого метода может потребоваться, чтобы избежать задержек — пауз во время диалога бота с абонентом. Реплику нужно кэшировать заранее — перед ее использованием в сценарии. Предусмотрите стейт в вашем сценарии, где это можно сделать. Синтаксис Метод $imputer.cacheAudio принимает аргументы: Если вы хотите, чтобы реплика была кэширована, аргументы replicaTemplateId, variables, voiceSpeed, переданные для метода $imputer.cacheAudio, должны совпадать с теми, что вы передаете для $imputer.generateAudioUrl. Примеры вызова Пример использования В этом примере реплики без переменных также были использованы в сценарии при помощи вызова метода $imputer.generateAudioUrl. Это было сделано, чтобы избежать разницы в звучании реплик: c переменными и без. Подробнее см. в разделе Гибридный синтез от Just AI.', 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.', '$nlp.match Метод выполняет классификацию текста в контексте указанного стейта. Синтаксис Метод принимает в качестве входных параметров необходимую для сопоставления фразу и стейт, в котором будет проведен поиск. Метод возвращает объект NLPResult, который содержит указание на сработанный паттерн, стейт и объект parseTree. Пример использования Метод может использоваться для управления порядком классификации фраз в специфичных контекстах. Например, есть сценарий, в котором бот предоставляет клиенту информацию о запрашиваемых акциях. Информация об акциях хранится в стороннем сервисе. Создадим стейт Promos, в котором клиенту будет предложен список акций. Установим стейту флаг modal = true для того, чтобы остаться в контексте этого стейта, пока не будет обработан запрос клиента. Как было сказано ранее, информация об акциях хранится в стороннем сервисе, а не в сценарии бота. Поэтому использование паттернов для получения этой информации нецелесообразно. Вместо этого будем использовать стейт Get с событием noMatch, в который будут попадать нераспознанные запросы клиента. Поскольку мы все еще хотим распознать фразу клиента для предоставления информации об акциях, будем использовать метод $nlp.matchExamples для определения запрашиваемой акции и перенаправления диалога. Если к полученному запросу не удалось найти соответствующего названия акции, тогда используем метод $nlp.match для распознания всей фразы.', 'Например, если у вас есть столбец name, то в блокноте у вас получится:$rawRequest.originateData.payload.name Ниже пример таблицы и значений $rawRequest: :size=400 Системную переменную с названием нужной колонки используйте в блоке Текст: :size=400 В данном случае при звонке на номер 79105555555 бот скажет: ""Здравствуйте, Саша!"". А при звонке на номер 79995555555 бот скажет ""Здравствуйте, Алекс!"" Почему при тестировании возникает ошибка? После того, как вы используете перечисленные выше значения $rawRequest в сценарии, при тестировании в тестовом виджете вы будете получать ошибку, так как информацию из таблицы можно доставать только из телефонного канала. :size=400 Поэтому мы рекомендуем добавлять значения $rawRequest для вывода имени тогда, когда вы уже готовы запустить обзвон. Извлекать имя пользователя и другую информацию из таблицы с номерами можно только в процессе обзвона. В тестовом виджете это работать не будет. Если вы в данный момент находитесь в процессе тестирования сценария и вам нужно тестировать стороннюю функциональность, отложите использование $rawRequest до того этапа, когда сможете запускать обзвон и тестировать в телефонном канале. Примеры содержания $rawRequest В текущей таблице переменная $rawRequest содержит следующие данные: После ответа пользователя $rawRequest будет также содержать текст сообщения пользователя:', 'Сперва откройте конфигурационный файл chatbot.yaml и дополните его полем injector, в котором укажите настройки прерывания слот-филлинга: В данном случае параметр maxSlotRetries: 3 означает, что бот дважды переспросит время перезвона, если не распознает его в ответах. Если клиент назовет некорректное время в третий раз, слот-филлинг прервется, а запрос попадет в стейт /Симптомы/Ответ по активатору event! : noMatch. Возможность прерывания по интенту для данного сценария не играет роли, поскольку других стейтов с глобальными интентами в сценарии нет. Поэтому параметры stopOnAnyIntent и stopOnAnyIntentThreshold установлены в соответствии с поведением по умолчанию. Дополнение сценария Осталось подключить в main.sc модуль слот-филлинга и добавить в корневую тему theme новый стейт: Метод $dialer.redial запланирует новый звонок с учетом нужного времени и включит его в обзвон. Перебивание Не всегда целесообразно ждать, когда бот закончит говорить, чтобы дать клиенту возможность ответить. Чтобы клиент мог перебивать бота, настройте в сценарии прерывание речевого потока.', 'Вот что получится в нашем случае: Нажмите Сохранить изменения и вернитесь на вкладку Сценарий. Найдите в вашем сценарии экран, на котором есть блок Текст, содержащий $items.current().question. Добавьте на этот экран блок Интенты. Скопируйте и вставьте в этот блок интент $answers. Вы также можете добавить в интенты такой шаблон: Если будете использовать этот шаблон, не забудьте поставить пробелы между $answers и звездочками: звездочка, пробел, $answers, пробел, звездочка. Этот шаблон позволит нам принимать ответ, даже если он окружен другими словами. Например, если на вопрос ""Сколько будет дважды два?"" пользователь ответит ""Ну, четыре, я думаю"" – благодаря этому шаблону бот сможет также принять этот ответ. Подробнее о синтаксисе шаблонов читайте в этой статье. Нажмите Сохранить. Вот что у нас получилось: Кликните на интент $answers и создайте блок Условия. Скопируйте и вставьте в него: $answers == $items.current().answer Здесь мы сравниваем ответ, который содержится в справочнике сущностей, с ответом из таблицы. == это оператор сравнения языка Javascript. Можете почитать о нем подробнее здесь. От условия $answers == $items.current().answer сделайте связь со следующим экраном и добавьте блок Текст. Скопируйте и вставьте на него: Да, это правильный ответ! Добавьте сюда еще один блок Текст: А вот подробный ответ: $items.current().link В этом блоке мы выводим соответствующую ссылку из таблицы, используя встроенную функцию Aimylogic current().', 'И, наконец, добавим еще одну строку: $TEXT::isname Данная строка будет отрабатывать только в том случае, если ни один из других примеров не отработал. Введенное на данном экране сообщение клиента будет попадать в нее полностью. Этот $TEXT нам нужен на случай, если клиент добавил необычное имя одним словом. По умолчанию, когда вы переходите в редактирование блока Интенты и начинаете добавлять строки, они добавляются как примеры фраз, а не как шаблоны. Об этом свидетельствует иконка . Нажмите Сохранить. Теперь можно удалить экран с текстом Вас правда зовут $queryText?, так как у вас есть сущность $TEXT, которая будет принимать любую строку. Если в интентах есть $TEXT, то ветка Любая другая фраза отрабатывать не будет. Далее нам нужно сделать связь от интента \\* меня \\* зовут $TEXT::isname и создать блок Условия: В блок Условия вставьте следующее выражение: $name = $NAME ? $NAME.name : $isname С помощью этого условия вы создаете переменную $name. = — это оператор языка программирования JavaScript, с помощью которого присваивается значение переменной $name. Далее идет логическое выражение. Если у вас ранее что-то попало в системную сущность $NAME, то переменная $NAME.name будет записываться в переменную $name. Если же в системную сущность $NAME ничего не попало, то в $name запишется значение $isname. В итоге в переменной $name окажется имя из словаря или принятое необычное имя.', 'В правой части — строка, определяющая путь перехода при нажатии кнопки. В нашем сценарии переход по нажатию осуществляется в стейт RememberCity. Флаг modal = true используется для того, чтобы бот не мог перейти в следующее состояние, пока пользователь не выберет город. RememberCity Выбор клиента будет обработан с помощью $request.query и записан в переменную $client.city. Бот будет предлагать последующие варианты ответов в зависимости от выбранного города. С помощью тега go! осуществляется переход в стейт ChoosePizza, работа которого будет описана в следующих шагах. ClickButtons Стейт ClickButtons реагирует на любой текстовый ввод клиента и выводит ответ Нажмите, пожалуйста, кнопку. Оно необходимо, так как modal=true не дает текстовому вводу попасть в глобальный CatchAll. Затем осуществляем переход в состояние на уровень выше go! : .., так как нам важно, чтобы клиент выбрал город. CatchAll Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт CatchAll, который обрабатывает сценарий в случае, когда сообщение клиента не подходит ни под один описанный стейт. Воспользуемся флагом noContext = true, чтобы контекст не изменился при попадании в стейт CatchAll. Тестирование Подключим канал в Telegram и протестируем результат работы сценария. Результат запуска: Telegram канал Telegram канал Далее перейдем к работе со справочником.', 'В переменной $queryText хранится полный текст ответа клиента на последний запрос. Если вы хотите сохранить ответ клиента на весь сценарий, создайте новую переменную и присвойте ей значение переменной $queryText. Запрос для отправки данных клиента должен выглядеть следующим образом: HTTP-запрос Соедините вариант Завершен успешно с новым экраном и напишите на нем сообщение об успешной отправке данных. Вариант Завершен с ошибкой соедините с экраном, на который добавьте текст Не удалось получить номер телефона. Ошибка $httpStatus. Если возникнет ошибка и бот пойдет по этой ветке сценария, он выведет сообщение с кодом ошибки. Это поможет вам понять причину ошибки. Сценарий Подобное сообщение рекомендуется добавлять только при тестировании бота. После того как вы протестировали бота и убедились, что он работает корректно, продумайте, какое сообщение должен получить клиент в случае ошибки. Тестирование отправки данных Теперь можете протестировать работу сценария. Для начала нажмите Опубликовать, чтобы изменения в сценарии отправились в Telegram. После этого нажмите Тестировать. Если вы используете один и тот же аккаунт при создании и при тестировании бота, тогда после получения данных бот пришлет их в тот же диалог: Пример диалога Бот всегда будет присылать полученные данные в чат с аккаунтом, chat_id которого вы указали в запросе. Когда реальные клиенты будут отправлять данные боту, он не будет выводить им сообщение с их данными, а отправит его в указанный чат.']"	В документации не указано способа подменить $request в прематче для матчинга текстового запроса. Возможно, это невозможно. Попробуйте переформулировать вопрос или обратиться к разработчикам для получения более подробной информации.	0.33333333333333337	0.9122449569479505	0.0
Подскажите, для трансформера доступны какие-то расширенные настройки из JAICP?	"[""'Нет, так как в документации не сказано про расширенные настройки именно этого классификатора'""]"	['Разместите его в директории src или по пути, который вы задали самостоятельно как параметр npmRcFile в chatbot.yaml. Например, вы можете использовать не только пакеты из публичного реестра https&#x3A;//registry.npmjs.org/, но и из приватного. Для этого в файле .npmrc укажите адрес реестра и токен для авторизации: Использование встроенного JS API JAICP предоставляет встроенный JS API — набор глобальных переменных, функций и сервисов, которые доступны из любой точки сценария. С помощью него можно реализовать часто используемую функциональность, актуальную для самых разных проектов: Переменные $session и $client предоставляют нативное хранилище данных о сессии и клиенте без необходимости подключать к боту свою базу данных. Сервис $http дает возможность интегрировать бота практически с любой внешней системой, к которой можно обратиться по HTTP API. Сервисы $analytics, $imputer, $pushgate и ряд других позволяют вызывать из сценария различные специализированные подсистемы самой JAICP. На данный момент внутри тегов scriptEs6 и зависимостей на ES6 вы можете использовать ограниченное подмножество JS API — не все возможности перенесены в новую среду исполнения. Список доступных возможностей приведен ниже и постепенно будет расширяться. Если нужная функциональность напрямую не связана с JAICP, используйте внешние зависимости, чтобы компенсировать ее недостаток. Например, вместо $http отлично подойдет HTTP-клиент Axios.', 'В данной подсекции ключи представляют собой ISO-коды языков, а значения — тексты сообщений. В поле defaultMessage указывается текст сообщения по умолчанию, которое отправляется в случае, если секция locales не задана или в ней не задан нужный язык. Также можно задать список сообщений по умолчанию в поле defaultMessages — тогда при ответе будет выбрано случайное из них. Если секция messages.onError не заполнена, то в случае возникновения ошибки бот не ответит клиенту. Для настройки более гибкого поведения при внештатных ситуациях используйте обработчики ошибок. Injector Секция injector позволяет задать параметры конфигурации чат-бота. Заданные параметры будут доступны в скриптах чат-бота через переменную $injector. Подробнее об $injector Настройки SMTP-сервера Секция injector.smtp позволяет задать настройки SMTP-сервера, через который будут отправляться email-сообщений при помощи метода $mail.sendMessage. Другие настройки Возможность изменения запроса Поле nlp.modifyRequestInPreMatch включает возможность изменять содержимое запроса в обработчике preMatch — например, редактировать текст запроса. Токенизация слов в паттернах Поле tokenizeWordsInPatterns включает токенизацию слов в паттернах для языков без разделителей между словами. Поле обязательно для корректной работы паттернов в проектах на китайском языке. Порядок загрузки файлов Поле scenarioLoadStrategy задает порядок загрузки файлов в сценарий, состоящий из множества файлов.', 'Явная квалификация каждого модуля соответствующим именем позволяет не засорять глобальное пространство имен. Глобальные переменные Для обратной совместимости со старой средой исполнения оставлена возможность обращаться к значениям, объявляемым внутри модуля, как к глобальным переменным — без необходимости каждый раз указывать пространство имен. Если вы хотите использовать глобальные переменные, в нужном модуле объявите их как свойства системного объекта global, после чего подключите модуль к сценарию. При этом объявление экспорта по умолчанию внутри модуля и указание параметра name у тега require по-прежнему обязательны. Использование глобальных переменных не рекомендуется: такой подход засоряет глобальное пространство имен и приводит к неявным зависимостям между модулями. В примере ниже при помощи Proxy объявляется объект $ — алиас объекта $context, который позволяет в более лаконичной записи обращаться к его свойствам: Конфигурация среды исполнения в chatbot.yaml Новая среда исполнения не требует какой-либо конфигурации: если в сценарии есть тег scriptEs6 или подключена зависимость с таким типом, их код будет автоматически исполнен как ES6. Однако в тестовых целях вы можете частично настроить поведение новой среды исполнения. Для этого используйте новую секцию scriptRuntime в конфигурационном файле chatbot.yaml. requirementsFile — путь до JSON-манифеста с объявлением внешних зависимостей, которые будут использоваться в сценарии, относительно директории src.', 'В этом релизе мы сделали возможным более гибкое поведение. При публикации бота в тестовый виджет, отдельный канал или все каналы проекта вы можете проконтролировать режим, в котором будут запущены тесты. Выбор режима запуска тестов на верхней панели Выбор режима запуска тестов при публикации бота в канал Выбранный режим запоминается и используется при дальнейших публикациях бота, пока не будет изменен. Новые провайдеры распознавания речи Мы постоянно расширяем список провайдеров распознавания речи (ASR), которых вы можете использовать в своих телефонных проектах JAICP. С этого релиза вы можете подключить ASR от провайдеров: Kaldi — разверните сервис ASR с использованием библиотеки Kaldi и укажите его URL и API-ключ при создании подключения. АСМ Решения — выберите подключение, предоставляемое Just AI, или создайте собственное (для него потребуется токен доступа). Документация к типам ответов бота В документации мы полностью переработали раздел Ответы бота. Добавление типизированных ответов в $response.replies — низкоуровневый способ управлять реакциями бота. Его преимущество по сравнению с DSL-тегами реакций и встроенным сервисом $reactions в том, что он позволяет отправлять любые виды реакций, которые поддерживаются в JAICP. Теперь каждому типу ответа посвящена отдельная статья, в каждой из которых вы узнаете: Какие свойства принимают ответы с тем или иным типом. Есть ли в интересующем вас канале ограничения на использование определенных типов ответов.', 'Теперь в секции nlp можно задать дополнительные поля для доступа к правилам активации только нужного типа: Обновления документации Обновлена инструкция о том, как подключить бота на JAICP к каналу Slack.', 'По умолчанию package.json. npmRcFile — путь до конфигурационного файла npm, относительно директории src. По умолчанию .npmrc. forceEs6 — если указано true, то код всех тегов реакций (не только script, но и, например, тега a) будет запускаться в новой среде исполнения. По умолчанию false. Запуск всех тегов в новой среде исполнения в настоящее время не оптимизирован. Рекомендуется не включать параметр forceEs6, если важно сохранить скорость ответа бота. Подключение npm-пакетов Ключевое преимущество новой среды исполнения над старой заключается в том, что для расширения возможностей бота вы можете использовать не только встроенное JS API, но и внешние зависимости — npm-пакеты, написанные сторонними разработчиками. Как подключить и использовать пакет Создайте в директории src файл package.json. Если вы переопределили requirementsFile, создайте файл по тому пути, который вы задали сами. Задайте в этом файле свойство dependencies. Его значением должен быть объект, где ключи — названия требуемых пакетов, а значения — их версии. Если вы разрабатываете проект локально, рекомендуется устанавливать зависимости через npm или любой другой пакетный менеджер, например yarn. Пакетные менеджеры могут сами определять оптимальные версии зависимостей и заполнять файл package.json автоматически. В файле могут быть заданы и другие свойства, но JAICP будет учитывать только dependencies.', 'Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.', 'Используйте пакет так же, как внутренние зависимости: импортируйте нужные объекты через import и обращайтесь к ним в нужных местах своего кода. Ограничения на доступные пакеты Если в сценарии используются внешние зависимости, JAICP устанавливает их перед публикацией бота в канал, фактически выполняя команду npm install. Во время дальнейшей работы бота JAICP уже не может выполнять никакие команды (например, те, что объявлены в секции scripts в package.json), поэтому: В JAICP не будут корректно работать пакеты, которые требуют запуска команд наподобие npm start. В частности, это Express и любые другие пакеты, которые самостоятельно запускают локальные серверы. Код для запуска в новой среде исполнения не получится писать на TypeScript, поскольку он требует отдельного этапа компиляции исходного кода через tsc. Также рекомендуем с осторожностью подходить к пакетам, которые уже после запуска генерируют артефакты, необходимые им для работы. Пример такого пакета — Prisma: она генерирует клиент для подключения к СУБД по заданной схеме данных. Боты на ECMAScript 6 имеют возможность работать с файловой системой, однако она не предназначена для постоянного хранения файлов и в любой момент может быть очищена. Чем больше пакетов вы используете, тем медленнее будет происходить публикация бота. Подключайте только то, что действительно нужно для работы проекта. Конфигурация npm Для дополнительного контроля над установкой npm-пакетов вы можете использовать конфигурационный файл .npmrc.', 'Обновления JAICP в декабре 2022 Разный порог активации для фраз и паттернов CAILA. Новые форматы ответов на вопросы из FAQ. Встроенный сервис $faq. Экспорт сценария из J‑Graph в PNG. Обновленная документация к тегам действий (специальным тегам). Разный порог активации для фраз и паттернов CAILA Раньше в конфигурационном файле chatbot.yaml часто использовалось поле caila.noMatchThreshold, которое задает общее пороговое значение и для тренировочных фраз, и для паттернов при работе с классификатором CAILA. Теперь вместо этого вы можете задавать разные пороговые значения для тренировочных фраз и паттернов. Для этого воспользуйтесь параметром nlp.intentNoMatchThresholds. Этот параметр содержит поля phrases и patterns со значениями по умолчанию 0.2. Подробнее о пороге активации для тренировочных фраз и паттернов Новые форматы ответов на вопросы из FAQ Теперь на вопросы из базы знаний можно отвечать не только в текстовом формате: загружайте изображения, аудиозаписи и файлы. К ответу на вопрос можно прикреплять сообщения, которые бот отправит пользователю по порядку. Подробнее о новом формате ответов на вопросы из FAQ Встроенный сервис $faq Встроенный сервис $faq упростит взаимодействие с FAQ. Теперь вы можете: Получать все сообщения из ответа на вопрос в формате JSON с помощью метода getReplies. Получать и сразу отправлять пользователю эти сообщения, используя метод pushReplies.', 'Обновления JAICP в январе 2023 Классификатор Transformer. JavaScript-действия. Строковые подстановки в YAML-справочниках. Обновлена статья о Chat API. Классификатор Transformer В январьском обновлении JAICP мы представляем новый алгоритм классификатора. Transformer выполняет классификацию на основе большой языковой модели и использует не просто слова, а информацию о смысловой связи между ними. Алгоритм может быть полезен, если у вас нет большого объема данных для обучения бота. Модель заранее обучили на значительном объеме текстов, поэтому она хорошо показывает себя при работе с небольшой выборкой. Свяжитесь со своим аккаунт-менеджером или напишите нам на support@just-ai.com, чтобы бесплатно попробовать бета-версию. Подробнее о Transformer JavaScript-действия В JAICP DSL есть особые теги действий, которые позволяют вызвать из стейта отдельный сценарий: например, запрос подтверждения или обработку оплаты в Telegram. Также через эти теги можно реализовать сложное действие, которое не предполагает работу с контекстом (например, HTTP-запрос). Теперь в таких случаях вы можете использовать лучше приспособленные для них JavaScript-действия. Такие теги реализованы не как переход в подсценарий, а как обычный вызов функции. Обновлена статья о Chat API Добавлено описание новых методов.']	В январьском обновлении JAICP представлен новый алгоритм классификатора - Transformer. Он выполняет классификацию на основе большой языковой модели и использует информацию о смысловой связи между словами. Для использования Transformer свяжитесь со своим аккаунт-менеджером или напишите на support@just-ai.com, чтобы получить доступ к бета-версии.	1.0	0.8615646448471392	0.7620370370243363
Привет. Подскажите, какие токенизаторы поддерживаются для английского? В доке написано, что только spacy, но судя по ответам от кайлы, это неправда (вижу там стенфордские POS-теги)	"[""'В кайле английский поддерживает только spacy'""]"	"['Поддержка других языков Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов Поддержка русского языка Поддержка других языков (вы находитесь здесь) Публикация в канал В следующем разделе пошагового сценария мы создадим бота на английском языке в составе многоязычного бота. Создайте новый проект, в качестве языка NLU выберите английский. Наполнение интентов Бот на английском языке должен поддерживать ровно те же интенты /hello и /book, что и бот на русском языке, с отличиями только в языке тренировочных фраз и вопросов для слот-филлинга. Интент для бронирования Сценарий Код англоязычного бота будет практически полностью совпадать с русскоязычным: изменения затронут только конфигурацию и тексты ответов. В разделе injector файла chatbot.yaml потребуется указать ISO-код английского языка вместо русского: В файле main.sc переведите все тексты ответов бота на английский язык, а также измените путь к зависимости на справочник имен на английском языке: Файл routerClient.js скопируйте из русскоязычного бота без изменений. Подключение к роутеру Так же, как и для русского языка, опубликуйте созданного бота в любом канале, скопируйте идентификатор бота и зарегистрируйте его в injector бота-роутера: Другие языки В многоязычного бота, построенного по приведенной схеме, легко добавить поддержку произвольного числа других языков.', 'Поддержка русского языка Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов Поддержка русского языка (вы находитесь здесь) Поддержка других языков Публикация в канал В этом разделе мы создадим бота на русском языке — второй составляющей бота, который будет понимать несколько языков одновременно. В JAICP вновь создайте новый проект, в качестве языка NLU для данного проекта выберите русский. Перейдите в раздел CAILA. Наполнение интентов Бот для данного пошагового сценария будет запрашивать имя клиента и номер комнаты для бронирования. Создайте через интерфейс CAILA два интента: /hello — интент для обработки приветствия. Добавьте для него такие тренировочные фразы, как добрый день, здравствуйте, привет. /book — интент, обрабатывающий запросы о бронировании комнаты по номеру. Включите для данного интента слот-филлинг, после чего настройте по образцу того, как показано ниже. Интент для бронирования Сценарий Дескриптор сценария Перейдите на вкладку Редактор для написания кода сценария. В конфигурации каждого одноязычного бота необходимо задать ISO-код языка, который он поддерживает. Добавьте этот параметр в раздел injector файла chatbot.yaml, чтобы он стал доступен из сценария. Функции Создайте в папке src файл routerClient.js. Функции из этого файла будут отвечать за взаимодействие с ботом-роутером.', 'Бот для маршрутизации запросов Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов (вы находитесь здесь) Поддержка русского языка Поддержка других языков Публикация в канал В этом разделе мы напишем реализацию бота-роутера, предназначенного для маршрутизации запросов клиента в одноязычного бота на нужном языке. Перейдите в JAICP и создайте новый проект. Язык NLU и другие настройки данного проекта могут быть любыми. Перейдите в раздел Редактор. Дескриптор сценария В соответствии с предложенной схемой многоязычного бота роутер должен иметь доступ к следующим конфигурируемым параметрам: Язык основного одноязычного бота, на который по умолчанию будет посылаться первый запрос. Текст сообщения в случае, если поступил запрос на неподдерживаемом языке. Идентификаторы всех одноязычных ботов, между которыми необходимо переключать контекст. Зададим данные параметры в разделе injector дескриптора сценария chatbot.yaml: Значение поля defaultLanguage и ключи в словаре bots должны соответствовать ISO-кодам языков, которые будет поддерживать бот. Значения словаря bots временно оставьте пустыми. Заданные параметры будут доступны из сценария через объект $injector. Функции Создадим в папке src файл router.js и поместим туда код, реализующий функциональность бота-роутера. Рассмотрим используемые функции. Все функции в числе аргументов принимают объект $context, представляющий собой текущий контекст обработки запроса.', 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.', 'Использование сущностей внешнего NLU-сервиса при настройке интентов и слотов не будет доступно. В сценарии сущности доступны по тегу q. Использовать интенты внешнего NLU-сервиса и сущности CAILA. Установите ""nluType"": ""external"" для параметра classification и ""nluType"": ""internal"" для markup и ner. В сценарии интенты доступны по тегу intent. Использовать разметку внешнего NLU-сервиса с сущностями и интентами CAILA. Установите ""nluType"": ""external"" для параметра markup и ""nluType"": ""internal"" для classification и ner. В разделе CAILA → Интенты вы можете использовать Тренировочные фразы на языках, которые не поддерживаются платформой. Они будут распознаны в сценарии. Вы можете ознакомиться с примером внешнего NLU-сервиса в репозитории на GitHub.', '$caila.inflect Преобразует слова и словосочетания в нужную грамматическую форму. Метод $caila.inflect поддержан для русского и украинского языков. Синтаксис Принимаемые аргументы Метод принимает 2 обязательных аргумента. Если к одному и тому же слову нужно применить несколько тегов, то они отделяются друг от друга запятой. Возвращаемое значение Метод возвращает слова и словосочетания в требуемой грамматической форме. Пример вызова Грамматические теги Метод $caila.inflect использует библиотеку pymorphy2. В качестве грамматических тегов в pymorphy2 используются теги, принятые в словаре OpenCorpora. Падеж Число Род Лицо Время Ознакомиться с полным списком тегов вы можете на сайте OpenCorpora. Версии словаря В словаре OpenCorpora могут встречаться ошибки преобразования слов. Если результат $caila.inflect не соответствует ожидаемому, вы можете использовать метод $caila.inflectWithDictVersion. Метод $caila.inflectWithDictVersion также использует библиотеку pymorphy2, но он позволяет выбрать другую версию словаря. Метод принимает 3 обязательных аргумента. Пример Методы $caila.inflectWithDictVersion с версией словаря v1 и $caila.inflect возвращают одинаковый результат. Если результат обоих методов не соответствуют ожидаемому, то обратитесь в нашу техническую поддержку. Использование в сценарии', 'Релиз Aimylogic 1.9.6 Сегодня у нас несколько изменений: Обновленная палитра блоков Язык сценария по умолчанию зависит от языка интерфейса Изменение названий сценариев, созданных из шаблонов Счетчик количества реплик в блоке Текст Обновленная палитра блоков Мы изменили визуальное отображение блоков, чтобы в них было проще ориентироваться. Теперь готовые интенты доступны сразу, а не из отдельного подменю. Вся информация о блоках и их использовании есть в разделе о блоках. Это обновление не влияет на функциональность и логику работы блоков. :size=400 Язык сценария по умолчанию Мы изменили язык, который по умолчанию указан при создании сценария. Раньше, вне зависимости от того, пользовались вы английской или русской версией Aimylogic, по умолчанию язык сценария был русский. Теперь язык, указанный по умолчанию, зависит от того, какой язык вы выбрали в настройках вашего аккаунта Aimylogic. При необходимости вы можете его поменять. Не забудьте, что язык сценария можно выбрать только в момент его создания. От выбранного языка зависит список каналов, в которых можно опубликовать сценарий Счетчик количества реплик в блоке Текст Раньше, когда вы добавляли несколько реплик в блок Текст, было сложно понять, все ли они действительно добавились. Теперь, когда вы добавляете несколько реплик, вы видите, сколько реплик было добавлено. Также, если вы наведете курсор на реплику, которая видна в блоке Текст, появится всплывающее окно, в котором текст реплики показан полностью. :size=400', 'currency Модуль предоставляет справочник порядка 200 валют на русском языке. Подключение Для подключения справочника импортируйте следующий файл с помощью тега require: После подключения в сценарии станут доступны следующие пары справочников и именованных сущностей для распознавания валют при помощи паттернов: справочник валют $Currencies и сущность $Currency; справочник неоднозначных валют $ambiguousCurrencies и сущность $ambiguousCurrency. Формат значений Справочник валют В справочник $Currencies включены только полные наименования, однозначно указывающие на валюту. Например, российский рубль, но не просто рубль, который также может быть белорусским. Справочник неоднозначных валют Справочник $ambiguousCurrencies содержит неполные названия валют, которые могут быть интерпретированы по-разному, например рубль и доллар. Примеры строк Справочник валют Справочник неоднозначных валют', 'Поддержка ECMAScript 6 в JAICP До сих пор для сложной бизнес-логики ботов на JAICP поддерживался только один диалект JavaScript (далее JS), а именно его реализация согласно спецификации ECMAScript 5 (ES5) на движке Nashorn. Она была предложена в 2009 году и успела значительно устареть, поэтому возможности написания JS-кода в JAICP не в полной мере отражают современные профессиональные стандарты. Разработчики на JAICP не могут либо могут лишь ограниченно использовать востребованные возможности современных версий JS. В свою очередь, новые пользователи с опытом разработки не могут в полной мере применить свои навыки. Среда исполнения JS в JAICP изолирована от экосистемы пакетов, сформированной сообществом JS-разработчиков, и не позволяет подключать к проектам внешние зависимости, кроме встроенных в платформу (Underscore.js и Moment.js). Мы представляем новую среду исполнения JS, которая решает обе эти проблемы и открывает возможность разрабатывать проекты на современном диалекте JS (далее ES6) с поддержкой внешних зависимостей. Формально ES6 — сокращенное название стандарта ECMAScript 2015, однако JAICP поддерживает и возможности более поздних стандартов. Для простоты в этой статье они объединены под названием ES6. В настоящий момент поддержка ES6 в JAICP находится на стадии бета-тестирования. Если вы хотите принять в нем участие, свяжитесь со своим аккаунт-менеджером или напишите нам на client@just-ai.com. Тег scriptEs6 В JAICP DSL появился новый тег реакции scriptEs6.', 'Поэтому вам не обязательно перечислять все возможные сочетания и синонимы при обучении бота. Однако, для более точной настройки вы можете использовать синтаксис шаблонов. Как получить данные из ввода пользователя Интеллектуальные боты умеют не только реагировать на интент, но и автоматически выделить из сказанного пользователем некоторые важные данные, чтобы в дальнейшем использовать их - для реакций, для вычислений или чтобы передать (например, переслать в мессенджер или отправить на почту). Например, если наш бот умеет автоматически бронировать столик в ресторане, то пользователь с своей фразе может сразу указать дату и время брони. Бот должен уметь выделить дату из ввода пользователя и передать ее в систему бронирования через HTTP запрос. Также, Aimylogic предоставляет возможность извлекать данные из введенного пользователем текста посредством сущностей - справочников фраз и синонимов, которые можно использовать в интентах. В Aimylogic есть системные сущности, а также возможность создавать свои собственные. Подробнее о работе с сущностями можно прочитать в статье Сущности. Кнопки Совместно с интентами, для упрощения диалога с пользователем, вы можете использовать кнопки. Даже если вы используете кнопки на экране, рекомендуется также помещать на экран блок Интенты, чтобы бот понимал, что делать, если пользователь что-то напишет, а не нажмет кнопку. Подробно об использовании кнопок описано в этой статье.']"	К сожалению, в документации не указано о поддержке токенизаторов для английского языка. Однако, возможно, система использует различные токенизаторы в зависимости от конкретной ситуации. Рекомендуется обратиться в техническую поддержку для получения более точной информации по этому вопросу.	0.33333333333333337	0.8957058409828539	0.0
привет! подскажите, пожалуйста, как сейчас можно выставить порог распознавания паттернов в проекте (не в кайле)? у лингвистов есть общие воспоминания, что ранее за это отвечал параметр sts в chatbot.yaml, сейчас данный функционал не срабатывает помогите, пожалуйста, точно ли он должен не срабатывать, и как нам сейчас можно управлять паттернами в q? вопрос относительно срочный, касается вывода проекта в прод	"['\'Нельзя: ""Поля phrases и patterns в секции nlp.intentNoMatchThresholds задают пороговые значения для классификатора интентов CAILA и его гипотез""\'']"	"['Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.', 'В новых проектах для корректного определения паттернов рекомендуется использовать вместо нее секцию nlp, поскольку у классификатора и алгоритма, который вычисляет вес паттернов, могут быть разные шкалы. Длина $context.nBest Поля семейства nlp.nbest задают число правил активации, к которым можно получить доступ из сценария через объект $context. Поле nbest задает длину $context.nBest — массива сработавших для запроса правил активации всех типов: паттернов, интентов и примеров. Значение по умолчанию — 1. Поле nbestPatterns задает длину $context.nBestPatterns — массива правил активации, сработавших только при помощи паттернов. Если поле не указано, то этот массив недоступен. nbestIntents и nbestExamples работают аналогично для интентов и примеров. Подробнее об использовании $context.nBest Ограничения при обработке запроса Ограничение на длину запроса Секция nlp.lengthLimit задает ограничение на длину запросов, которые принимает бот: enabled включает или выключает проверку. symbols — максимальное количество символов в запросе. words — максимальное количество слов в запросе. Если указано -1, эта проверка не производится. По умолчанию включено ограничение на 400 символов, ограничение на количество слов отключено. Если запрос превысит одно из ограничений, в сценарии возникнет событие lengthLimit. Ограничение на время обработки запроса Секция nlp.timeLimit задает ограничение на общее время, в течение которого будет обработан запрос: enabled включает или выключает проверку.', 'Задайте другие пороговые значения для фраз и паттернов в конфигурационном файле chatbot.yaml. Использование паттернов По умолчанию для обучения классификатора используются примеры фраз, однако вы также можете задавать паттерны для непосредственного описания шаблонов фраз, подходящих под интент. Чтобы переключиться на режим ввода паттернов или переделать фразу в паттерн, нажмите . Для переключения обратно на фразы нажмите . Синтаксис паттернов в интентах поддерживает все базовые и большинство расширенных элементов паттернов, за небольшим числом исключений: Не поддерживается паттерн $morph и маппинги — (один:1/два:2). Вместо именованных паттернов $pattern и сущностей $entity&lt;> используйте сущности CAILA. Названия сущностей CAILA начинаются с символа @. Перефразирование тренировочных фраз Если у вас нет готового набора данных для обучения, вы можете воспользоваться встроенным инструментом перефразирования. Он поможет подобрать фразы с похожим смыслом и сэкономить время на формирование обучающей выборки. Вам не придется придумывать фразы самостоятельно, учитывая в них много различных способов сказать одно и то же. Перефразирование доступно только для проектов на русском и английском языке. При вводе тренировочной фразы нажмите в правой части поля, чтобы сгенерировать ее парафраз. Если вам не понравился результат, вы можете попробовать еще раз — исходная фраза будет перефразирована заново.', 'Метод возвращает целочисленные значения от 0 до max(не включая max), поэтому в качестве параметра укажем 100 и прибавим к получившемуся случайному значению 1. Запишем в тег script команду: В JS API переменная $session является объектом для сохранения сессионных данных. Присвоим переменной $session.number функцию случайного выбора числа. В дальнейшем будем сравнивать число, хранящееся в $session.number, с числом, введенным пользователем. Чтобы убедиться, что бот действительно загадывает числа в случайном порядке, выведем загаданное число на экран в виде сообщения Загадано \\*число\\*. Вставьте в скрипт следующую строку: Переходы по стейтам Переход в другой стейт осуществляется посредством вызова метода $reactions.transition. В параметре указывается путь к стейту /Проверка. Подробнее ознакомьтесь с использованием встроенных сервисов $jsapi и видах переменных в JS API Проверка Настройка интента Перейдите на вкладку CAILA > Интенты, расположенную в боковом меню. Создайте интент /Число и добавьте в поле Тренировочные фразы фразу @duckling.number, чтобы бот мог распознать введенное пользователем число и сохранить его. Интент число Выполнение условия Переменная $parseTree.\\_Number представляет собой число, которое ввел пользователь. Создадим отдельную переменную num. Присвоим ей значение, полученное в стейте Согласие из слота Number. Далее с помощью условного оператора if/else сравниваем загаданное значение с введенным. Если числа равны, то бот выдаст сообщение Ты выиграл!', 'Изменение веса паттернов Если вы реализуете в сценарии NLU на паттернах, вы можете принудительно изменять вес совпадения запросов с паттернами или их отдельными элементами. Это может быть полезно в следующих случаях: Запрос совпадает с несколькими различными паттернами. В сценарии необходимо явным образом указать, какой из паттернов является приоритетным, чтобы присваивать ему больший вес. Необходимо пометить какой-либо элемент паттерна как нежелательный, чтобы при совпадении по этому элементу вес становился ниже порогового значения классификатора и запрос не попадал в стейт. Рекомендуем использовать данную возможность с осторожностью. Если слишком часто изменять вес паттернов, поведение классификатора становится менее предсказуемым и управляемым. $weight Чтобы изменить вес паттерна, используйте элемент $weight. Этот элемент может использоваться после тегов q и q!, а также при объявлении именованных паттернов при помощи тега patterns. Варианты записи $weight: $weight&lt;a> $weight&lt;a+b> $weight&lt;a-b> $weight&lt;+b> $weight&lt;-b> Вес паттерна изменяется по формуле: $$ S = S \\\\cdot a + b $$ где $S$ — итоговый вес паттерна, $a$ и $b$ — значения, заданные в $weight. $a$ и $b$ могут быть произвольными вещественными числами. Отличия параметров $a$ и $b$: $a$ изменяет значение веса линейно, то есть умножает в $a$ раз. $b$ сдвигает значение веса на константное значение, то есть прибавляет к нему $b$.', 'От http-запроса Завершен успешно делаем новый http-запрос, в котором отправляем значение true в нужную ячейку. Это будет значить, что на эту дату столик будет занят. Чтобы отправить данные в нужную ячейку, нужно создать апплет через IFTTT. Вам нужно пройти шаги, которые описаны в этой инструкции до шага 9. На шаге 9 у вас должны быть такие настройки: В итоге настройки апплета будут выглядеть так: Drive folder path - укажите папку на вашем Google диске. Например, можете в корне Google диска создать папку под названием ""Work"" и тогда в поле Drive folder path вам нужно просто указать Work. Spreadsheet name - переместите в созданную папку на Google диске Google Таблицу, которую вы заполняли в этом уроке. Укажите в поле Spreadsheet name название таблицы. Which cell? - Value1 Value - Value2 После этого перейдите на https&#x3A;//ifttt.com/maker_webhooks, нажмите Documentaion и заполните эту ячейку названием ивента: Чтобы протестировать, вы можете в поле value1 ввести значение ячейки какой-нибудь не отмеченной флажком ячейки, например, E2. В value2 напишите: true И нажмите Test It. После этого в соответствующей ячейке должна появиться галочка: И скопируйте получившуюся ссылку: В инструкции вы должны были получить адрес вебхука. После того, как мы получили нужный адрес, куда мы можем отправить данные, сделаем такой запрос: метод POST URL - полученная выше ссылка BODY: { ""value1"": ""$cell"", ""value2"": ""true""} То есть, отправляем в определенную ячейку значение true.', 'q Тег активации q задает паттерн, по которому диалог может попасть в стейт. Это локальный тег: переход по нему возможен только из ближайшего родительского, из соседних или дочерних стейтов. Значение После тега записывается паттерн. Подробнее о синтаксисе паттернов вы можете узнать в разделе Паттерны. Параметры Примеры использования', 'Настройка конфигурационного файла Создайте конфигурационный файл бота chatbot.yaml и укажите следующие параметры: В этом туториале мы будем использовать процесс дозапроса информации слот-филлинг, поэтому настроим параметры его прерывания: maxSlotRetries — количество попыток для одного слота. Если клиент ответил указанное количество раз, и слот не был заполнен, процесс слот-филлинга будет прерван. Последняя фраза клиента будет обработана в сценарии бота. Установим две попытки. В дальнейшем, когда будем настраивать заполнение слотов, именно столько фраз будет использовано в поле Вопросы. stopOnAnyIntent — параметр прерывания процесса слот-филлинга по интенту. Если stopOnAnyIntent: true, то интент будет прерван тогда, когда пользователь захочет обработать другой интент. В нашем сценарии не предусмотрены случаи, когда нужно прервать интент со слот-филлингом по другому интенту. Поэтому установим stopOnAnyIntent: false. stopOnAnyIntentThreshold — параметр соответствия, задающий минимально необходимую похожесть фразы на один из классов. Является параметром прерывания процесса слот-филлинга по интенту. В ходе разработки NLU-сервиса было эмпирически определено, что оптимальное значение этого параметра 0.2. Теперь перейдем к разработке сценария бота.', 'Между подключением модуля слот-филлинга и объявлением корневой темы добавьте блок init, в котором установите обработчик postProcess: В данном случае: bargeIn: ""forced"" означает, что в случае прерывания бот не договаривает реплику до конца и прерывается сразу; bargeInTrigger: ""interim"" — режим прерывания с промежуточными результатами распознавания; установка времени noInterruptTime в 1 000 миллисекунд значит, что в течение 1 секунды после начала ответа перебить бота нельзя. Это полезно для защиты от случайных шумов. Подробнее о параметрах прерывания Обработчик postProcess в данном случае привязан к корневой теме, то есть ко всем стейтам сценария. Для более тонкой настройки перебивания воспользуйтесь методом $dialer.bargeInResponse. Воспроизведение аудио В качестве ответа бота можно использовать предзаписанные аудиофайлы — например, чтобы вместо синтезированной речи использовать записи диктора. Для вывода используется тег audio. Аудиофайлы должны удовлетворять ряду требований. Допустим, что записана реплика Кажется, проблемы со связью, а аудиофайл размещен по адресу https&#x3A;//example.com/comms-issue.wav. Тогда в стейте /NoInput замените строку на Перейдем к тестированию разработанного сценария.', '$gpt.createChatCompletion Встроенный сервис $gpt позволяет обращаться к ChatGPT от OpenAI из сценария бота. Метод $gpt.createChatCompletion реализован на основе метода OpenAI, который возвращает ответ LLM-модели gpt-3.5-turbo на заданную фразу. Вы можете использовать его, например, чтобы генерировать ответы на нераспознанные фразы пользователей. Синтаксис Метод принимает следующие аргументы: В документации OpenAI вы можете ознакомиться с примерами запросов. Метод возвращает ответ в следующем формате: Особенности При вызове метода происходит списание MLP-токенов. Они не равны токенам OpenAI. Количество потраченных MLP-токенов зависит от запроса. Когда лимит MLP-токенов будет исчерпан, метод выбросит исключение GptAi limit exhausted, которое вы сможете обработать в сценарии. Чтобы пополнить лимиты, приобретите дополнительный пакет MLP-токенов. Использование в сценарии Чтобы бот отвечал на нераспознанные фразы пользователя с помощью ChatGPT, вызовите $gpt.createChatCompletion в стейте для обработки этих фраз:']"	К сожалению, в документации не указано о наличии параметра sts или другого способа управления порогом распознавания паттернов в проекте. Возможно, в настоящее время такой функциональности нет. Рекомендую обратиться к разработчикам или технической поддержке для получения более точной информации по данному вопросу.	0.0	0.8865465227981373	0.5888888888692593
Други! Бот на JAICP. По ходу диалога нужно получить от пользователя календарную дату. Ещё лучше заставить пользователя щёлкнуть дату из календарика. Не умею как..	"['\'у нас робот просто спрашивает желаемый день доставки. дальше применяем системную сущность дата, изучали по документации при этом работает и ""25 мая"", и ""понедельник"", и ""завтра""  Про выбор из календарика в документации ничего нет, но выбор чего-либо можно реализовать на кнопках\'']"	['Блок Случайный ответ', 'Пример Рассмотрим пример создания и отмены будильника.', 'Протестируйте сценарий бота.', 'Пример ответа:', 'Разберитесь со структурой сценария Протестируйте бота.', 'Протестируйте сценарий.', 'Протестируйте бота.', ':)', 'Предварительно зададим сущность @Yes в справочнике укажем набор паттернов: Сценарий: В качестве ответа будет передан JSON:', 'Примеры строк']	К сожалению, в документации нет информации о том, как получить от пользователя календарную дату или заставить пользователя выбрать дату из календаря. Пожалуйста, уточните вопрос или переформулируйте его.	0.0	0.8140270471271652	0.0
Подскажите, пожалуйста, есть ли какой-то красивый и удобный способ извлечь имя именованного паттерна, в который проматчилась та или иная фраза, из $parseTree? Пробовали через $parseTree.pattern, но выдаётся только корневой - root) можно циклом пройтись, конечно, но вдруг есть встроенный метод специальный)) как с $context.intent.path)) заранее благодарю))	"[""'Метод $nlp.match возвращает объект NLPResult, который содержит указание на сработанный паттерн, стейт и объект parseTree.'""]"	"['Объявите именованный паттерн при помощи специального элемента $entity, после которого в угловых скобках записывается название справочника, а как атрибут после || — имя конвертера: Использование Рассмотрим пример стейта, который будет срабатывать на запросы с упоминанием сущности $city: При попадании в данный стейт, например, по запросу мой регион Санкт Петербург в $parseTree будет доступна информация по сущности: По ключу &lt;имя\\_паттерна> доступна подробная информация по всем распознанным сущностям, а по ключу \\_&lt;имя\\_паттерна> — значение value первой распознанной сущности. Значение value отличается в зависимости от того, задан ли для сущности конвертер: Если конвертер задан, берется значение, которое возвращает конвертер. Если конвертер не задан, записывается только идентификатор сущности.', 'Для этого тоже можно создать решение. Добавьте новый интент и нажмите на : Нажмите Создать интент: Скопируйте и вставьте в поле интента следующее выражение: \\* меня \\* зовут $TEXT::isname Нажмите Добавить пример. Не закрывайте это окно, чтобы потом добавить еще несколько примеров. С помощью этого интента вы принимаете в $TEXT все, что будет написано после фразы «меня зовут». $TEXT — системная сущность, которая принимает любой текст. После $TEXT ставится два двоеточия — это будет означать, что все, что попало в $TEXT, будет записываться в переменную. В данном случае создается переменная $isname, которую вы будете использовать позже. Скопируйте и добавьте следующие строки: \\* зови\\* \\* меня $TEXT::isname — этот шаблон будет принимать любые слова + зовите меня имя и любые слова + зови меня имя \\* ну \\* пусть \\* будет $TEXT::isname \\* наверное $TEXT::isname \\* имя $TEXT::isname \\* хорошо $TEXT::isname \\* зовут $TEXT::isname \\* ладно $TEXT::isname \\* я $TEXT::isname Вот что у вас должно получиться: Данные строки являются шаблонами фраз клиента, которыми клиент может ответить на сообщение бота. С помощью этих шаблонов вы делаете так, чтобы в имя не попадали лишние слова. То есть, отсекаются разные незначительные слова, которые могут быть введены клиентом одновременно с именем. Одновременно с этим не придется говорить владельцам необычных имен, что их имена неизвестные. В дальнейшем вы можете добавить больше таких примеров.', 'Подробнее об именованных сущностях Использование в сценарии Объявление именованного паттерна: Использование в сценарии: Здесь RoamingRegions — название справочника, RoamingRegionTagConverter — название конвертера. При подобном объявлении именованного паттерна в $parseTree появляется элемент value, куда обычно записывается id или значение из справочника. Правило $entity записывает в value только идентификатор сущности, а список ассоциированных значений содержится в справочнике. $Pattern::Alias $Pattern::Alias — позволяет задать псевдоним для токена, под которым токен будет помещен в $parseTree. Использование в сценарии Рассмотрим пример $Number::Hour: паттерн $Number будет интерпретироваться в parseTree как Hour. Сценарий: Запрос пользователя: Дерево разбора: Дерево разбора без использования псевдонима для сценария q! : я приду в $Number имеет вид: Практичный прием использования $Pattern::Alias: Здесь смысл $Number зависит от положения в запросе: вычитаемое может быть названо первым или вторым числом. (один:1 | два:2 …\u200b) (один:1 | два:2 …\u200b) — соответствие различных семантик, позволяет задать значение для той или иной фразы. Указанное значение записывается в поле value для $parseTree того паттерна, в котором соответствие объявлено.', 'И, наконец, добавим еще одну строку: $TEXT::isname Данная строка будет отрабатывать только в том случае, если ни один из других примеров не отработал. Введенное на данном экране сообщение клиента будет попадать в нее полностью. Этот $TEXT нам нужен на случай, если клиент добавил необычное имя одним словом. По умолчанию, когда вы переходите в редактирование блока Интенты и начинаете добавлять строки, они добавляются как примеры фраз, а не как шаблоны. Об этом свидетельствует иконка . Нажмите Сохранить. Теперь можно удалить экран с текстом Вас правда зовут $queryText?, так как у вас есть сущность $TEXT, которая будет принимать любую строку. Если в интентах есть $TEXT, то ветка Любая другая фраза отрабатывать не будет. Далее нам нужно сделать связь от интента \\* меня \\* зовут $TEXT::isname и создать блок Условия: В блок Условия вставьте следующее выражение: $name = $NAME ? $NAME.name : $isname С помощью этого условия вы создаете переменную $name. = — это оператор языка программирования JavaScript, с помощью которого присваивается значение переменной $name. Далее идет логическое выражение. Если у вас ранее что-то попало в системную сущность $NAME, то переменная $NAME.name будет записываться в переменную $name. Если же в системную сущность $NAME ничего не попало, то в $name запишется значение $isname. В итоге в переменной $name окажется имя из словаря или принятое необычное имя.', 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.', 'В Aimylogic мы пишем переменные используя $, а затем имя переменной. Регистр имеет значение - переменные $number и $NUMBER - это разные переменные. | Подробнее о переменных читайте здесь. На вкладке RESPONSE нажмите +. Скопируйте и вставьте в поля: Имя переменной: num В поле Значение скопируйте и вставьте: parseInt($httpResponse) Что здесь происходит? После HTTP запроса Aimylogic сохраняет ответ сервиса random.org в системную переменную $httpResponse. Но сервис random.org возвращает текст, а нам нужно целое число, чтобы мы могли сравнивать с ним число пользователя (строка и число - разные типы данных в Javascript). Поэтому нам нужно сначала преобразовать текстовый ответ сервиса в целое число. Для этого в Javascript есть функция parseInt, которой мы и воспользуемся. Передадим в функцию parseInt весь ответ от сервиса - так мы преобразуем строку в число. Затем мы записываем это значение в переменную, которую указали в поле ?? и сохраним его в переменную $num. Поля BODY и HEADERS заполнять не нужно. Нажмите Сохранить Назовем этот экран: запрос А теперь угадывай! Бот получил случайное число. Теперь бот должен вывести пользователю сообщение о том, что число загадано, и пригласить пользователя угадать число. Кликните на вариант Завершен успешно блока HTTP-запрос и создайте блок Текст. В нем напишите: Я загадал число от 1 до 100. Угадай, какое!', 'Метод возвращает целочисленные значения от 0 до max(не включая max), поэтому в качестве параметра укажем 100 и прибавим к получившемуся случайному значению 1. Запишем в тег script команду: В JS API переменная $session является объектом для сохранения сессионных данных. Присвоим переменной $session.number функцию случайного выбора числа. В дальнейшем будем сравнивать число, хранящееся в $session.number, с числом, введенным пользователем. Чтобы убедиться, что бот действительно загадывает числа в случайном порядке, выведем загаданное число на экран в виде сообщения Загадано \\*число\\*. Вставьте в скрипт следующую строку: Переходы по стейтам Переход в другой стейт осуществляется посредством вызова метода $reactions.transition. В параметре указывается путь к стейту /Проверка. Подробнее ознакомьтесь с использованием встроенных сервисов $jsapi и видах переменных в JS API Проверка Настройка интента Перейдите на вкладку CAILA > Интенты, расположенную в боковом меню. Создайте интент /Число и добавьте в поле Тренировочные фразы фразу @duckling.number, чтобы бот мог распознать введенное пользователем число и сохранить его. Интент число Выполнение условия Переменная $parseTree.\\_Number представляет собой число, которое ввел пользователь. Создадим отдельную переменную num. Присвоим ей значение, полученное в стейте Согласие из слота Number. Далее с помощью условного оператора if/else сравниваем загаданное значение с введенным. Если числа равны, то бот выдаст сообщение Ты выиграл!', 'Расширенные элементы паттернов $pattern_name $название-паттерна — ссылка на именованный паттерн. Подробнее об именованных паттернах Использование в сценарии Объявление паттерна: Использование паттерна в сценарии: ~lemma ~lemma проверяет все формы слова. Слово после тильды должно стоять в словарной форме. Например, в паттерн ~яблоко попадут слова: яблоки, яблок и др. Правило срабатывает на всех словоформах всех омонимов: слов, которые звучат и пишутся одинаково, но имеют разные значения или морфологическую форму. Например, паттерн ~печь сработает на словоформах существительного печь (печи, печью) и глагола печь (пеку, печешь). Из-за морфологического разнообразия языка использование этого паттерна может приводить к ложноположительным результатам. Использование в сценарии $morph Элемент $morph&lt;свойство> проверяет совпадение по слову с определенными грамматическими свойствами. Список поддерживаемых свойств зависит от того, какой диалоговый движок использует проект. botEngine: v1 На первой версии диалогового движка для морфологического анализа используется парсер AOT. Используйте для грамматических свойств условные обозначения для русского и английского языка. Указывайте их внутри угловых скобок через пробел. Кроме того, на этой версии $morph позволяет проверить совпадение по одному или сразу по нескольким свойствам.', 'Вот что получится в нашем случае: Нажмите Сохранить изменения и вернитесь на вкладку Сценарий. Найдите в вашем сценарии экран, на котором есть блок Текст, содержащий $items.current().question. Добавьте на этот экран блок Интенты. Скопируйте и вставьте в этот блок интент $answers. Вы также можете добавить в интенты такой шаблон: Если будете использовать этот шаблон, не забудьте поставить пробелы между $answers и звездочками: звездочка, пробел, $answers, пробел, звездочка. Этот шаблон позволит нам принимать ответ, даже если он окружен другими словами. Например, если на вопрос ""Сколько будет дважды два?"" пользователь ответит ""Ну, четыре, я думаю"" – благодаря этому шаблону бот сможет также принять этот ответ. Подробнее о синтаксисе шаблонов читайте в этой статье. Нажмите Сохранить. Вот что у нас получилось: Кликните на интент $answers и создайте блок Условия. Скопируйте и вставьте в него: $answers == $items.current().answer Здесь мы сравниваем ответ, который содержится в справочнике сущностей, с ответом из таблицы. == это оператор сравнения языка Javascript. Можете почитать о нем подробнее здесь. От условия $answers == $items.current().answer сделайте связь со следующим экраном и добавьте блок Текст. Скопируйте и вставьте на него: Да, это правильный ответ! Добавьте сюда еще один блок Текст: А вот подробный ответ: $items.current().link В этом блоке мы выводим соответствующую ссылку из таблицы, используя встроенную функцию Aimylogic current().', '$integration.customRequest Метод позволяет выполнить произвольный запрос к любому методу, который поддерживается на стороне API интеграции, подключенной к проекту. Метод функционально схож с методом $http.query для выполнения HTTP-запросов. Используйте вместо него $integration.customRequest для обращения к API, имеющим отдельную интеграцию на стороне платформы. Синтаксис Принимаемые аргументы Метод принимает 5 обязательных аргументов. Возвращаемое значение Метод возвращает объект со следующими полями. Примеры использования Рассмотрим примеры того, как вызывать при помощи $integration.customRequest методы API для работы с таблицами Google. В примерах предположим, что идентификатор интеграции и таблицы сохранены в переменных integrationId и spreadsheetId соответственно. Подробное описание методов Google Sheets API Чтение данных из ячеек Для чтения данных воспользуемся методом spreadsheets.values.get. Получим данные из ячейки A1 на первом листе: Если первый лист называется Sheet1, а ячейка содержит значение Привет, метод вернет следующий объект: Поле responseBody содержит тело ответа от API в виде строки. Не забудьте использовать метод JSON.parse, чтобы преобразовать его в объект и извлечь необходимые данные. Запись данных в ячейки Воспользуемся методом spreadsheets.values.update, чтобы обновить существующие данные в ячейках таблицы. При успешном вызове метода значение ячейки A1 будет заменено на Пока.']"	"В документации нет информации о специальном методе для извлечения имени именованного паттерна из $parseTree. Однако, вы можете использовать цикл для обхода $parseTree и проверки каждого элемента на наличие имени паттерна. Вот пример кода на JavaScript, который может помочь вам реализовать это:

```javascript
function getPatternName(parseTree) {
  let patternName = null;
  parseTree.forEach((element) => {
    if (element.name && element.name.startsWith(""$"") && !element.name.startsWith(""$root"")) {
      patternName = element.name.substring(1);
    }
  });
  return patternName;
}

const patternName = getPatternName($parseTree);
```

Вызов функции `getPatternName($parseTree)` вернет имя именованного паттерна, если такой существует в $parseTree. Пожалуйста, обратите внимание, что это пример реализации, и вам может потребоваться настроить его под свои потребности."	1.0	0.9107143699605466	0.9999999999
Есть ли возможность в JAICP в тестах эмулировать перебивание голосового бота? такой возможности я не нашла, но, может, просто невнимательно читала доку )	"[""'Если клиент перебьет бота во время произнесения фразы, для которой задан параметр bargeInIf, в сценарии сработает событие bargeInIntent, которое необходимо обработать в отдельном стейте. События можно обработать в xml тестах'""]"	"['Такой подход может быть неэффективен, например, в условиях фонового шума либо если клиент при прослушивании активно использует речевые маркеры восприятия речи («ага», «ясно», «понятно»). Они не требуют ответной реакции, однако бот вынужден прерываться, чтобы обработать такие фразы. Для решения этой проблемы используйте возможность перебивания по условию, которая позволяет определить из сценария, в каких случаях бот должен обработать перебивание, а в каких нет. Рассмотрим пример ниже. bargeInIf Параметр bargeInIf после тега a или audio включает условное перебивание для фразы. Значением параметра является метка условного перебивания — строка с любой необходимой справочной информацией. bargeInIntent Если клиент перебьет бота во время произнесения фразы, для которой задан параметр bargeInIf, в сценарии сработает событие bargeInIntent, которое необходимо обработать в отдельном стейте. Само по себе возникновение этого события не заставит бота прерваться — бот продолжит ответ и одновременно запустит обработчик события. В результате выполнения обработчика бот должен определить, действительно ли ему нужно прерваться или же проигнорировать попытку его перебить. Для решения этой задачи в обработчике события bargeInIntent доступны следующие методы: $dialer.getBargeInIntentStatus — метод для получения метки условного перебивания и текста запроса, которым клиент пытался перебить бота.', '&lt;mockData> Описание Тег &lt;mockData> позволяет задать заглушки ответов (мок-объекты) на HTTP-запросы из сценария бота. Когда при выполнении тестов в сценарии вызывается метод $http.query или его аналоги (например, $http.get), система проверяет, предусмотрен ли в тесте соответствующий тег &lt;mockData> с такими же параметрами и телом, с какими выполняется HTTP-запрос. Если такой тег существует и указанные в нем URL и тело запроса в точности совпадают с ожидаемыми, то система использует ответ, указанный в &lt;mockData>, в качестве тела HTTP-ответа, полученного в результате вызова метода. Если в сценарии есть вызов $http, для которого в тесте нет подходящего элемента &lt;mockData>, HTTP-запрос будет принят за неудачный и не вернет данных в ответе. Из-за этого тест, вероятнее всего, будет провален. Реальные HTTP-запросы при выполнении автоматических тестов не выполняются. Это поведение можно переопределить. Передайте с тегом &lt;test> или &lt;test-case> атрибут integration=""true"", чтобы при запуске теста или тест-кейса выполнялись HTTP-запросы. В таком случае &lt;mockData> можно не указывать. Если вы используете атрибут integration=""true"" и достаточно часто запускаете автоматические тесты, то реальные запросы могут быстро исчерпать квоты на использование или иметь другие нежелательные побочные эффекты во внешних системах.', 'Перебивание бота Перебивание (англ. barge-in) — возможность телефонного канала, позволяющая абонентам прерывать речь собеседника, не дожидаясь, пока тот закончит говорить. Использование перебивания в проектах голосовых ботов позволяет им воспринимать запросы клиентов в реальном времени и оперативно на них реагировать. Это делает разговор более живым и стимулирует вовлеченность клиента в диалог. Параметры перебивания Для того чтобы включить перебивание, вызовите в нужном стейте метод $dialer.bargeInResponse с нужными настройками перебивания. Если произойдет перебивание, ответ бота будет прерван, а запрос клиента будет обработан в контексте данного стейта. Рассмотрим пример: Если клиент не дослушает и перебьет бота вопросом «Что?», бот прервется и отреагирует на вопрос. Метод $dialer.isBargeInInterrupted позволяет определить, был ли прерван ответ бота. Контекстное перебивание При зачитывании длинных последовательностей фраз вы можете настроить перебивание так, чтобы контекст перебивания отличался в зависимости от того, на какой фразе клиент перебил бота. Для настройки контекстного перебивания используются параметры тегов реакций a или audio, которые передаются через разделитель || после тела тегов. Рассмотрим синтаксис на следующем примере. bargeInTransition Параметр bargeInTransition задает путь до стейта, в который будет перенаправлен бот при перебивании. Путь задается в том же формате, что и после тега реакции go.', '$dialer.bargeInInterrupt Метод позволяет задать поведение бота при перебивании по условию. Метод работает корректно только в обработчике события перебивания по условию — bargeInIntent. Синтаксис Метод принимает в качестве аргумента значение логического типа — true или false. Передача true означает, что условие перебивания выполнено. После того как обработчик события bargeInIntent завершит выполнение, бот прервется, чтобы обработать поступивший запрос. Если передано значение false, условие перебивания не выполнено. Бот не прервется и обработает поступивший запрос после того, как закончит выполнение реакций в текущем стейте. Отсутствие вызова $dialer.bargeInInterrupt в обработчике события bargeInIntent равносильно вызову метода со значением false. Использование в сценарии Метод используется совместно с методом $dialer.getBargeInIntentStatus, чтобы задать поведение в случае, если клиент пытается перебить бота. Если клиент произносит осмысленную фразу, явно передающую его намерение, в обработчике вызывается метод $dialer.bargeInInterrupt с аргументом true, чтобы бот прервался. В противном случае попытка перебить бота игнорируется — обработка запроса происходит лишь после того, как бот закончит ответ.', '$dialer.bargeInInterrupt — метод для задания поведения бота: должен ли бот прерваться, чтобы обработать запрос, или нет. Таким образом, в примере выше клиент сможет перебить прощание бота, только упомянув в запросе слово «оператор». Используйте метод $nlp.matchPatterns для динамического сопоставления текста запроса паттернам, чтобы задать более сложную логику классификации запросов на перебивание бота. Зависимость от bargeInTrigger Обратите внимание, что условия срабатывания события bargeInIntent отличаются в зависимости от того, какое значение присвоено полю bargeInTrigger при настройке перебивания. При использовании значения interim событие срабатывает при каждом промежуточном результате распознавания. Большое число вызовов обработчика события могут существенно увеличить потребляемые ресурсы и замедлить работу бота. Рекомендуется использовать для перебивания по условию только значение final, при котором событие возникает после получения окончательного результата распознавания.', 'Между подключением модуля слот-филлинга и объявлением корневой темы добавьте блок init, в котором установите обработчик postProcess: В данном случае: bargeIn: ""forced"" означает, что в случае прерывания бот не договаривает реплику до конца и прерывается сразу; bargeInTrigger: ""interim"" — режим прерывания с промежуточными результатами распознавания; установка времени noInterruptTime в 1 000 миллисекунд значит, что в течение 1 секунды после начала ответа перебить бота нельзя. Это полезно для защиты от случайных шумов. Подробнее о параметрах прерывания Обработчик postProcess в данном случае привязан к корневой теме, то есть ко всем стейтам сценария. Для более тонкой настройки перебивания воспользуйтесь методом $dialer.bargeInResponse. Воспроизведение аудио В качестве ответа бота можно использовать предзаписанные аудиофайлы — например, чтобы вместо синтезированной речи использовать записи диктора. Для вывода используется тег audio. Аудиофайлы должны удовлетворять ряду требований. Допустим, что записана реплика Кажется, проблемы со связью, а аудиофайл размещен по адресу https&#x3A;//example.com/comms-issue.wav. Тогда в стейте /NoInput замените строку на Перейдем к тестированию разработанного сценария.', 'Например, если у вас есть столбец name, то в блокноте у вас получится:$rawRequest.originateData.payload.name Ниже пример таблицы и значений $rawRequest: :size=400 Системную переменную с названием нужной колонки используйте в блоке Текст: :size=400 В данном случае при звонке на номер 79105555555 бот скажет: ""Здравствуйте, Саша!"". А при звонке на номер 79995555555 бот скажет ""Здравствуйте, Алекс!"" Почему при тестировании возникает ошибка? После того, как вы используете перечисленные выше значения $rawRequest в сценарии, при тестировании в тестовом виджете вы будете получать ошибку, так как информацию из таблицы можно доставать только из телефонного канала. :size=400 Поэтому мы рекомендуем добавлять значения $rawRequest для вывода имени тогда, когда вы уже готовы запустить обзвон. Извлекать имя пользователя и другую информацию из таблицы с номерами можно только в процессе обзвона. В тестовом виджете это работать не будет. Если вы в данный момент находитесь в процессе тестирования сценария и вам нужно тестировать стороннюю функциональность, отложите использование $rawRequest до того этапа, когда сможете запускать обзвон и тестировать в телефонном канале. Примеры содержания $rawRequest В текущей таблице переменная $rawRequest содержит следующие данные: После ответа пользователя $rawRequest будет также содержать текст сообщения пользователя:', 'capitalize Встроенная функция capitalize преобразует первую букву переданной строки в заглавную, но также имеет дополнительное поведение: она приводит к верхнему регистру первые буквы всех частей строки, разделенных дефисом, а все остальные символы приводит к нижнему регистру. Это поведение подходит не для всех случаев, поэтому теперь оно конфигурируется отдельным аргументом и может быть отключено. Обновления документации Мы переработали документацию по использованию мок-объектов в XML-тестах при помощи тега &lt;mockData>. Надеемся, что она поможет вам писать качественные тесты на сценарии сложных ботов!', '$imputer.cacheAudio Метод $imputer.cacheAudio позволяет кэшировать реплику на сервере: на один час или навсегда. Вызов этого метода может потребоваться, чтобы избежать задержек — пауз во время диалога бота с абонентом. Реплику нужно кэшировать заранее — перед ее использованием в сценарии. Предусмотрите стейт в вашем сценарии, где это можно сделать. Синтаксис Метод $imputer.cacheAudio принимает аргументы: Если вы хотите, чтобы реплика была кэширована, аргументы replicaTemplateId, variables, voiceSpeed, переданные для метода $imputer.cacheAudio, должны совпадать с теми, что вы передаете для $imputer.generateAudioUrl. Примеры вызова Пример использования В этом примере реплики без переменных также были использованы в сценарии при помощи вызова метода $imputer.generateAudioUrl. Это было сделано, чтобы избежать разницы в звучании реплик: c переменными и без. Подробнее см. в разделе Гибридный синтез от Just AI.', 'Для этого нажмите Остановить тест: И затем снова нажмите Тестировать. Попробуйте вводить другие имена, чтобы убедиться, что бот работает. Если вы вносили любые изменения в сценарий — например, отредактировали фразу — вам нужно перезапускать тестирование таким же образом. Если клиент напишет что-то, что не попадет в единственный добавленный интент Имена, то, так как других интентов у вас не добавлено, бот пойдет по ветке Любая другая фраза. Так как в данный момент ветка Любая другая фраза ни с чем не связана, бот будет отвечать по умолчанию фразой Извините, непонятно. Чтобы бот каждый раз, когда получает в ответ не популярное имя из списка, а что-то другое, не отвечал Извините, непонятно, свяжите интент Любая другая фраза с новым блоком Текст и напишите в нем фразу: Вас правда зовут $queryText? $queryText — системная переменная, которая будет содержать полный текст текущего запроса клиента. В данном случае это текст, попавший в блок Интенты. Теперь все, что не попадет в интент Имена, будет переводить бота по ветке Любая другая фраза. Любая другая фраза будет вести на блок Текст, где выводится введенный клиентом текст с помощью системной переменной $queryText. Нажмите Тестировать и введите любой текст, чтобы проверить: Интент Имена принимает не только одно слово — имя — но и умеет распознавать имя внутри написанного клиентом предложения. Например: Распознавание необычных имен Что, если у клиента необычное, оригинальное имя — например, одно из редких иностранных имен?']"	В документации не указано о специфической возможности эмулировать перебивание голосового бота в тестах JAICP. Возможно, эта функциональность не предусмотрена. Рекомендуется обратиться к технической поддержке JAICP для более точной информации.	0.0	0.9476410162008756	0.8099999999838
Добрый день! Скажите может jaicp кешировать ответ на POST запрос к внешнему API? Я отправляю в запросе новые данные, а ответ приходит как на запрос для старых данных	"[""'Кэширование http-ответов осуществляется, если в $http.query передан флаг cachingRequired со значением true. При этом обязательна предварительная инициализация параметра кэша cacheTimeToLiveInSeconds через вызов $http.config'""]"	"['Здесь можно указывать данные в любом формате (JSON, XML, произвольный текст), а также добавлять переменные. Настройка тела HTTP-запроса В примере тело запроса указано в формате JSON. Бот автоматически подставит в тело запроса значения переменных $client.name и $client.age. При добавлении переменных в объект JSON необходимо учитывать, какой тип данных содержится в переменной. В примере переменная $client.name указана в кавычках, потому что она содержит данные строкового типа, а $client.age без кавычек, потому что содержит число. Обработка ответа В ответ на запрос сервер обычно возвращает данные, которые можно обработать или вывести клиенту. Для этого на вкладке Response вы можете указать, какие данные из ответа вы хотите сохранить в новые переменные. Например, по адресу https&#x3A;//api.forismatic.com/api/1.0/?method=getQuote&format=json&lang=ru сервер возвращает следующий ответ: JAICP сохраняет этот ответ в переменную $httpResponse. Поскольку это ответ в формате JSON, JAICP автоматически конвертирует его в JavaScript-объект, с которым сценарий может далее работать. Ответы в формате XML также конвертируются в JavaScript-объекты. Если же сервер вернул ответ в другом формате, он сохранятся в $httpResponse как строка без какой-либо обработки. Чтобы сохранить данные из определенного поля объекта, на вкладке Response укажите: Имя переменной. Значение будет сохранено в сценарии как $session.&lt;имя переменной>.', 'Отправка файлов $http.query позволяет отправлять файлы на внешний сервис. Для этого укажите в настройках запроса поля fileUrl и опционально fileName. Такому запросу автоматически устанавливается заголовок Content-Type со значением multipart/form-data. Запрос отправляется как HTML-форма с полем file, где закодировано содержимое файла в бинарном виде. Если fileName не указан, но fileUrl содержит название файла с расширением, будет взято оно. В противном случае именем файла будет случайный UUID. Типы данных запроса и ответа Чтобы указать тип данных, которые содержатся в запросе и ожидаются в ответе, используйте поле dataType. Обратите внимание на то, как оно взаимодействует с передаваемым HTTP-заголовком Content-Type. Возвращаемое значение Метод возвращает объект со следующими полями: Пример использования В следующем примере выполняется запрос к API сервиса OpenWeather, чтобы получить информацию о текущей погоде в запрашиваемом городе. Пример предполагает, что вы получили собственный ключ к API OpenWeather и сохранили его в проекте как токен OPENWEATHER_API_KEY. $http.query выполняет HTTP-запросы синхронно. Обработка запроса пользователя приостанавливается до тех пор, пока HTTP-запрос не вернет ответ. Во время обработки одного запроса можно выполнить не более 15 вызовов $http.query. При превышении этого лимита метод возвращает ответ со статусом -1 и ошибкой Callback limit reached.', 'Кэширование HTTP-ответов Сервис $http поддерживает кэширование ответов на HTTP-запросы. Если один и тот же запрос в течение некоторого времени выполняется несколько раз, $http может брать ответ из кэша вместо того, чтобы выполнять запрос повторно. Условия кэширования Кэширование работает, если соблюдены следующие условия: До выполнения HTTP-запроса в сценарии вызывается метод $http.config с полем cacheTimeToLiveInSeconds. Метод $http.query вызывается с параметром cachingRequired со значением true. Запрос является успешным — имеет код ответа от 200 до 299. Ответы на запросы с ошибкой не кэшируются. Повторные запросы имеют одинаковые значения полей method, url, headers, query, body, form и dataType. Если все условия выполнены, ответ на первый запрос будет сохранен в кэше. Последующие одинаковые запросы в течение cacheTimeToLiveInSeconds будут возвращать ответ из кэша. Пример использования Следующий пример иллюстрирует, что при сравнении объектов body и form учитывается их структура, а не форма записи. Здесь ответ на первый запрос будет получен от сервера, а на второй — взят из кэша.', 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get в url используйте ссылку, которую получили шагом выше на вкладке RESPONSE напишите название переменной: check и значение: \\_.findWhere($httpResponse, {""number"": 1}) где 1 - число, соответствующее порядковому номеру кода для соответствующего задания. В этом месте сценария, например, мы будем принимать за правильный ответ код 4444, который стоит в строке 1: Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный ли код. Он только делает запрос к url. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел код неверно. Поэтому мы будем проверять код на следующих шагах. Сам факт успешного завершения http-запроса не говорит о том, что введенный код был верным. Также, http-запрос получает информацию из соответствующей строки с помощью \\_.findWhere($httpResponse, {""number"": 1}) и записывает все, что есть в строке, которая соответствует номеру ""1"" в переменную $check. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите: Ошибка чтения кода $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи.', '&lt;mockService> Описание Тег &lt;mockService> позволяет задать заглушки ответов на запросы к методам интеграций с внешними сервисами. Подробнее о том, как создавать и использовать интеграции Тег выполняет ту же задачу, что тег &lt;mockData> для HTTP-запросов. Он задает фиктивные ответы, которые будут применяться при выполнении автоматических тестов сценариев, где используется сервис $integration. Когда при выполнении тестов в сценарии вызывается один из методов $integration, система проверяет, предусмотрен ли в тесте соответствующий тег &lt;mockService> с такими же параметрами, что переданы как аргументы при вызове метода. Если такой тег существует и его параметры совпадают с ожидаемыми, то система использует ответ, указанный в &lt;mockService>, в качестве ответа от внешнего сервиса. Таким образом, реальные запросы при выполнении автоматических тестов не выполняются. Выполнение реальных запросов к методам интеграций из автоматических тестов невозможно. Если в сценарии предусмотрен вызов метода $integration, но в тесте для него нет соответствующего тега &lt;mockService> с совпадающими параметрами, то возвращаемое значение метода будет null. Структура Элемент с тегом &lt;mockService> должен быть вложен в элемент &lt;test> и иметь атрибут id=""integration"". Элемент может иметь следующие дочерние элементы: &lt;service> — тип интеграции. В настоящий момент поддерживается только тип googleSheets. &lt;method> — проверяемый метод.', '&lt;mockData> Описание Тег &lt;mockData> позволяет задать заглушки ответов (мок-объекты) на HTTP-запросы из сценария бота. Когда при выполнении тестов в сценарии вызывается метод $http.query или его аналоги (например, $http.get), система проверяет, предусмотрен ли в тесте соответствующий тег &lt;mockData> с такими же параметрами и телом, с какими выполняется HTTP-запрос. Если такой тег существует и указанные в нем URL и тело запроса в точности совпадают с ожидаемыми, то система использует ответ, указанный в &lt;mockData>, в качестве тела HTTP-ответа, полученного в результате вызова метода. Если в сценарии есть вызов $http, для которого в тесте нет подходящего элемента &lt;mockData>, HTTP-запрос будет принят за неудачный и не вернет данных в ответе. Из-за этого тест, вероятнее всего, будет провален. Реальные HTTP-запросы при выполнении автоматических тестов не выполняются. Это поведение можно переопределить. Передайте с тегом &lt;test> или &lt;test-case> атрибут integration=""true"", чтобы при запуске теста или тест-кейса выполнялись HTTP-запросы. В таком случае &lt;mockData> можно не указывать. Если вы используете атрибут integration=""true"" и достаточно часто запускаете автоматические тесты, то реальные запросы могут быстро исчерпать квоты на использование или иметь другие нежелательные побочные эффекты во внешних системах.', '$integration.customRequest Метод позволяет выполнить произвольный запрос к любому методу, который поддерживается на стороне API интеграции, подключенной к проекту. Метод функционально схож с методом $http.query для выполнения HTTP-запросов. Используйте вместо него $integration.customRequest для обращения к API, имеющим отдельную интеграцию на стороне платформы. Синтаксис Принимаемые аргументы Метод принимает 5 обязательных аргументов. Возвращаемое значение Метод возвращает объект со следующими полями. Примеры использования Рассмотрим примеры того, как вызывать при помощи $integration.customRequest методы API для работы с таблицами Google. В примерах предположим, что идентификатор интеграции и таблицы сохранены в переменных integrationId и spreadsheetId соответственно. Подробное описание методов Google Sheets API Чтение данных из ячеек Для чтения данных воспользуемся методом spreadsheets.values.get. Получим данные из ячейки A1 на первом листе: Если первый лист называется Sheet1, а ячейка содержит значение Привет, метод вернет следующий объект: Поле responseBody содержит тело ответа от API в виде строки. Не забудьте использовать метод JSON.parse, чтобы преобразовать его в объект и извлечь необходимые данные. Запись данных в ячейки Воспользуемся методом spreadsheets.values.update, чтобы обновить существующие данные в ячейках таблицы. При успешном вызове метода значение ячейки A1 будет заменено на Пока.', 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get; в URL используйте ссылку, которую получили шагом выше. на вкладке RESPONSE напишите название переменной:userи значение:\\_.findWhere($httpResponse, {login: $entry}) вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный логин или нет. Он только делает запрос к URL. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел логин неверно. Поэтому мы будем проверять логин на следующих шагах. А сейчас же мы просто запрашиваем всю информацию из Google Таблиц. Также, http-запрос ищет в Google Таблицах введенный вами логин с помощью \\_.findWhere($httpResponse, {login: $loginentry}). Если логин присутствует в таблице, он помещает его в переменную $user. Но успешное завершение запроса вовсе не означает, что логин действительно был в таблице. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите:Ошибка чтения логина $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи. От варианта Завершен успешно сделайте связь с блоком Условие и напишите в него:$user Это условие будет проверять, записалось ли что-либо в переменную $user, то есть, был ли найден введенный пользователем логин.', 'Использование в сценарии Чтобы бот мог использовать ответы из CDQA, добавьте метод $caila.cdqaQuery в глобальный стейт для обработки нераспознанных запросов:', 'Ошибка, если сервер вернул любой другой ответ. Код ответа сохраняется в переменную $session.httpStatus.']"	Добрый день! В документации не указано, что JAICP поддерживает кэширование ответов на POST-запросы. Кэширование работает только для успешных запросов с кодом ответа от 200 до 299. Если вам приходит ответ для старых данных, возможно, стоит проверить, правильно ли формируются запросы и обрабатываются данные. Если проблема сохраняется, вам следует обратиться к разработчикам JAICP для получения более подробной информации или помощи.	0.5	0.8970084797193342	0.33333333331666665
не найду как подключать репощитории(	"[""'1) При создании проекта выберите Подключиться к Git-проекту. 2) В разделе Где будет размещаться проект выберите GitHub или Bitbucket. 3) Если вы делаете это в первый раз, откроется окно авторизации. Разрешите JAICP доступ к вашему аккаунту. 4) На странице создания проекта укажите настройки репозитория: - Рабочее пространство (только для Bitbucket). - Проект (только для Bitbucket). - Репозиторий. - Ветка.  Эта настройка определяет, содержимое какой ветки будет отображаться в редакторе кода и в J‑Graph. Однако в любом канале можно указать любую ветку.  После того как вы нажмете Создать проект, указанный репозиторий на GitHub или Bitbucket будет подключен к новому проекту.'""]"	['Подключите внешний NLU-сервис к проекту.', 'Подробнее о том, как подключить ваш аккаунт Viber к Битрис24', 'Подключение Viber для проекта на JAICF Чтобы подключить Viber для проекта на JAICF: Подготовьте проект. Подключите канал. Протестируйте бота. Подготовка проекта Перед подключением канала предварительно подготовьте проект JAICF: Укажите в файле build.gradle.kts в зависимостях настройки: Замените $jaicfVersion последней версией фреймворка. Сконфигурируйте в зависимости от способа подключения к платформе: long polling — бот будет сам подключаться к серверу Just AI при взаимодействии с платформой. Простое решение, подходит для локальной разработки и отладки. Для этого способа укажите в файле JaicpPoller.kt канал ViberChannel: webhook — по указанной ссылке бот будет принимать сообщения платформы. Необходимо конфигурировать для подключения в JAICP Cloud. Для этого способа укажите в файле JaicpServer.kt канал ViberChannel: Подключение канала Для подключения канала используйте инструкцию. Тестирование бота Перейдите в окно диалога с ботом в Viber и отправьте ему приветственную/активационную фразу, предусмотренную вашим сценарием. После этого должен начаться ваш диалог с ботом. Нативные возможности канала Использование данных из запроса В канале Viber можно получить из запроса дополнительные данные.', 'Настройки SIP-подключения Далее создайте новый проект с использованием NLU-ядра CAILA и переходите к разработке сценария.', 'Подробнее о процессе создания и настройки интентов', 'Кроме того, в настройках канала необходимо заполнить поле Сервисный ключ доступа.', 'Если вы хотите сначала разобраться с SIP-подключением, вы можете нажать Запустить позже и вернуться к этому сценарию по шаблону когда будете готовы.', 'Удалить подключение невозможно при наличии каналов, которые используют его.', 'Вам также может быть интересно Онлайн-чаты Как подключить блок Перевод на оператора Перевод на оператора Битрикс24', 'При подключении операторского канала ко входящему следует выбрать группу операторов.']	К сожалению, я не могу найти информацию о подключении репозиториев в предоставленной документации. Пожалуйста, уточните свой вопрос или переформулируйте его.	0.5	0.8201168944507388	0.0
Привет! Подскажите пожалуйста, какие форматы файлов пользователь может отправить в бот.	"[""'Список форматов зависит от канала и очень разнится'""]"	"['С помощью одного запроса можно передать сразу несколько переменных: Блок должен быть оформлен следующим образом: Метод GET Формирование URL Для создания URL скопируйте в блокнот строку: https&#x3A;//api.telegram.org/bot&lt;token>/sendMessage Затем перейдите в Telegram в канал BotFather и скопируйте токен вашего бота, который был сгенерирован, когда вы публиковали канал: В блокноте выделите &lt;token> И вместо &lt;token> вставьте токен из Telegram: Получится примерно следующий адрес: Теперь выделите строку целиком и вставьте ее в поле URL HTTP-запроса в Aimylogic Оформление поля BODY В BODY нам нужно указать: значение chat_id, которое мы получили ранее все переменные, которые мы до этого собрали в сценарии. Если вы повторили урок по сбору контактных данных, то в сценарии вы получили следующую информацию: Ваше имя: $name Ваша фамилия: $lastname Ваш телефон: $PHONE Ваш email: $EMAIL Вид услуги: $service Поэтому сейчас мы используем именно эти переменные. Итак, нужно вставить значение chat_id и перечислить переменные, которые были в сценарии до отправки. Обратите внимание на отступы и знаки препинания! Рекомендуем не набирать текст, а скопировать и вставить. { ""chat_id"": 123456789, ""text"": ""Имя клиента: $name $lastname, номер телефона: $PHONE, email: $EMAIL, Вид услуги: $service""} Нажмите Сохранить. Готово, мы оформили Http-запрос для отправки данных.', 'Отправка файлов $http.query позволяет отправлять файлы на внешний сервис. Для этого укажите в настройках запроса поля fileUrl и опционально fileName. Такому запросу автоматически устанавливается заголовок Content-Type со значением multipart/form-data. Запрос отправляется как HTML-форма с полем file, где закодировано содержимое файла в бинарном виде. Если fileName не указан, но fileUrl содержит название файла с расширением, будет взято оно. В противном случае именем файла будет случайный UUID. Типы данных запроса и ответа Чтобы указать тип данных, которые содержатся в запросе и ожидаются в ответе, используйте поле dataType. Обратите внимание на то, как оно взаимодействует с передаваемым HTTP-заголовком Content-Type. Возвращаемое значение Метод возвращает объект со следующими полями: Пример использования В следующем примере выполняется запрос к API сервиса OpenWeather, чтобы получить информацию о текущей погоде в запрашиваемом городе. Пример предполагает, что вы получили собственный ключ к API OpenWeather и сохранили его в проекте как токен OPENWEATHER_API_KEY. $http.query выполняет HTTP-запросы синхронно. Обработка запроса пользователя приостанавливается до тех пор, пока HTTP-запрос не вернет ответ. Во время обработки одного запроса можно выполнить не более 15 вызовов $http.query. При превышении этого лимита метод возвращает ответ со статусом -1 и ошибкой Callback limit reached.', 'Блок file to $var Блок file to $var позволяет боту получить от клиента любой файл, например, фотографию полученного товара, текстовый файл с данными юридического лица и т. п. Вы можете посмотреть пошаговую видеоинструкцию по использованию блока Получение файла: Как добавить блок Блок доступен через меню Добавить экран → Еще блоки → file to $var. Параметры В настройках блока вы можете указать: Сообщение клиенту с просьбой загрузить файл. Вы можете использовать HTML-разметку в параметре Сообщение. Для этого активируйте переключатель Использовать в сообщении HTML разметку. Не все каналы поддерживают HTML-разметку. Подробнее об этом вы можете прочитать в статье HTML-разметка сообщений. Имя переменной, в которую сохранится URL файла. Используйте символы Aa-Zz, \\_, 0-9. Имя переменной должно начинаться с Aa-Zz. Нельзя использовать зарезервированные слова языка JavaScript. Чтобы снизить возможную нагрузку на Aimylogic, мы ограничили допустимый размер загружаемых файлов до 50 Мб. Результат загрузки файла Вы можете самостоятельно решить, что будет происходить в диалоге после удачной загрузки файла или после ошибки загрузки. Для этого создайте связи с другими блоками для каждого результата загрузки файла.', 'Мы наконец подробно описали эти требования прямо в интерфейсе, чтобы вы точно знали, что ваш файл подходит для загрузки.', 'База данных В Aimylogic вы можете сохранять, читать и удалять любые данные, привязанные к пользователю бота. Запись данных Чтобы записать данные в базу данных: Создайте в сценарии блок HTTP-запрос. Выберите метод POST. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} Во вкладке BODY HTTP-запроса нужно указать JSON-объект, в котором вы можете указать любые данные, которые хотите сохранить. Например: { ""var1"": ""value"", ""var2"": 100, ""var3"": \\[1,2,3]} Вкладки RESPONSE и HEADERS заполнять не нужно. Пример HTTP-запроса Чтение данных Чтобы прочитать данные из базы данных: Создайте в сценарии блок HTTP-запрос. Выберите метод GET. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} На вкладке RESPONSE напишите название переменной, в которую вы будете записывать данные, и в поле значение пропишите нужное значение, например,$httpResponse. Вкладки BODY и HEADERS заполнять не нужно. Если никаких данных для этого пользователя найдено не будет, то запрос вернется с ошибкой 404. А если данные будут найдены, то в переменную $httpResponse будет записан тот объект, который ранее был сохранен в базу данных. Удаление данных Чтобы удалить все данные для текущего пользователя: Создайте в сценарии блок HTTP-запрос. Выберите метод DELETE. В поле URL скопируйте ссылку: https&#x3A;//tools.aimylogic.com/api/data/${userId} Вкладки RESPONSE, BODY и HEADERS заполнять не нужно.', 'file Чтобы отправить файл в чат с пользователем, используйте тип ответа file. Свойства Синтаксис Ограничения на каналы Поддерживается только в следующих каналах: Чат-виджет Chat API edna.chatCenter edna WhatsApp 2.0 Microsoft Teams Для отправки файлов в канале Microsoft Teams рекомендуется использовать ответы с типом raw. Webim (External Bot API 2.0) Использование в сценарии', 'Конфигурационный файл chatbot.yaml chatbot.yaml — конфигурационный файл чат-бота. Файл содержит основную информацию о конфигурации проекта, например: имя главного файла сценария; данные о подключаемых зависимостях; конфигурацию NLU; перечень файлов с тестами. В данном разделе перечислены настройки, которые можно задать в chatbot.yaml, и их назначение. Подробнее о синтаксисе YAML Точка входа в сценарий Поле используется для указания файла, с которого начинается загрузка сценария чат-бота при публикации. Файл должен находиться в папке src и обычно называется main.sc или entryPoint.sc. Если код сценария состоит из нескольких файлов, все необходимые файлы должны быть прямо или опосредованно импортированы в основной файл. Для этого используйте тег require. entryPoint — обязательное поле. Имя бота Поле задает имя бота, которое будет использовано, например, в сообщениях о публикации бота в канал. Если поле отсутствует, в качестве имени используется системное название проекта. Настройки NLU Диалоговый движок Поле задает версию диалогового движка бота. Движок второй версии v2 позволяет использовать для понимания естественного языка (NLU) сервис CAILA. Это рекомендуемое значение поля для всех новых проектов. Если поле отсутствует или значение поля отличается от v2, будет использован движок первой версии v1. NLU на этом движке возможен только при помощи паттернов. Язык бота Поле задает язык, на котором общается бот. Значение поля должно быть ISO-кодом нужного языка.', 'fileTooBigEvent Событие fileTooBigEvent срабатывает, когда пользователь отправляет боту файл размером выше 50 Мбайт. JAICP не сохраняет такие файлы. fileEvent поддерживается во всех входящих каналах, кроме Jivo, Zendesk, Zendesk Chat и чат-виджета. Пример использования', 'Сохраните содержимое строки в файл с расширением .wav.', 'Работа с Telegram Bot API Telegram предоставляет Bot API для управления поведением ботов. С помощью доступных методов API вы можете настраивать логику ботов для данного канала. Например, вы можете: отправлять сообщения удалять сообщения Если ваш бот еще не подключен к каналу Telegram, сначала перейдите к инструкции по подключению и выполните ее шаги, чтобы опубликовать бота. После подключения перейдите к следующему шагу этой статьи. Отправка сообщений С помощью метода sendMessage вы можете отправлять сообщения от клиента в ваш личный аккаунт Telegram и отвечать клиенту прямо в диалоге с ботом. В личный аккаунт Чтобы отправить сообщение клиента в личный аккаунт, добавьте в сценарий: Блок text to $var, чтобы записать сообщение клиента в переменную. Блок HTTP-запрос: Выберите метод GET. В поле URL вставьте https&#x3A;//api.telegram.org/bot&lt;token>/sendMessage, где &lt;token> — токен из последнего сообщения бота BotFather при создании бота в Telegram. Это значение вида 5949769123:AAFVkGudasD-qdWscjxJsmlqphhOcD59eXs. Скопируйте JSON-объект ниже и вставьте его на вкладку BODY: Здесь: 223001234 — пример идентификатора вашего диалога с ботом. Вы можете узнать его через специального бота. $rawRequest.message.from.id — идентификатор диалога клиента с ботом из переменной $rawRequest. Он также имеет вид 223001235. $message — переменная, которая содержит текст сообщения клиента. Опубликуйте сценарий и протестируйте отправку сообщений.']"	Вам нужно использовать блок file to $var, который позволяет боту получить любой файл от пользователя. Этот блок поддерживает отправку файлов различных форматов, включая фотографии, текстовые файлы и многое другое.	0.33333333333333337	0.8677402660469679	0.3333333333
Есть ли в JAICP аналог системной сущности $TEXT из Aimylogic, которую можно было бы использовать как часть паттерна?	"[""'$oneWord — любое слово, число или символ $nonEmptyGarbage — произвольный текст. Отличие от паттерна * в том, что текст не может быть пустым, а также знаком препинания.'""]"	"['Разместите его в директории src или по пути, который вы задали самостоятельно как параметр npmRcFile в chatbot.yaml. Например, вы можете использовать не только пакеты из публичного реестра https&#x3A;//registry.npmjs.org/, но и из приватного. Для этого в файле .npmrc укажите адрес реестра и токен для авторизации: Использование встроенного JS API JAICP предоставляет встроенный JS API — набор глобальных переменных, функций и сервисов, которые доступны из любой точки сценария. С помощью него можно реализовать часто используемую функциональность, актуальную для самых разных проектов: Переменные $session и $client предоставляют нативное хранилище данных о сессии и клиенте без необходимости подключать к боту свою базу данных. Сервис $http дает возможность интегрировать бота практически с любой внешней системой, к которой можно обратиться по HTTP API. Сервисы $analytics, $imputer, $pushgate и ряд других позволяют вызывать из сценария различные специализированные подсистемы самой JAICP. На данный момент внутри тегов scriptEs6 и зависимостей на ES6 вы можете использовать ограниченное подмножество JS API — не все возможности перенесены в новую среду исполнения. Список доступных возможностей приведен ниже и постепенно будет расширяться. Если нужная функциональность напрямую не связана с JAICP, используйте внешние зависимости, чтобы компенсировать ее недостаток. Например, вместо $http отлично подойдет HTTP-клиент Axios.', 'Рекомендуется использовать интеграционные тесты только для тех частей сценария, где действительно необходимо проверить работу бота в связке с внешней системой, интегрированной через HTTP API. Структура Элемент &lt;mockData> может иметь следующие дочерние элементы. URL и параметры запроса &lt;query> — описание запроса. Обязательный элемент. Атрибут method — HTTP-глагол, используемый при запросе. Значение по умолчанию — GET. В теле элемента &lt;query> обязательно указывается URL, на который посылается запрос. &lt;parameters> — переменные значения для подстановки в URL. Необязательный элемент. Чтобы задать переменные значения (чаще всего это параметры запроса), можно подставить их непосредственно в тело элемента &lt;query> или использовать отдельный элемент &lt;parameters>. Дочерние элементы &lt;parameters> должны иметь вид &lt;имя-параметра>значение-параметра&lt;/имя-параметра>, а в &lt;query> на месте параметров должны стоять заглушки вида ${имя-параметра}. В XML-тестах необходимо экранировать специальные символы: заменять & на &amp;amp;, &lt; на &amp;lt;, > на &amp;gt;. Тело запроса &lt;body> — описание тела запроса. Необязательный элемент. Если указан тег &lt;body>, при выполнении HTTP-запроса мок-объект дополнительно проверяется на соответствие указанного тела запроса реально переданному из сценария. В теле элемента &lt;body> обязательно указывается JSON-объект или примитив, передача которого ожидается в теле запроса.', 'Поддержка ECMAScript 6 в JAICP До сих пор для сложной бизнес-логики ботов на JAICP поддерживался только один диалект JavaScript (далее JS), а именно его реализация согласно спецификации ECMAScript 5 (ES5) на движке Nashorn. Она была предложена в 2009 году и успела значительно устареть, поэтому возможности написания JS-кода в JAICP не в полной мере отражают современные профессиональные стандарты. Разработчики на JAICP не могут либо могут лишь ограниченно использовать востребованные возможности современных версий JS. В свою очередь, новые пользователи с опытом разработки не могут в полной мере применить свои навыки. Среда исполнения JS в JAICP изолирована от экосистемы пакетов, сформированной сообществом JS-разработчиков, и не позволяет подключать к проектам внешние зависимости, кроме встроенных в платформу (Underscore.js и Moment.js). Мы представляем новую среду исполнения JS, которая решает обе эти проблемы и открывает возможность разрабатывать проекты на современном диалекте JS (далее ES6) с поддержкой внешних зависимостей. Формально ES6 — сокращенное название стандарта ECMAScript 2015, однако JAICP поддерживает и возможности более поздних стандартов. Для простоты в этой статье они объединены под названием ES6. В настоящий момент поддержка ES6 в JAICP находится на стадии бета-тестирования. Если вы хотите принять в нем участие, свяжитесь со своим аккаунт-менеджером или напишите нам на client@just-ai.com. Тег scriptEs6 В JAICP DSL появился новый тег реакции scriptEs6.', 'Тег работает аналогично script с той разницей, что при попадании в стейт код внутри тега запускается в новой среде исполнения. Это позволяет использовать в нем возможности ES6, недоступные внутри обычного тега script: Для запуска кода используется платформа Node.js версии 20. Это означает, что внутри него доступны возможности спецификаций вплоть до ECMAScript 2023, в том числе разбиение кода на модули, новые структуры данных (множества Set, отображения Map), классы, асинхронные функции и многое другое. Подробнее о возможностях ES6 по сравнению с ES5 вы можете узнать, например, в книге доктора Акселя Раушмаера Exploring ES6. Есть и другие теги JAICP DSL, внутри которых пишется JS-код: if, elseif, init. Пока что эти теги не имеют аналогов, в которых можно использовать ES6. Подключение зависимостей Как и раньше, сложную бизнес-логику рекомендуется не описывать напрямую внутри тега scriptEs6, а выносить ее в отдельные JS-файлы, которые затем подключаются к сценарию при помощи тега require. Однако есть важные отличия между тем, как используются именованные объекты (переменные, функции, классы) из файлов, написанных на ES5 и ES6. Зависимости на ES5 Если код зависимости написан на ES5 и запускается в старой среде исполнения, то JS-файл нужно обязательно импортировать в сценарий при помощи тега require без параметров. При этом если на верхнем уровне вложенности этого файла объявлены переменные или функции, то они автоматически помещаются в глобальную область видимости.', '&lt;mockService> Описание Тег &lt;mockService> позволяет задать заглушки ответов на запросы к методам интеграций с внешними сервисами. Подробнее о том, как создавать и использовать интеграции Тег выполняет ту же задачу, что тег &lt;mockData> для HTTP-запросов. Он задает фиктивные ответы, которые будут применяться при выполнении автоматических тестов сценариев, где используется сервис $integration. Когда при выполнении тестов в сценарии вызывается один из методов $integration, система проверяет, предусмотрен ли в тесте соответствующий тег &lt;mockService> с такими же параметрами, что переданы как аргументы при вызове метода. Если такой тег существует и его параметры совпадают с ожидаемыми, то система использует ответ, указанный в &lt;mockService>, в качестве ответа от внешнего сервиса. Таким образом, реальные запросы при выполнении автоматических тестов не выполняются. Выполнение реальных запросов к методам интеграций из автоматических тестов невозможно. Если в сценарии предусмотрен вызов метода $integration, но в тесте для него нет соответствующего тега &lt;mockService> с совпадающими параметрами, то возвращаемое значение метода будет null. Структура Элемент с тегом &lt;mockService> должен быть вложен в элемент &lt;test> и иметь атрибут id=""integration"". Элемент может иметь следующие дочерние элементы: &lt;service> — тип интеграции. В настоящий момент поддерживается только тип googleSheets. &lt;method> — проверяемый метод.', '$integration.customRequest Метод позволяет выполнить произвольный запрос к любому методу, который поддерживается на стороне API интеграции, подключенной к проекту. Метод функционально схож с методом $http.query для выполнения HTTP-запросов. Используйте вместо него $integration.customRequest для обращения к API, имеющим отдельную интеграцию на стороне платформы. Синтаксис Принимаемые аргументы Метод принимает 5 обязательных аргументов. Возвращаемое значение Метод возвращает объект со следующими полями. Примеры использования Рассмотрим примеры того, как вызывать при помощи $integration.customRequest методы API для работы с таблицами Google. В примерах предположим, что идентификатор интеграции и таблицы сохранены в переменных integrationId и spreadsheetId соответственно. Подробное описание методов Google Sheets API Чтение данных из ячеек Для чтения данных воспользуемся методом spreadsheets.values.get. Получим данные из ячейки A1 на первом листе: Если первый лист называется Sheet1, а ячейка содержит значение Привет, метод вернет следующий объект: Поле responseBody содержит тело ответа от API в виде строки. Не забудьте использовать метод JSON.parse, чтобы преобразовать его в объект и извлечь необходимые данные. Запись данных в ячейки Воспользуемся методом spreadsheets.values.update, чтобы обновить существующие данные в ячейках таблицы. При успешном вызове метода значение ячейки A1 будет заменено на Пока.', 'По умолчанию package.json. npmRcFile — путь до конфигурационного файла npm, относительно директории src. По умолчанию .npmrc. forceEs6 — если указано true, то код всех тегов реакций (не только script, но и, например, тега a) будет запускаться в новой среде исполнения. По умолчанию false. Запуск всех тегов в новой среде исполнения в настоящее время не оптимизирован. Рекомендуется не включать параметр forceEs6, если важно сохранить скорость ответа бота. Подключение npm-пакетов Ключевое преимущество новой среды исполнения над старой заключается в том, что для расширения возможностей бота вы можете использовать не только встроенное JS API, но и внешние зависимости — npm-пакеты, написанные сторонними разработчиками. Как подключить и использовать пакет Создайте в директории src файл package.json. Если вы переопределили requirementsFile, создайте файл по тому пути, который вы задали сами. Задайте в этом файле свойство dependencies. Его значением должен быть объект, где ключи — названия требуемых пакетов, а значения — их версии. Если вы разрабатываете проект локально, рекомендуется устанавливать зависимости через npm или любой другой пакетный менеджер, например yarn. Пакетные менеджеры могут сами определять оптимальные версии зависимостей и заполнять файл package.json автоматически. В файле могут быть заданы и другие свойства, но JAICP будет учитывать только dependencies.', 'Теперь вам доступен аналогичный тег &lt;mockService> для тестирования интеграций с таблицами Google при помощи встроенного сервиса $integration.', 'JavaScript в сценарии JAICP DSL использует вставки JavaScript-кода спецификации ECMAScript 5 для описания бизнес-логики и интеграции с внешними системами. Несколько примеров использования JS-кода в проектах: Бот может хранить в переменных определенную информацию, например имена клиентов, и в дальнейшем её переиспользовать в течение диалога. Бот также может производить вычисления, проверять ранее сохраненную информацию о пользователе и реагировать в зависимости от результата. Например, можно проверять канал, в котором происходит общение с ботом, и в зависимости от канала коммуникации отображать элементы графического интерфейса. Структура JS-кода в проекте JS-код в проекте: JS-файлы Вы можете прописать логику непосредственно в файле сценария .sc. Но мы рекомендуем выносить весь JS-код в отдельный файл. Для этого вам потребуется создать в папке src файл с расширением .js, например, functions.js. Напишите в нем функции, которые потом можно будет вызвать из сценарного файла после тега script. Обратите внимание, что JS-файлы содержат объекты и функции, доступные к использованию в любых других скриптах. Файлы подключаются в начале сценария при помощи тега require: Глобальный скоуп Глобальный контекст выполнения доступен явно по имени $global, аналогично объекту window.document в браузере. В глобальном контексте выполнения сохраняются все загружаемые функции и переменные, объявленные непосредственно в JS-файлах.', 'Системные сущности и справочники В Aimylogic есть набор наиболее часто используемых системных справочников и сущностей. Это позволяет вам не создавать их вручную каждый раз. Вы можете использовать системные сущности в блоке Интенты, чтобы бот извлекал из фразы клиента ту или иную сущность и создавал переменную с ее языконезависимым представлением. Среди таких сущностей и справочников: $TEXT, $NUMBER, $FLOATNUMBER, $PHONE, $CITY, $CAPITAL, $COUNTRY, $NAME. Системные сущности Эти сущности позволяют извлечь из фразы клиента данные, которые соответствуют определенным шаблонам. $TEXT Данная сущность позволяет извлечь из фразы клиента произвольный текст. Сущность $TEXT можно использовать только в шаблонах. В примерах фраз ее использовать нельзя. Для того чтобы добавить шаблон для интента, в окне создания интента нажмите на иконку в строке, где собираетесь добавить шаблон. На ее месте появится иконка : :size=500 Например, если вы добавили шаблон вида Я ищу $TEXT, то бот извлечет из фразы клиента «Я ищу интересную работу» сущность $TEXT. Он сохранит часть фразы «интересную работу» в переменной $TEXT. $NUMBER Эта сущность извлекает из фразы клиента целые числа. Клиент может указать их как цифрами, так и словами. В результате бот создаст переменную $NUMBER, в которую поместит целое число.']"	В JAICP нет аналога системной сущности $TEXT из Aimylogic, которую можно использовать как часть паттерна. Вместо этого в JAICP можно использовать регулярные выражения для извлечения произвольного текста из фразы клиента.	0.33333333333333337	0.9350579421016044	0.0
Я нашел только возможность протестировать текстовый бот, но не могу найти голосового	"[""'Редактор кода JAICP предоставляет специальный виджет, с помощью которого можно протестировать, как синтезируют реплики бота все доступные вам провайдеры TTS.'""]"	['Теперь вы можете протестировать бота, отправив ему приветственную фразу, которую вы указали при создании сценария.', 'Далее перейдем к тестированию бота.', 'Чтобы протестировать бота, отправьте сообщение в бизнес-аккаунт WhatsApp.', 'Протестируйте бота Теперь протестируйте бота, написав ему в виджете Jivo на вашем сайте.', 'Тестирование синтеза речи Когда вы разрабатываете сценарий для телефонного канала и продумываете реплики бота, полезно проверять, как именно они будут звучать после синтеза. Так вы сможете заранее оценить, естественно ли звучит речь бота, — а если нет, доработать текст реплики, чтобы добиться оптимального звучания. Редактор кода JAICP предоставляет специальный виджет, с помощью которого можно протестировать, как синтезируют реплики бота все доступные вам провайдеры TTS. Если провайдер поддерживает разметку синтеза речи через SSML, ее также можно использовать в виджете. Виджет для тестирования синтеза речи Как запустить тестовый виджет Тестовый виджет доступен из редактора кода: откройте нужный проект бота и перейдите в раздел Редактор → Код. Есть несколько способов запустить тестовый виджет TTS: Нажмите TTS в правом верхнем углу редактора. Используйте сочетание клавиш Ctrl + F10 (⌘ + F10). Нажмите в зоне с номерами строк. Эта иконка появляется во всех строках, где есть тег a. В этом случае поле для текста на синтез будет предзаполнено ответом из тега a. Если у тега дополнительно есть параметр tts, поле будет заполнено значением этого параметра. Настройка провайдера TTS Через виджет вы можете задать провайдера TTS и голос, который будет использован для синтеза реплики. На всех тарифах, кроме бесплатных, для тестирования доступны все провайдеры, которых можно использовать при создании телефонного канала. На бесплатных тарифах доступен только провайдер Aimyvoice.', 'После того как вы создадите бота для входящих звонков и опубликуете его, вы можете позвонить на арендованный номер и проверить работу бота.', 'Для этого введите название голоса в поле Голос вручную.', 'Использование в сценарии В примере бот фиксирует неавтоматизированный диалог в текстовом канале:', 'Теперь перейдем к тестированию бота и созданию канала.', 'Теперь перейдем к работе с HTTP-запросом.']	В документации есть информация о тестировании синтеза речи бота. Вы можете использовать специальный виджет в редакторе кода JAICP для протестирования, как звучит речь бота. Виджет позволяет использовать различных провайдеров синтеза речи и настраивать голос. Если вы не нашли нужную информацию, пожалуйста, уточните свой вопрос.	0.75	0.816510854310672	0.2888888888792593
Уроков по созданию голосового бота, для обзвона нет? Просто в уроках везде только кнопочный	"['\'Есть гайд: ""В разделе Обзвоны вы можете задать условия и возможные ограничения для обзвона ботом. Здесь же происходит запуск обзвона."" и тд\'']"	"['Как создать обзвон Чтобы создать обзвон, выполните следующие шаги: Создайте бота для исходящих звонков в разделе Звонки. Сконструируйте ваш сценарий и разметьте его для аналитики. Выберите голос для обзвона. Выберите тип обзвона: Подготовьте и загрузите список номеров. Или настройте обзвон по триггеру из CRM. Настройте параметры и расписание обзвона. Запустите обзвон. Для запуска обзвона у вас должен быть положительный баланс минут. Выделенная телефонная линия и номер для исходящих вызовов на данный момент доступны только для Российской Федерации. Если вы хотите запускать обзвоны на зарубежные номера, используйте собственное SIP-подключение. Создайте бота для обзвона Сценарии для чат-ботов и звонков в Aimylogic находятся на разных вкладках. Чтобы создать сценарий для обзвона: Выберите вкладку Звонки → Создать бота → Звонить клиентам → Продолжить: Укажите название бота, по желанию измените язык и шаблон проекта. Нажмите Создать. Вы попадете на страницу сценария. Выберите голос для обзвона Перейдите на вкладку Обзвоны. Здесь вы увидите текущий баланс ваших минут и список всех обзвонов в данном сценарии. Рядом с балансом минут вы можете выбрать голос, которым будет говорить бот во всех обзвонах сценария. Для выбора вам доступны голоса, которые были созданы на платформе Aimyvoice и голос Алена от Яндекс. Подробнее о создании и использовании голосов Aimyvoice Чтобы прослушать выбранный голос, нажмите .', 'Или происходит техническая ошибка. Или случается еще что-то, что не предусмотрено в сценарии. Теперь вы сможете контролировать, что происходит в таких случаях. В Настройках бота появилась новая вкладка, ""Ответы бота при форс-мажорах"". Здесь вы можете предупредить все возможные проблемы, которые могут возникнуть во время звонка. Шаблоны для звонков Бывает, что вам нужно быстро сделать типовой обзвон (например, для подтверждения доставки), но у вас мало времени. Мы сделали для вас шаблоны, которые вы можете настроить под себя за пять минут, и тут же запустить обзвон. На данный момент шаблонов два: подтверждение доставки подтверждение записи на прием Впишите в шаблон название компании, дату доставки или посещения, загрузите номера телефонов клиентов –– и готово! Надеемся, шаблоны облегчат вам работу. А если вам не хватает каких-то других простых сценариев для обзвона, напишите нам на contact@aimylogic.com! Интеграция с ботом Маруся от компании Mail.Ru Многие компании выпускают умные колонки, которые делают жизнь пользователей проще. Теперь и компания Mail.ru присоединилась к рынку умных устройств, выпустив не только колонку, но и голосового помощника Марусю. А благодаря нам, вам не придётся разбираться с созданием навыков для Маруси, потому что Маруся –– уже один из каналов, в котором вы можете опубликовать бота Aimylogic. Создайте сценарий в Aimylogic и свяжитесь с Mail.ru для публикации навыка!', 'Подробнее о том, как создать простого бота в редакторе навыков и в конструкторе.', 'Визард для входящей телефонии С помощью Aimylogic вы можете быстро создать чат-бота для обработки входящих звонков. Обратите внимание: прежде, чем пользоваться шаблоном для обработки входящих звонков, вам нужно создать собственное телефонное подключение Первым делом на странице обзвонов выберите нужный шаблон. Перед началом заполнения информации вы сможете прослушать пример диалога и узнать, что нужно сделать для подготовки обзвона. :size=400 Чтобы создать сценарий для входящих звонков по шаблону, вам нужно пройти несколько шагов: Настроить сценарий Протестировать сценарий Запустить шаблон в работу Настройте сценарий На первом этапе подготовки сценария для обработки входящих звонков вам нужно: написать текст приветственного сообщения придумать ответ бота на случай, если он не поймет, что сказал пользователь указать текст ответа для каждого из подготовленных вопросов или уточнить, что на этот вопрос ответит оператор указать рабочие часы, в которые звонки могут переводиться на оператора определить поведение бота в нерабочие часы Протестируйте сценарий На втором этапе подготовки сценария для обработки входящих звонков вы можете протестировать сценарий. При тестировании бот сам позвонит на номер, который вы уже указывали для проверки. Если вы еще не указывали номер, вы сможете тут же сделать это. Бот сам совершит звонок только при тестировании. После запуска шаблона бот будет использовать подготовленный сценарий только для обработки входящих звонков.', 'Теперь вы можете настроить обзвон и запустить его на любые российские номера через телефонию Aimylogic.', 'Урок с использованием Google Таблиц', 'Пример запроса Ответом на такой запрос будет идентификатор созданного задания на обзвон в строковом формате.', 'Пример запроса Ответом на такой запрос будет идентификатор созданного задания на обзвон в строковом формате.', 'Если вы уже все придумали, или просто хотите попробовать сделать простого бота, можно приступать к первому уроку.', 'Контроль обзвона Следующие методы Calls API предназначены для контроля выполнения обзвона: Пример запроса']"	В документации нет упоминания об уроках по созданию голосового бота для обзвона. Возможно, вам стоит обратиться напрямую к разработчикам по электронной почте contact@aimylogic.com и уточнить возможность проведения таких уроков.	0.33333333333333337	0.8937167777206341	0.7499999999625
может можно как-то работать с кодом локально? а то у меня код растет — и vscode был бы кстати.	"[""'Just AI представляет расширение JAICP для Visual Studio Code (VS Code). С его помощью вы можете разрабатывать проекты не только во встроенном редакторе JAICP, но и локально на своем компьютере.'""]"	"['Создание интента geo Теперь добавьте в поле Тестовые фразы фразу @mystem.geo, чтобы бот мог распознавать название городов. Подробнее о настройке интентов и слот-филлинга Приведение к начальной форме Заполненный слот будет храниться в поле $parseTree.\\_geo. Присвоим это значение переменной city. Клиент может ввести фразу как угодно, например, Москва или в Москве. Значение в $parseTree.\\_geo будет записано именно так, как и ввел его клиент, но для выполнения запроса к API нам необходимо, чтобы значение было приведено к нормальной форме. Для этого будем использовать функцию $caila.inflect, которая умеет склонять текст в любой падеж. Вызовем функцию с аргументом \\[""nomn""], чтобы названия городов были приведены к именительному падежу: Вызов функции API Перейдем к обработке запроса. Вызываем функцию openWeatherMapCurrent, которую мы создали ранее. Функция принимает 3 аргумента: ""metric"" — параметр, использующийся для вывода температуры в градусах Цельсия; ""ru"" — параметр, указывающий на язык вывода данных; city — переменная, в которой хранится название города. Выполним асинхронный HTTP-запрос. Функция openWeatherMapCurrent возвращает объект promise. Чтобы вывести результат, обрабатываем promise при помощи then(function (res) {}). Здесь res — переменная, содержащая ответ на запрос. Получение ответа Допустим, клиента интересует погода в Москве. Из сообщения будет извлечена сущность В Москве и приведена к начальной форме Москва с помощью $caila.inflect.', 'Далее такой модуль можно переиспользовать, подключив его в нужный проект как внешнюю зависимость. Например, в такие зависимости могут быть вынесены готовые фрагменты сценариев, часто используемые функции и справочники. Конфигурация Зависимости указываются в разделе dependencies конфигурационного файла chatbot.yaml. Для внешних зависимостей должны быть указаны поля: Поля loginSecretKey и tokenSecretKey нужны только в том случае, если зависимость размещена в приватном репозитории. Также учитывайте следующие требования: В качестве значения tokenSecretKey нельзя использовать пароль от учетной записи. Вместо него вам нужно выпустить персональный токен с доступом на чтение нужного репозитория. Подробнее о том, как получить токен в Bitbucket, GitHub и GitLab. Для безопасности ваших данных ни логин, ни токен нельзя записывать непосредственно в chatbot.yaml. Вместо этого их нужно хранить в хранилище токенов JAICP. В качестве значений loginSecretKey и tokenSecretKey используйте названия токенов, где хранятся нужные значения. Структура проекта Рассмотрим пример файла offtopic.sc, приведенный выше. Создайте директорию под новый репозиторий. В ней создайте поддиректорию src, в которую поместите offtopic.sc: Создайте в корневой директории Git-репозиторий и зафиксируйте изменения. Опубликуйте репозиторий на любом внешнем хостинге, например Bitbucket, GitHub или GitLab.', 'JavaScript в сценарии JAICP DSL использует вставки JavaScript-кода спецификации ECMAScript 5 для описания бизнес-логики и интеграции с внешними системами. Несколько примеров использования JS-кода в проектах: Бот может хранить в переменных определенную информацию, например имена клиентов, и в дальнейшем её переиспользовать в течение диалога. Бот также может производить вычисления, проверять ранее сохраненную информацию о пользователе и реагировать в зависимости от результата. Например, можно проверять канал, в котором происходит общение с ботом, и в зависимости от канала коммуникации отображать элементы графического интерфейса. Структура JS-кода в проекте JS-код в проекте: JS-файлы Вы можете прописать логику непосредственно в файле сценария .sc. Но мы рекомендуем выносить весь JS-код в отдельный файл. Для этого вам потребуется создать в папке src файл с расширением .js, например, functions.js. Напишите в нем функции, которые потом можно будет вызвать из сценарного файла после тега script. Обратите внимание, что JS-файлы содержат объекты и функции, доступные к использованию в любых других скриптах. Файлы подключаются в начале сценария при помощи тега require: Глобальный скоуп Глобальный контекст выполнения доступен явно по имени $global, аналогично объекту window.document в браузере. В глобальном контексте выполнения сохраняются все загружаемые функции и переменные, объявленные непосредственно в JS-файлах.', 'Уточнение часового пояса Это часть серии статей, посвященной созданию бота для отправки напоминаний через сервис $pushgate. Уточнение часового пояса (вы находитесь здесь) Создание напоминаний Отмена напоминаний Создание проекта Перейдите в JAICP и создайте новый проект из системного шаблона Проект для CailaPub, после чего перейдите в раздел Редактор. Мы будем работать только с файлом main.sc. Очистите его содержимое, оставив только: подключение файла slotFilling.sc из системного модуля zb-common; объявление корневой темы /, в которой будут находиться все стейты этого сценария; стейт CatchAll для обработки нераспознанных реплик в глобальном контексте. Подключение справочника городов Теоретически клиенты могут общаться с ботом из любой точки мира. Бот должен знать, в каком часовом поясе находится клиент, чтобы устанавливать напоминания на корректные дату и время. Поэтому прежде чем начать диалог, необходимо выяснить часовой пояс клиента, а проще всего узнать его по городу. Воспользуемся справочником городов, который предоставляет системный модуль zb-common. В значении каждый элемент справочника содержит поле timezone — строку, которая обозначает соответствующий городу часовой пояс в формате спецификации Java. Подключите справочник при помощи тега require: Теперь в сценарии доступна именованная сущность $City для распознавания городов в запросах клиента. Вступительная часть сценария Теперь приступим к разработке точки входа в сценарий.', 'Если в каком-либо тест-кейсе вы хотите проверить код, который выполняется внутри тега scriptEs6, для таких проверок не будут работать следующие теги: dateTime mockData mockService random Если вы разрабатываете проект локально, для тестирования JS-кода (но не сценария) вы можете использовать любой удобный инструмент. Например, фреймворк Jest. Примеры проектов Мы подготовили примеры проектов, которые работают в новой среде исполнения и демонстрируют ее возможности. Вы можете просмотреть их исходный код на GitHub, а оттуда же сразу создать проект в JAICP. Полезные ссылки MDN Web Docs — портал по веб-разработке от Mozilla. Его раздел про JavaScript наиболее приближен по статусу к официальной документации языка. Exploring JS — книги по JS от уже упомянутого выше доктора Акселя Раушмаера, в том числе о новейших спецификациях ECMAScript. Introduction To Node.js — официальное введение в Node.js. Из него вы больше узнаете про менеджмент пакетов, встроенные модули и другие особенности разработки под эту платформу.', 'Разместите его в директории src или по пути, который вы задали самостоятельно как параметр npmRcFile в chatbot.yaml. Например, вы можете использовать не только пакеты из публичного реестра https&#x3A;//registry.npmjs.org/, но и из приватного. Для этого в файле .npmrc укажите адрес реестра и токен для авторизации: Использование встроенного JS API JAICP предоставляет встроенный JS API — набор глобальных переменных, функций и сервисов, которые доступны из любой точки сценария. С помощью него можно реализовать часто используемую функциональность, актуальную для самых разных проектов: Переменные $session и $client предоставляют нативное хранилище данных о сессии и клиенте без необходимости подключать к боту свою базу данных. Сервис $http дает возможность интегрировать бота практически с любой внешней системой, к которой можно обратиться по HTTP API. Сервисы $analytics, $imputer, $pushgate и ряд других позволяют вызывать из сценария различные специализированные подсистемы самой JAICP. На данный момент внутри тегов scriptEs6 и зависимостей на ES6 вы можете использовать ограниченное подмножество JS API — не все возможности перенесены в новую среду исполнения. Список доступных возможностей приведен ниже и постепенно будет расширяться. Если нужная функциональность напрямую не связана с JAICP, используйте внешние зависимости, чтобы компенсировать ее недостаток. Например, вместо $http отлично подойдет HTTP-клиент Axios.', 'Валидация кодов для разных заданий В этом уроке вы научитесь обеспечивать валидацию числовых кодов. Это может быть полезно в игровых навыках или для валидации промо-кодов во время акций. В данной конкретной статье мы научимся хранить в Google Таблице коды, которые понадобятся на разных этапах сценария. Скажем, на первом этапе нам нужно за правильный ответ принимать код ""4444"", но во втором задании нам нужно за правильный ответ принимать код ""5632"". После прохождения этого урока вы научитесь принимать за верный ответ в определенном задании только один код из таблицы. Если вас интересует авторизация по логину и паролю, смотрите этот урок. Если вы хотите проводить авторизацию определенных аккаунтов Telegram, то смотрите этот урок. Прежде чем приступим к уроку, нужно сделать небольшое отступление. Обратите внимание, что если в сценарии есть глобальный интент, он будет переводить пользователя на соответствующий экран, даже если вод введен неверно. Также, бот будет продолжать выдавать ответы из базы знаний. Итак, приступим. Начнем с создания таблицы. Создайте таблицу с колонками:number code Скопируйте и вставьте эти названия столбцов в таблицу. Если вы допустите ошибку в названии столбца, данный сценарий работать не будет. В колонке number будут порядковые номера - 1, 2, 3, 4, 5… В колонке code перечислите коды для соответствующих заданий. Добавьте в сценарий блок num to $var.', 'Валидация кода В этом уроке вы научитесь обеспечивать валидацию числовых кодов. Это может быть полезно в игровых навыках или для валидации промо-кодов во время акций. Если вас интересует авторизация по логину и паролю, смотрите этот урок. Если вы хотите проводить авторизацию определенных аккаунтов Telegram, то смотрите этот урок. Если вам нужно для разных этапов сценария принимать разные правильные ответы (разные коды), то пройдите этот урок. Прежде чем приступим к уроку, нужно сделать два отступления. Обратите внимание, что если в сценарии есть глобальный интент, он будет переводить пользователя на соответствующий экран, даже если вод введен неверно. Также, бот будет продолжать выдавать ответы из базы знаний. Итак, приступим. Начнем с создания таблицы. Создайте таблицу с колонками: codes Скопируйте и вставьте это название столбца в таблицу. Если вы допустите ошибку в названии столбца, данный сценарий работать не будет. Напишите в таблице несколько числовых кодов. Добавьте в сценарий блок num to $var. Напишите в нем текст: Введите код. И напишите переменную: entry. Также, укажите нужный вам диапазон номеров. Например, от 1 до 9999. Подготовим таблицу. Опубликуйте таблицу: Файл → Поделиться → Опубликовать в интернете → Опубликовать. Путь из всплывающего окна копировать не нужно. Закройте всплывающее окно. Публиковать страницу нужно только один раз. Вам не нужно снова публиковать страницу после внесения в нее изменений.', 'Но мы рекомендуем выносить весь JS-код в отдельный файл. Для этого вам потребуется создать в src папке файл с расширением .js, например, functions.js. Напишите в нем функции, которые потом можно будет вызвать из сценарного файла после тега script. Обратите внимание, что JS-файлы содержат объекты и функции, доступные к использованию в любых других скриптах. .js-файлы подключаются в начале сценария при помощи тега require: Подробнее о работе с тегом require', 'Может получиться что-то вроде этого: heroku git:clone -a august30app Введите эту команду и нажмите Enter. После выполнения этой команды появится сообщение ""Warning: You appear to have cloned an empty repository."" Это нормально. Далее, выполните следующую команду: cd app Вместо app снова вставьте название вашего приложения. Например: cd august30app После этого скопируйте и вставьте данную команду, нажмите Enter: git remote add origin https&#x3A;//github.com/aimylogic/nodejs-webhook Затем скопируйте и вставьте данную команду, нажмите Enter: git pull origin master Теперь перейдите в папку проекта. Там появилась папка с вашим приложением. Откройте ее. Кликните правой кнопкой на файл webhook.js и откройте его любым текстовым редактором. Удалите все после строки \'use strict\' и вставьте следующее: module.exports = (webhook) => { webhook.on(\'event1\', (session) => { if (session.count == null) { session.count = 1; } else { session.count = session.count + 1; } } ); } Файл будет выглядеть так: Здесь мы прописали кусочек кода на языке Javascript. С помощью этого кода мы будем прибавлять 1 к переменной $count. Важно здесь название события - event1, мы пропишем его позже в сценарии. Сохраните файл webhook.js и закройте его. Вернитесь в терминал. Отправляем изменения Выполните команду: git add . Затем выполните эту команду: git commit -am ""some comments"" И, наконец, git push После этого подождите, пока изменения будут внесены.']"	Да, вы можете работать с кодом локально, используя свою среду разработки, например, Visual Studio Code. В документации приведены примеры работы с кодом и рекомендации по структуре проекта. Вы можете создать отдельный файл с расширением .js, например, functions.js, и написать в нем функции, которые затем можно будет вызывать из сценарного файла после тега script. Обратите внимание, что JS-файлы содержат объекты и функции, доступные для использования в любых других скриптах.	0.4285714285714286	0.9055190141422512	0.24074074073271604
"пытаюсь понять как через js добавить кнопки с переходом в состояния. казалось бы как-то так   $response.replies.push({  type: ""buttons"",  buttons: [  {text: ""actions"", transition: ""/get_actions""},  ]  })  и кнопка действительно появляется. но вот только в результате нажатия просто печается текст без предполагаемого перехода. спустя час гугления и экспериментов не смог найти работающий вариант. сдаюсь :). подскажите, пожалуйста"	"['\'Функция позволяет добавлять в ответ кнопки.  Функция принимает объект, описывающий кнопку:  - text — название кнопки; - transition, url — путь перехода при клике на кнопку.  Код: script:  $reactions.buttons({text: ""Кнопка с переходом"", transition: ""/state""})\'']"	"['Метод возвращает целочисленные значения от 0 до max(не включая max), поэтому в качестве параметра укажем 100 и прибавим к получившемуся случайному значению 1. Запишем в тег script команду: В JS API переменная $session является объектом для сохранения сессионных данных. Присвоим переменной $session.number функцию случайного выбора числа. В дальнейшем будем сравнивать число, хранящееся в $session.number, с числом, введенным пользователем. Чтобы убедиться, что бот действительно загадывает числа в случайном порядке, выведем загаданное число на экран в виде сообщения Загадано \\*число\\*. Вставьте в скрипт следующую строку: Переходы по стейтам Переход в другой стейт осуществляется посредством вызова метода $reactions.transition. В параметре указывается путь к стейту /Проверка. Подробнее ознакомьтесь с использованием встроенных сервисов $jsapi и видах переменных в JS API Проверка Настройка интента Перейдите на вкладку CAILA > Интенты, расположенную в боковом меню. Создайте интент /Число и добавьте в поле Тренировочные фразы фразу @duckling.number, чтобы бот мог распознать введенное пользователем число и сохранить его. Интент число Выполнение условия Переменная $parseTree.\\_Number представляет собой число, которое ввел пользователь. Создадим отдельную переменную num. Присвоим ей значение, полученное в стейте Согласие из слота Number. Далее с помощью условного оператора if/else сравниваем загаданное значение с введенным. Если числа равны, то бот выдаст сообщение Ты выиграл!', 'В Aimylogic мы пишем переменные используя $, а затем имя переменной. Регистр имеет значение - переменные $number и $NUMBER - это разные переменные. | Подробнее о переменных читайте здесь. На вкладке RESPONSE нажмите +. Скопируйте и вставьте в поля: Имя переменной: num В поле Значение скопируйте и вставьте: parseInt($httpResponse) Что здесь происходит? После HTTP запроса Aimylogic сохраняет ответ сервиса random.org в системную переменную $httpResponse. Но сервис random.org возвращает текст, а нам нужно целое число, чтобы мы могли сравнивать с ним число пользователя (строка и число - разные типы данных в Javascript). Поэтому нам нужно сначала преобразовать текстовый ответ сервиса в целое число. Для этого в Javascript есть функция parseInt, которой мы и воспользуемся. Передадим в функцию parseInt весь ответ от сервиса - так мы преобразуем строку в число. Затем мы записываем это значение в переменную, которую указали в поле ?? и сохраним его в переменную $num. Поля BODY и HEADERS заполнять не нужно. Нажмите Сохранить Назовем этот экран: запрос А теперь угадывай! Бот получил случайное число. Теперь бот должен вывести пользователю сообщение о том, что число загадано, и пригласить пользователя угадать число. Кликните на вариант Завершен успешно блока HTTP-запрос и создайте блок Текст. В нем напишите: Я загадал число от 1 до 100. Угадай, какое!', '$reactions.buttons Функция позволяет добавлять в ответ кнопки. Функция принимает объект, описывающий кнопку: text — название кнопки; transition, url — путь перехода при клике на кнопку. Примеры использования', 'Все значения параметров имеют строковый тип. Поэтому перед математическими операциями их нужно привести к числам — для этого используется встроенная функция parseFloat. Затем значения складываются, а их сумма сохраняется в $temp.result. Проверяется исключительный случай, что параметры не удалось привести к числам и сумма имеет значение NaN. Если значение не NaN, бот отправляет ответ со значением суммы. Лучше всего проектировать теги так, чтобы в них можно было указать, в какой стейт основного сценария бот должен вернуться после действия. Тег SumTwoNumbers поддерживает два дополнительных параметра: okState и errorState. Если бот успешно посчитал сумму и в тег передан параметр okState, сценарий переходит в этот стейт. Если посчитать сумму не удалось и в тег передан errorState, сценарий переходит в этот стейт. Если не передан ни okState, ни errorState, бот сообщает об ошибке. Шаг 2. Задайте настройки тега Чтобы использовать сценарий выше как тег действия, его нужно описать в специальном JSON-файле с настройками. Создайте в той же директории SumTwoNumbers файл block.json. В файл запишите JSON-объект с полями ниже. Все поля обязательны, если не указано иное. Настройки тега Настройки параметров Типы параметров Независимо от того, какой тип объявлен для параметров, все значения попадают в $request.data.args как строки. Чтобы корректно работать с ними в сценарии тега действия, преобразуйте их тип: Параметры с типом bool приводятся к логическому значению через конструктор Boolean.', 'Свяжите ""Переход после ввода $entry"" с новым блоком HTTP-запрос: Параметры HTTP-запроса: метод Get в url используйте ссылку, которую получили шагом выше на вкладке RESPONSE напишите название переменной: check и значение: \\_.findWhere($httpResponse, {""number"": 1}) где 1 - число, соответствующее порядковому номеру кода для соответствующего задания. В этом месте сценария, например, мы будем принимать за правильный ответ код 4444, который стоит в строке 1: Вкладки BODY и HEADERS заполнять не нужно. Нажмите Сохранить. С помощью этого HTTP-запроса мы получим всю информацию, которая есть у нас в таблице. То есть, сам запрос еще не проверяет, верный ли код. Он только делает запрос к url. Если таблица опубликована как описано в инструкции по чтению данных из Google Таблиц, то запрос будет успешным, даже если пользователь ввел код неверно. Поэтому мы будем проверять код на следующих шагах. Сам факт успешного завершения http-запроса не говорит о том, что введенный код был верным. Также, http-запрос получает информацию из соответствующей строки с помощью \\_.findWhere($httpResponse, {""number"": 1}) и записывает все, что есть в строке, которая соответствует номеру ""1"" в переменную $check. От варианта Завершен с ошибкой сделайте связь с блоком Текст, где напишите: Ошибка чтения кода $httpStatus Если в процессе тестирования вы увидите это сообщение, ищите решение проблемы в конце этой статьи.', '$imputer.generateAudioUrl Метод $imputer.generateAudioUrl возвращает URL реплики с переданными значениями переменных. За основу JAICP берет шаблон реплики из списка в разделе Гибридный синтез речи. Подробнее о том, как добавить шаблон реплики Чтобы воспроизвести в сценарии аудио по полученному URL, используйте тег audio. Синтаксис Принимаемые аргументы Метод $imputer.generateAudioUrl принимает аргументы: Возвращаемое значение Метод возвращает URL реплики с указанными значениями переменных и заданной скоростью. Примеры вызова Пример использования Например, для шаблона реплики {name: Алексей Викторович}, вы записаны завтра на {serviceName: диагностику двигателя}. Подтверждаете запись? с идентификатором confirmation вызов метода может выглядеть следующим образом: В этом примере реплика без переменных helloPhrase также была использована в сценарии при помощи вызова метода $imputer.generateAudioUrl. Это было сделано, чтобы избежать разницы в звучании реплик: c переменными и без. Подробнее см. в разделе Гибридный синтез от Just AI.', 'Для этого будем использовать встроенные функции Aimylogic. От варианта блока http-запрос Завершен успешно создаем новый блок Условия, в который пишем $items.first() Назовем этот экран ПЕРВЫЙ ВОПРОС Вот что у нас получилось: Таким образом получаем первый элемент массива, а теперь нам нужно его вывести. Выводим первый вопрос Чтобы вывести текст первого вопроса, соедините условие $items.first() с новым блоком Текст. В блоке Текст напишите: Дополни такую фразу: Назовем этот экран ВЫВОДИМ ВОПРОС На этот же экран ""ВЫВОДИМ ВОПРОС"" добавьте еще один блок Текст :size=200 :size=200 и напишите в нем: \\`$items.current().question\\`\\` :size=200 :size=200 Теперь мы можем протестировать, выводится ли первый вопрос. Для этого нажмите Тестировать и напишите боту ""да"". Должно получиться так: Если вопрос не выводится, вернитесь к шагу 5 и убедитесь, что вы опубликовали страницу. Если появляется ошибка или бот выводит не то, что в таблице, то убедитесь, что вы нигде не допустили опечатку. Принимаем варианты ответов Остановите тестирование. Добавьте на экран ""ВЫВОДИМ ВОПРОС"" блок Интенты. Создайте интент $answer Этот интент будет принимать ответы, которые мы пропишем в справочнике сущностей. Создадим справочник Сохраните сценарий. Чтобы принимать ввод пользователя и сравнивать его с правильными ответами, нам нужно создать справочник сущностей.', 'И, наконец, добавим еще одну строку: $TEXT::isname Данная строка будет отрабатывать только в том случае, если ни один из других примеров не отработал. Введенное на данном экране сообщение клиента будет попадать в нее полностью. Этот $TEXT нам нужен на случай, если клиент добавил необычное имя одним словом. По умолчанию, когда вы переходите в редактирование блока Интенты и начинаете добавлять строки, они добавляются как примеры фраз, а не как шаблоны. Об этом свидетельствует иконка . Нажмите Сохранить. Теперь можно удалить экран с текстом Вас правда зовут $queryText?, так как у вас есть сущность $TEXT, которая будет принимать любую строку. Если в интентах есть $TEXT, то ветка Любая другая фраза отрабатывать не будет. Далее нам нужно сделать связь от интента \\* меня \\* зовут $TEXT::isname и создать блок Условия: В блок Условия вставьте следующее выражение: $name = $NAME ? $NAME.name : $isname С помощью этого условия вы создаете переменную $name. = — это оператор языка программирования JavaScript, с помощью которого присваивается значение переменной $name. Далее идет логическое выражение. Если у вас ранее что-то попало в системную сущность $NAME, то переменная $NAME.name будет записываться в переменную $name. Если же в системную сущность $NAME ничего не попало, то в $name запишется значение $isname. В итоге в переменной $name окажется имя из словаря или принятое необычное имя.', 'Добавить ""пустую"" кнопку Второй способ подойдет вам, если кнопка-ссылка не подходит для вашего сценария. нажмите + КНОПКА наберите пробел и нажмите Enter. Текст кнопки будет содержать только один символ - пробел нажмите на значок ссылки, вставьте любую ссылку нажмите Сохранить Нажмите Опубликовать и дождитесь сообщения о публикации в канал. Затем пройдите ветку заново. Например, пошлите боту /start. Обычные кнопки превратятся в Инлайн-кнопки, а кнопка, которая содержит только символ пробела, отображаться не будет. Как запомнить выбор пользователя Вы можете получить текст выбранной инлайн-кнопки в Telegram через переменную $queryText. Для этого после блока с инлайн-кнопками добавьте блок Условия и сохраните значение $queryText в новую переменную $choice через выражение $choice = String($queryText).split(\';\')\\[1]. Особенности канала Telegram Есть некоторые особенности отображения кнопок, которые нужно учитывать. Не всегда сразу же можно увидеть новый вариант кнопок. Иногда нужно пройти по другой ветке бота, затем послать /start и вернуться на экран с кнопками. Если у вас есть два экрана, которые идут друг после друга, и на первом экране обычные кнопки, а на втором инлайн-кнопки, то при перехода на экран с Инлайн-кнопками, обычные кнопки не исчезнут. К примеру, возьмем два таких экрана. На экране, выделенном синим, обычные кнопки. На экране, выделенном зеленым, Инлайн-кнопки.', 'Чтобы записать в переменную объект из массива items, потребуется следующее JavaScript-выражение: \\_.findWhere($httpResponse.items, {name: ""$choice""}) Функция будет искать в ответе объект, у которого значение поля name совпадает со значением переменной $choice. Переходы после запроса Блок HTTP-запрос имеет два выхода: Завершен успешно, если в ответ на запрос сервер вернул код ответа от 200 до 299 включительно. Завершен с ошибкой, если сервер вернул любой другой ответ. Код ответа автоматически сохраняется в системную переменную $httpStatus.']"	"Чтобы добавить кнопки с переходом в состояния в Aimylogic с использованием JavaScript, вам нужно использовать функцию $reactions.buttons. Вот пример кода:

```javascript
$response.reactions.buttons([
  {text: ""Название кнопки"", transition: ""/путь_к_стейту""}
]);
```

В этом примере, при нажатии на кнопку ""Название кнопки"" произойдет переход в состояние с путем ""/путь_к_стейту"". Убедитесь, что вы правильно указали путь к состоянию."	0.5	0.8804019292740778	0.8333333332916666
всем привет! подскажите, пожалуйста, как научить бота принимать файлы?	"[""'Используйте event!: fileEvent.'""]"	"['Как добавить ChatGPT в бота из конструктора', 'Как сочетать кнопки и интенты?', 'Бот-лидогенератор для онлайн-школы В данном уроке вы создадите бота, который будет предлагать клиентам записаться на пробный урок в онлайн-школу английского языка. Если клиент согласится, бот уточнит его данные и время записи, а затем отправит полученную информацию в Google Таблицу. Приветствие Перейдите на главную страницу Aimylogic и нажмите Создать бота. В первую очередь бот должен поздороваться с клиентом. Для этого добавьте новый экран с блоком Текст и укажите приветственную реплику, например: Добро пожаловать в школу английского языка “High Five”! Я могу рассказать вам о часах работы и расписании уроков, а также записать на первое занятие. Чем я могу вам помочь? Приветственная реплика Прием реакции клиента Чтобы клиент мог отреагировать на сообщение бота, нужно добавить в сценарий кнопки и интенты. Интент определяет, чего хочет клиент, и направляет его по нужной ветке сценария. Кнопки Кнопки позволяют связать два экрана. Вам потребуется добавить несколько кнопок: Нажмите Кнопка и введите текст для кнопки — например, Часы работы. Таким же образом добавьте другие кнопки — Запись и Расписание. К кнопке Расписание добавьте ссылку на сайт с информацией о расписании. Прикрепить ссылку можно к любой кнопке. Для этого наведите курсор на кнопку, нажмите и укажите URL. Добавление кнопок Интенты Интенты позволяют боту распознавать определенные фразы клиента. Чтобы добавить интент, нажмите Блок → Сделать свой интент. Вы можете заполнить интент примерами и шаблонами фраз.', 'Создание датасета Чем лучше бот понимает пользователей, тем лучше он будет справляться со своими задачами. Поэтому важно обучить его на наборе данных, похожих на те, с которыми бот столкнется при реальном общении. JAICP предоставляет инструменты, с помощью которых вы можете создать датасет для обучения бота из интерфейса платформы: По умолчанию разметка логов и дообучение интентов отключены. Отправьте запрос технической поддержке, если хотите, чтобы эти инструменты стали для вас доступны. Чтобы перейти к созданию датасета: Перейдите в проект и на панели управления нажмите CAILA → Разметка логов. Выберите подходящий для вас инструмент — разметку логов или дообучение интентов. Используйте разметку логов, если у вас есть собственные данные для обучения. Дообучение интентов будет полезно, когда бот уже какое-то время проработал и накопил данные о диалогах. В зависимости от того, что вы выбрали, загрузите файл с данными или нажмите Импортировать из аналитики. Теперь вы можете приступать к работе над датасетом. В статье Как обучать интенты собраны практические рекомендации по наполнению классификаторов CAILA. Учитывайте их при работе над датасетом. Если вы уже пользовались разметкой логов или дообучением в этом проекте, но теперь хотите обработать новый датасет, после перехода в CAILA → Разметка логов нажмите Новый набор фраз.', 'Как создать простого бота в J‑Graph В этом туториале вы создадите простого чат-бота, который будет: Предлагать оформить заказ Запрашивать контакты клиента Подтверждать заказ Создание сценария Чтобы начать работу в J‑Graph: Создайте новый проект в JAICP. Выберите на панели управления слева Редактор → J‑Graph. Вы попадаете на холст — основное рабочее пространство в J‑Graph. Передвигайтесь по холсту, зажав правую кнопку мыши или выбрав свободное место на холсте пальцем на тачпаде. Масштабируйте его с помощью колесика мыши или прокрутки пальцами на тачпаде. На холсте создаются шаги — экраны с реакциями бота и ожидаемыми ответами пользователя на них. В сценарии уже есть несколько шагов: Обязательный шаг начала сценария /Start — он отмечен специальным флагом. Шаги приветствия /Hello и прощания /Bye. Обязательный шаг /NoMatch — шаг с реакцией бота на нераспознанные фразы. Шаг /Match — реакция бота на распознанные фразы, но не учтенные в сценарии. Шаги /Hello, /Bye и /Match не понадобятся, чтобы создать бота в этом туториале, их можно удалить. Шаги сценария Шаг 1. Приветствие и меню бота Для начала на шаге /Start измените приветственную фразу бота, добавьте кнопочное меню и ссылку на ваш сайт: Перейдите на шаг /Start. В секции Реакции бота выберите блок Текст и измените приветствие бота в поле Реплика бота на Добрый день! Я бот-помощник. Чем я могу помочь? Ниже выберите Добавить реакцию. В появившемся меню выберите Группа кнопок → Добавить кнопку.', 'Функция first Кликните на Завершен успешно в блоке HTTP запрос, чтобы создать экран, на который бот перейдет, если поисковый сервис отработал корректно. На новом экране добавьте блок Условия Добавьте единственное условие вида $items.first() Функция first вернет первый элемент из массива, если массив не пуст. Таким образом бот пытается вытащить первый навык из результатов поиска, и если там что-то есть, то условие сработает, и бот перейдет на следующий экран. Нажмите на Сохранить и кликните на условие $items.first, чтобы связать его с новым экраном, на котором бот должен рассказать о навыке. Функция current На новом экране нужно рассказать о навыке, который мы нашли. Для этого добавьте блок Текст Тут бот вызывает функцию current, чтобы получить данные о текущем навыке из массива items. Из поля name можно получить название навыка. В поле examples хранится массив с примерами запросов. $items.current().name. Просто скажите Алисе - ""$items.current().examples\\[0]"". Так бот формирует строку ответа, например Футбольная игра Яндекса. Просто скажите Алисе - ""запусти навык футбольная игра"". Функция next Теперь нужно дать пользователю возможность послушать информацию о следующем найденном навыке. Для этого добавьте на этот же экран кнопку ""Еще варианты"". Кликните на нее, чтобы создать новый экран. На нем добавьте блок Условия Здесь тоже только одно условие $items.next() Функция next переместит бота на следующий элемент в массиве items, если там еще есть элементы.', 'Теперь не придется просить клиентов загрузить файл на сторонний сервис, и можно будет получить нужные документы не отвлекаясь от диалога! Подробнее о том, как пользоваться блоком, мы написали в статье Исправлено Убрали всплывающее окно, которое появлялось при открытии чат-бота в конструкторе, если вы не установили категорию ботов Исправляли ошибки верстки Убирали мелкие баги', 'Работа с файловой системой в ECMAScript 6 Боты в среде исполнения ECMAScript 6 имеют доступ к файловой системе. Благодаря ему боты могут выполнять ряд задач, которые требуют скачивания файлов на диск и их обработки, например: Конвертация между различными форматами данных. Самостоятельная генерация файлов и отправка их пользователю. У каждого бота есть специальные директории, в которых ему разрешены операции на чтение и запись. Для манипуляций над этими директориями используйте встроенный сервис $storage. Само взаимодействие с файловой системой вы можете выстроить с помощью стандартного модуля Node.js node:fs или аналогичных библиотек. Встроенный сервис $storage Встроенный сервис $storage предназначен для работы с хранилищем файлов из бота на ECMAScript 6. Все его методы: Являются асинхронными — всегда используйте их с ключевым словом await. Вызываются без аргументов. Хранилище для файлов в рамках запроса Метод $storage.getRequestDir возвращает путь до директории, где бот может хранить файлы, нужные во время обработки одного запроса. После обработки запроса директория автоматически очищается. Иногда может потребоваться очистить ее вручную. Например, если в одной точке сценария идет последовательная работа с несколькими файлами и вам нужно динамически освободить место от старых файлов, чтобы загрузить новые. Для этого используйте метод $storage.deleteRequestDir.', 'Записная книжка В этом уроке мы рассмотрим создание бота, который записывает данные в Google Таблицу и читает ранее записанные заметки. В этом уроке мы покажем вам отрезок сценария, который поможет: поочередно выводить данные из строк таблицы; выводить значения определенной строки и определенного столбца;\\* сообщать, если данные из таблицы прочитаны и больше данных нет. Полностью сценарий выглядит так: Шаг 1. Экран приветствия Добавьте приветствие и предложение читать или записать заметки: Привет! Я могу прочитать твои заметки или сделать запись. Также добавьте две кнопки ""читать"" и ""писать"". Шаг 2. Добавьте реплику Добавьте рядом еще один текстовый блок с текстом: Что записать? Добавьте к этому экрану блок фраз с примером: $TEXT Шаг 3. Создайте HTTP-запрос От $TEXT протяните связь и создайте HTTP-запрос. Перейдите к этой инструкции для создания апплета IFTTT для записи в таблицу. Оформите запрос следующим образом: поле URL оформите так, как описано в инструкции по ссылке. метод запроса POST на вкладку BODY скопируйте следующее: { ""value1"" : ""$TEXT"" } на вкладке HEADERS: Content-Type application/json Шаг 4. Добавьте реакцию на успешное завершение От варианта Завершен успешно Http-запроса протяните связь и создайте текстовый блок, на котором разместите сообщение об успешной записи: Записал. Будем читать или записать еще одну? Также, на этот экран добавьте кнопки Читать и Записать еще. Шаг 5.', 'Для этого: Перейдите в BotFather Напишите команду /mybots Выберите нужного бота Перейдите в Bot Settings → Group Privacy Выберите Turn off Должна появиться фраза Privacy mode is disabled for Bot Удалите $rawRequest Вернитесь в сценарий бота. Теперь можно удалить блок, который содержит $rawRequest.message.chat.id. Опубликуйте бота Опубликуйте бота в Telegram и дождитесь публикации: Протестируйте бота Теперь напишите в Telegram боту (не в группу). Ссылка на бота есть в BotFather, в сообщении, в котором вы получали токен бота. :size=400 Запустите новую сессию с помощью /start, пришлите боту сообщение и убедитесь, что оно приходит в группу: :size=300 :size=300 Если ваши пользователи напишут боту, сообщения от них также будут публиковаться в группу в Telegram. Что сделать, чтобы бот отвечал пользователям? Чтобы бот отвечал пользователям в группе в Telegram, вам нужно добавить бота в администраторы группы. Если этого не сделать, бот будет реагировать только если пользователь напишет / и затем название интента. Например, /привет. Вам также может быть интересно Как отправить сообщение в Telegram Как валидировать городской номер телефона Авторизация в Telegram Инлайн-кнопки']"	"Вы можете научить бота принимать файлы, используя блок ""Загрузка файла"". Для этого:

1. Перейдите на экран, на котором вы хотите разместить блок ""Загрузка файла"".
2. Нажмите кнопку ""Добавить блок"" и выберите блок ""Загрузка файла"" из списка доступных блоков.
3. В настройках блока ""Загрузка файла"" вы можете указать, какой тип файлов вы хотите принимать (например, изображения, документы и т.д.).
4. После того, как пользователь отправит файл, вы сможете обработать его в дальнейшем сценарии бота.

Обратите внимание, что для обработки файлов вам может потребоваться использовать соответствующие инструменты и библиотеки, в зависимости от используемой платформы и языка программирования."	0.0	0.9479934829778102	0.1249999999875
Сколько в JAICP классификаторов и TTS провайдеров?	"[""'4 классификатора: Transformer, Classic ML, Deep learning, STS. Также можно упомянуть паттерны 7 TTS провайдеров: 3iTech, Aimyvoice, Azure, Google, Сбер, Яндекс, SaluteSpeech.'""]"	"['Провайдеры телефонии JAICP позволяет использовать телефонию различных сторонних провайдеров. В этой статье вы можете ознакомиться с некоторыми из них. Mango Office Mango Office — провайдер виртуальных ATC и облачных коммуникаций. После регистрации в Mango Office создайте новое SIP-подключение в JAICP. При настройке SIP-подключения используйте данные из раздела Телефония > Учетная запись SIP в Mango Office. New-Tel New-Tel — популярный провайдер, который предоставляет подключение к телефонии, виртуальные номера и многое другое. После регистрации в New-Tel создайте новое SIP-подключение в JAICP. При настройке SIP-подключения используйте данные из раздела Настройки телефонии > Настройка SIP-аккаунта для транка в New-Tel. Если вы используете провайдера New-Tel, отключите опцию Требуется регистрация в блоке Расширенные настройки SIP-подключения в JAICP. SIPLink SIPLink — провайдер телефонии для бизнеса с широким спектром функций. После регистрации в SIPLink создайте новое SIP-подключение в JAICP. При настройке SIP-подключения используйте данные из раздела Номера > SIP настройки в SIPLink. Vonage Vonage — провайдер облачных решений для бизнес-коммуникаций. Подробнее о подключении провайдера Vonage Novofon Novofon — облачная ATC c быстрой конфигурацией и большим выбором виртуальных номеров. После регистрации в Novofon создайте новое SIP-подключение в JAICP. При настройке SIP-подключения используйте данные из раздела Настройки > Подключение по SIP в Novofon.', 'Бизнес-тарифы: JAICP Business Standard JAICP Business Pro JAICP Business Pro+ JAICP Business Ultra JAICP Business Enterprise Исправлено', 'Чем различаются алгоритмы классификатора Требования к обучающей выборке различаются в зависимости от того, какой алгоритм классификатора выбран в настройках проекта. Чтобы изменить алгоритм классификатора для проекта, нажмите в правом верхнем углу , выберите Свойства проекта и перейдите на вкладку Классификатор. STS STS (Semantic Textual Similarity) — алгоритм, который сравнивает семантическую близость слов. Он учитывает инверсию, словарные формы слов, их синонимы и другую информацию. Преимущества STS: Хорошо проявляет себя на небольших выборках: даже если каждый интент содержит всего одну тренировочную фразу, алгоритм будет работать. Позволяет использовать сущности в тренировочных фразах. Не чувствителен к неравномерному распределению фраз по интентам. Различает семантически близкие интенты лучше, чем Classic ML. Обладает самыми гибкими и интерпретируемыми настройками. Используйте расширенные настройки NLU, чтобы адаптировать алгоритм под ваш проект. Например, настройте параметр synonymMatch, чтобы отрегулировать вес совпадений по синонимам. Слишком тонкие настройки NLU могут уменьшить качество классификации при добавлении новых тренировочных фраз. Кроме того, настройки, адаптированные под один проект, могут не подойти для другого. Classic ML Classic ML — стандартный алгоритм машинного обучения для распознавания интентов на основе логистической регрессии. Преимущества Classic ML: Сохраняет хорошую скорость работы при высоких нагрузках на бота.', 'Для тарифа JAICP Free действует ограничение 2 оператора, 1 группа; для остальных тарифов — 100 операторов, 100 групп.', 'В этом релизе мы сделали возможным более гибкое поведение. При публикации бота в тестовый виджет, отдельный канал или все каналы проекта вы можете проконтролировать режим, в котором будут запущены тесты. Выбор режима запуска тестов на верхней панели Выбор режима запуска тестов при публикации бота в канал Выбранный режим запоминается и используется при дальнейших публикациях бота, пока не будет изменен. Новые провайдеры распознавания речи Мы постоянно расширяем список провайдеров распознавания речи (ASR), которых вы можете использовать в своих телефонных проектах JAICP. С этого релиза вы можете подключить ASR от провайдеров: Kaldi — разверните сервис ASR с использованием библиотеки Kaldi и укажите его URL и API-ключ при создании подключения. АСМ Решения — выберите подключение, предоставляемое Just AI, или создайте собственное (для него потребуется токен доступа). Документация к типам ответов бота В документации мы полностью переработали раздел Ответы бота. Добавление типизированных ответов в $response.replies — низкоуровневый способ управлять реакциями бота. Его преимущество по сравнению с DSL-тегами реакций и встроенным сервисом $reactions в том, что он позволяет отправлять любые виды реакций, которые поддерживаются в JAICP. Теперь каждому типу ответа посвящена отдельная статья, в каждой из которых вы узнаете: Какие свойства принимают ответы с тем или иным типом. Есть ли в интересующем вас канале ограничения на использование определенных типов ответов.', 'Релиз JAICP 1.10.15 A/B-тестирование. Бесплатный тариф Developer. 3iTech ASR/TTS. Массовое добавление меток. Новые колонки в отчетах по сессиям и сообщениям. В релизе 1.10.15 мы представляем новую функциональность A/B-тестирование, с помощью которой вы сможете проверять различные гипотезы внутри сценария. В аналитике мы реализовали возможность массово добавлять метки и добавили новые колонки в отчеты по сессиям и сообщениям. Другие доработки: ASR и TTS от 3iTech. Бесплатный тариф Developer. A/B-тестирование В разделе Аналитика появилась новая вкладка A/B-тестирование. Здесь вы сможете создавать эксперименты, тем самым проводя A/B-тестирование внутри сценария. Сравнивайте полученные результаты и оптимизируйте свой сценарий. Подробнее об A/B-тестировании Аналитика Разное ASR и TTS 3iTech Теперь вы можете настроить собственное подключение ASR и TTS через провайдера 3iTech. Подробнее о подключении ASR/TTS 3iTech Тариф Developer В JAICP больше нет демо-периода, а тариф Developer стал абсолютно бесплатным. После регистрации аккаунта в JAICP вам будет автоматически подключен тариф Developer. Если вы уже зарегистрировались в JAICP и сейчас находитесь на демо-периоде, продолжайте разрабатывать ботов. Мы автоматически переключим вас на тариф Developer. Если вы сейчас на тарифе Developer, то в следующем месяце списания денег не произойдет. Тариф автоматически станет для вас бесплатным.', 'Разместите его в директории src или по пути, который вы задали самостоятельно как параметр npmRcFile в chatbot.yaml. Например, вы можете использовать не только пакеты из публичного реестра https&#x3A;//registry.npmjs.org/, но и из приватного. Для этого в файле .npmrc укажите адрес реестра и токен для авторизации: Использование встроенного JS API JAICP предоставляет встроенный JS API — набор глобальных переменных, функций и сервисов, которые доступны из любой точки сценария. С помощью него можно реализовать часто используемую функциональность, актуальную для самых разных проектов: Переменные $session и $client предоставляют нативное хранилище данных о сессии и клиенте без необходимости подключать к боту свою базу данных. Сервис $http дает возможность интегрировать бота практически с любой внешней системой, к которой можно обратиться по HTTP API. Сервисы $analytics, $imputer, $pushgate и ряд других позволяют вызывать из сценария различные специализированные подсистемы самой JAICP. На данный момент внутри тегов scriptEs6 и зависимостей на ES6 вы можете использовать ограниченное подмножество JS API — не все возможности перенесены в новую среду исполнения. Список доступных возможностей приведен ниже и постепенно будет расширяться. Если нужная функциональность напрямую не связана с JAICP, используйте внешние зависимости, чтобы компенсировать ее недостаток. Например, вместо $http отлично подойдет HTTP-клиент Axios.', 'Релиз JAICP 1.11.9 Поддержка ASR/TTS от Microsoft Azure. Подключение ASR/TTS от SaluteSpeech от Сбера. Токены для чувствительных данных в сценарии. Переопределение значений переменных $client и $session в XML-тестах. Отправка файлов клиенту в чат-виджете. Облегченное подключение GitHub-репозитория к проекту. Обновленный интерфейс раздела Аналитика > Клиенты. Новый параметр при создании канала i-Digital WhatsApp. Инструкции по выпуску персональных токенов для Bitbucket и GitLab. Новая статья о том, как обратиться в техническую поддержку. Новые провайдеры ASR/TTS Мы постоянно расширяем список ASR/TTS-провайдеров, которые вы можете использовать в JAICP. В этом релизе мы добавили: поддержку ASR/TTS от Azure; возможность подключить ASR/TTS от SaluteSpeech by Sber. Поддержка ASR/TTS от Azure Чтобы использовать ASR/TTS от Azure, вы можете при создании телефонного канала: Выбрать этого провайдера из списка для ASR и TTS. Настроить собственное подключение ASR/TTS Azure. Подключение ASR/TTS от SaluteSpeech Вы также можете настроить собственное подключение ASR/TTS SaluteSpeech от Сбера. Токены для чувствительных данных Чтобы хранить и использовать чувствительные данные в проекте, теперь вы можете добавить токены. Токен — это пара «ключ-значение», содержащая данные, которые не должны быть доступны публично, например, пароли или ключи доступа. Значения токенов хранятся в зашифрованном виде. Добавлять, изменять и удалять токены могут только пользователи с ролью администратора.', 'Релиз JAICP 1.9.10 ZB-7612 Регистрация и авторизация в JAICP с использованием учетной записи GitHub или Google. ZB-7614 Выбор провайдеров ASR/TTS. ZB-7475 Просмотр лога успешной публикации канала в списке оповещений. ZB-7541 Размещение запросов в службу технической поддержки. ZB-7661 Не отображается статус публикации. ZB-7495 Перемещение между диалогами. Регистрация и авторизация через GitHub и Google Регистрация и авторизация в JAICP стала ещё удобнее! Теперь для этого вы можете использовать учетные записи GitHub или Google. Выбор провайдеров ASR/TTS В ботах, которые совершают и принимают звонки используется синтез и распознавание речи: Text-To-Speech (TTS) или синтез речи — процесс генерирования речи по печатному тексту. Automatic Speech Recognition (ASR) или распознавание речи — процесс преобразования речи в текст. Теперь при создании телефонного канала вы можете выбрать провайдеров для ASR и TTS. spelling spelling Оптимизация работы платформы Публикация в канал В список оповещений мы добавили возможность просмотреть лог при успешной публикации в канал. Для этого нажмите кнопку Посмотреть лог под выполненной задачей. В логе доступен результат публикации сценария, в том числе список успешно пройденных тестов. Техническая поддержка На верхней панели мы добавили ссылки для перехода в сообщество JAICP, а также для обращения в техническую поддержку. Исправлено', 'Вы можете использовать сторонние сервисы для распознавания именованных сущностей и интентов в проектах JAICP. Чтобы подключить внешний NLU-сервис к проекту, используйте в расширенных настройках поле externalNluSettings: nluProviderSettings — объект, определяющий, где будет выполняться действие NLU. markup — параметры для запросов на разметку. nluType — тип NLU. Может быть установлен внешний external или внутренний internal NLU. ner — параметры для распознавания именованных сущностей. classification — параметры для запросов на классификацию интентов. language — язык внешнего NLU. Если не установлен, будет использован язык из настроек проекта. nluActionAdditionalProperties — дополнительные настройки для внешнего NLU-сервиса. modelID — ID модели классификатора. classifierName — имя классификатора. Использование В проекте нельзя одновременно использовать интенты и сущности и от внешнего NLU-сервиса, и от CAILA. В проекте JAICP вы можете: Использовать сущности и интенты внешнего NLU-сервиса. Установите ""nluType"": ""external"" для параметров markup, ner и classification. В сценарии интенты доступны по тегу intent, а сущности — по тегу q. Визуальная настройка в разделе CAILA для интентов и сущностей внешнего NLU-сервиса не поддерживается. Использовать сущности внешнего NLU-сервиса и интенты CAILA. Установите ""nluType"": ""external"" для параметра ner и ""nluType"": ""internal"" для markup и classification.']"	В JAICP есть два типа классификаторов: STS (Semantic Textual Similarity) и Classic ML. По провайдерам TTS (Text-To-Speech) нет информации в данной документации.	0.5	0.9407631342344983	0.0
Для каких языков доступно исправление ошибок и опечаток в запросе?	"[""'Функция доступна только для проектов на русском и украинском языках'""]"	['Функция detectLanguage определяет язык запроса при помощи метода $caila.detectLanguage. Исключение составляет первый запрос /start — для него функция возвращает язык по умолчанию, заданный в дескрипторе сценария. Функция redirectToBot переключает контекст в нужного одноязычного бота при помощи context-switch. По умолчанию делается переход в стейт /Hello. В качестве данных, общих между ботами, передается все содержимое объекта $session. Функция processRequest используется для обработки всех запросов, которые принимает бот-роутер: она определяет язык запроса и переключает контекст на нужного одноязычного бота. Если бот для языка запроса не задан в дескрипторе, выдается сообщение о том, что язык не поддерживается. Код сценария В файле main.sc необходимо подключить файл router.js при помощи тега require, а также предусмотреть два стейта: стейт /Request для приема всех запросов, переданных в роутер; стейт-заглушку /Redirect, который будет использоваться для маршрутизации запросов. К обоим стейтам следует привязать в качестве обработчика функцию processRequest. Далее мы перейдем к созданию первого одноязычного бота.', 'Поддержка других языков Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов Поддержка русского языка Поддержка других языков (вы находитесь здесь) Публикация в канал В следующем разделе пошагового сценария мы создадим бота на английском языке в составе многоязычного бота. Создайте новый проект, в качестве языка NLU выберите английский. Наполнение интентов Бот на английском языке должен поддерживать ровно те же интенты /hello и /book, что и бот на русском языке, с отличиями только в языке тренировочных фраз и вопросов для слот-филлинга. Интент для бронирования Сценарий Код англоязычного бота будет практически полностью совпадать с русскоязычным: изменения затронут только конфигурацию и тексты ответов. В разделе injector файла chatbot.yaml потребуется указать ISO-код английского языка вместо русского: В файле main.sc переведите все тексты ответов бота на английский язык, а также измените путь к зависимости на справочник имен на английском языке: Файл routerClient.js скопируйте из русскоязычного бота без изменений. Подключение к роутеру Так же, как и для русского языка, опубликуйте созданного бота в любом канале, скопируйте идентификатор бота и зарегистрируйте его в injector бота-роутера: Другие языки В многоязычного бота, построенного по приведенной схеме, легко добавить поддержку произвольного числа других языков.', 'Бот для маршрутизации запросов Это часть серии статей, посвященной созданию многоязычного бота. Принцип работы Маршрутизация запросов (вы находитесь здесь) Поддержка русского языка Поддержка других языков Публикация в канал В этом разделе мы напишем реализацию бота-роутера, предназначенного для маршрутизации запросов клиента в одноязычного бота на нужном языке. Перейдите в JAICP и создайте новый проект. Язык NLU и другие настройки данного проекта могут быть любыми. Перейдите в раздел Редактор. Дескриптор сценария В соответствии с предложенной схемой многоязычного бота роутер должен иметь доступ к следующим конфигурируемым параметрам: Язык основного одноязычного бота, на который по умолчанию будет посылаться первый запрос. Текст сообщения в случае, если поступил запрос на неподдерживаемом языке. Идентификаторы всех одноязычных ботов, между которыми необходимо переключать контекст. Зададим данные параметры в разделе injector дескриптора сценария chatbot.yaml: Значение поля defaultLanguage и ключи в словаре bots должны соответствовать ISO-кодам языков, которые будет поддерживать бот. Значения словаря bots временно оставьте пустыми. Заданные параметры будут доступны из сценария через объект $injector. Функции Создадим в папке src файл router.js и поместим туда код, реализующий функциональность бота-роутера. Рассмотрим используемые функции. Все функции в числе аргументов принимают объект $context, представляющий собой текущий контекст обработки запроса.', 'Удалить короткие фразы — удаление всех фраз короче указанного числа знаков с учетом пробелов. Удалить длинные фразы — удаление всех фраз длиннее указанного числа знаков с учетом пробелов. Исправить опечатки — исправление орфографических ошибок и опечаток. Параметр включен по умолчанию и доступен только для русского и украинского языков. Удалить стоп-слова — словарь стоп-слов встроен в платформу и доступен только для русского языка. Распознать сущности — поиск активных системных и пользовательских сущностей во фразах. Например: «завтра в 16:00» будет заменено на «завтра в @duckling.time». Удалить дубликаты — после удаления останется только одно вхождение для каждой фразы. Параметр включен по умолчанию. Если вы хотите перед удалением просмотреть дубликаты, отключите этот параметр и воспользуйтесь разметкой по дубликатам. Нажмите Обработать. Методы разметки Если вы обрабатываете большой объем фраз, методы разметки помогут сгруппировать их, чтобы упростить распределение фраз по интентам. Для этого на вкладке Разбор фраз в разделе Загруженные логи нажмите Разметить и выберите метод разметки. Вы можете разметить фразы: По интентам. По дубликатам. По ключевым словам. По кластерам. После разметки датасета распределите фразы по интентам. Вы также можете распределить фразы по интентам вручную: Выберите фразу или несколько фраз и нажмите Добавить в интенты. Появится окно выбора интента. Выберите подходящий интент или создайте новый. После этого нажмите Добавить фразу.', '$caila.inflect Преобразует слова и словосочетания в нужную грамматическую форму. Метод $caila.inflect поддержан для русского и украинского языков. Синтаксис Принимаемые аргументы Метод принимает 2 обязательных аргумента. Если к одному и тому же слову нужно применить несколько тегов, то они отделяются друг от друга запятой. Возвращаемое значение Метод возвращает слова и словосочетания в требуемой грамматической форме. Пример вызова Грамматические теги Метод $caila.inflect использует библиотеку pymorphy2. В качестве грамматических тегов в pymorphy2 используются теги, принятые в словаре OpenCorpora. Падеж Число Род Лицо Время Ознакомиться с полным списком тегов вы можете на сайте OpenCorpora. Версии словаря В словаре OpenCorpora могут встречаться ошибки преобразования слов. Если результат $caila.inflect не соответствует ожидаемому, вы можете использовать метод $caila.inflectWithDictVersion. Метод $caila.inflectWithDictVersion также использует библиотеку pymorphy2, но он позволяет выбрать другую версию словаря. Метод принимает 3 обязательных аргумента. Пример Методы $caila.inflectWithDictVersion с версией словаря v1 и $caila.inflect возвращают одинаковый результат. Если результат обоих методов не соответствуют ожидаемому, то обратитесь в нашу техническую поддержку. Использование в сценарии', 'Если слово было добавлено в словарь, при запросе клиента с исходным текстом, оно будет исправлено на вариант из словаря Например, слово купитъъ будет заменено на купить. Для удаления слова нажмите на гипотезу в тестовом виджете, в секции Словарь пользователя нажмите крестик напротив слова. Не исправлять Если была выбрана опция Не исправлять, то при запросе клиента с исходным текстом, слово исправлено не будет. Например, слово купитъъ не будет заменено. Скачивание и загрузка словаря При помощи CAILA API вы можете скачать содержимое пользовательского словаря или загрузить другой словарь. {token} — API-ключ CAILA проекта. При использовании метода для просмотра словаря, результат будет возвращен в формате: Где: 2 — слово было добавлено в словарь, запрос клиента будет исправлен. При повторном выборе альтернативной гипотезы из словаря, данное слово будет в приоритете. При каждом последующем выборе приоритет повышается на 1. 1 — слово было добавлено в словарь, запрос клиента будет исправлен. \\-1 — слово исключено, исправления не последует. Обратите внимание, что для загрузки в проект словарь должен соответствовать формату. Подробное описание CAILA API: методы, параметры запроса, форматы ответа, примеры, возвращаемые ошибки >', 'Функция isSameLanguage вызывает метод $caila.detectLanguage для определения языка и проверяет, совпадает ли результат вызова с языком, заданным по умолчанию в injector. Функция returnToRouter возвращает контекст на бота-роутера при помощи context-return. По умолчанию делается переход в стейт /Redirect. Код сценария В файле main.sc разместите код сценария бота на русском языке. В начале подключаются все необходимые зависимости. В данном случае это справочник имен и модуль слот-филлинга из zb-common, а также созданный ранее файл routerClient.js. Стейты /Start и /Hello отвечают соответственно за технический запуск бота и за обработку приветствия. Во вложенном стейте Name происходит обработка имени, распознанного при помощи паттерна $Name, и сохранение информации об имени в сессионные данные. Стейт /Book и вложенный стейт Yes предназначены для уточнения номера комнаты при помощи слот-филлинга. Названный номер также записывается в $session. Обратим особое внимание на реализацию стейта /NoMatch для обработки нераспознанных запросов. Сначала производится проверка, совпадает ли язык запроса с языком бота. При их несовпадении контекст возвращается боту-роутеру с передачей всех данных, которые были ранее записаны в $session.booking. Контекст возвращается в стейт-заглушку /Redirect.', 'От опции Любая другая фраза создайте экран и поместите на него реплику бота на случай, если клиент напишет что-то непредсказуемое. На этот раз не нужно делать интент доступным из любой точки сценария. В противном случае глобальный интент $TEXT, настроенный для старта диалога, не будет отлавливать реплики из других экранов и не будет переводить диалог на экран приветствия. Системные переменные При работе с Открытыми линиями Битрикс24 вы можете использовать системные переменные. $bitrix.user – данные о клиенте. $bitrix.user.id – ID клиента в CRM системе Битрикс24. $bitrix.user.name – имя клиента в CRM системе Битрикс24. $bitrix.params – данные о текущем диалоге. Включает в себя: $bitrix.params.dialogId — ID диалога. $bitrix.params.fromUserId— ID отправителя. $bitrix.params.toUserId — ID получателя. $bitrix.params.chatId — ID чата. $bitrix.params.messageId — ID сообщения. $bitrix.params.message — сообщение. $bitrix.params.messageType — тип сообщения. $bitrix.params.chatType — тип чата (групповой чат, чат для звонка, чат открытой линии и т.д.). $bitrix.params.authorId — ID владельца чата. $bitrix.params.chatEntityType — внешний код для чата (тип). $bitrix.params.chatEntityData1 — внешние данные для чата. $bitrix.params.chatEntityData2 — внешние данные для чата. $bitrix.params.chatEntityData3 — внешние данные для чата. $bitrix.params.language — язык чата. Перевод на оператора Вы можете использовать Битрикс24 как операторский канал.', 'Исправление орфографии Функция Исправление орфографии позволяет исправлять орфографические ошибки и опечатки в запросах клиентов. Функция доступна только для проектов на русском и украинском языках. Настройка проекта Для включения функции перейдите к редактированию проекта. Выберите вкладку Классификатор > переведите переключатель Исправление орфографии в активное положение. Вы также можете включить Исправление орфографии неспосредственно при тестировании сущностей и интентов в тестовом виджете. Подключение исправления орфографии в словах⠀⠀⠀Подключение исправления орфографии в словах Работа со словарем Вы можете самостоятельно настроить словарь для проекта. Например, отменить исправление опечаток или добавить слово в словарь. Перейдите на страницу Интенты или Сущности > в правом нижнем углу нажмите тестировать. В текстовое поле введите фразу > протестировать Enter. Тестирование сообщения с ошибками⠀⠀⠀Исправление слова с ошибками с помощью системного словаря ⠀⠀Исправление слова с ошибками с помощью словаря пользователя Нажмите на исправленное слово. Здесь вы можете выбрать одну из представленных гипотез, добавить слово в словарь или отменить исправление слова. Добавить в словарь Для добавления в словарь нажмите на исправленное слово > Добавить в словарь > исправьте слово или оставьте гипотезу сервиса > нажмите Добавить.', 'Сбер language Язык, на котором распознается речь. model Языковая модель для распознавания речи. 3iTech lang Язык, на котором распознается речь. model Языковая модель для распознавания речи.']	Исправление ошибок и опечаток в запросе доступно только для проектов на русском и украинском языках.	1.0	0.8628871088629575	0.23611111109930555
В JAICP доступен синтез речи с динамическими параметрами от тинькофф?	"[""'Нет, но вы можете воспользоваться синтезом речи с переменными от Just AI или Яндекса'""]"	"['Чтобы воспользоваться гибридным синтезом речи Just AI, вам потребуется отправить заявку на подключение аккаунт-менеджеру. Когда технология будет подключена, вам станет доступен раздел Гибридный синтез речи, где вы сможете: Загружать подготовленные аудиофайлы в JAICP. Размечать переменные в шаблонах реплик из загруженных аудио. Тестировать, как звучат реплики при подстановке различных значений переменных. Реплики, сгенерированные при помощи гибридного синтеза, доступны для использования из сценариев ботов через встроенный JS-сервис $imputer, а также сторонними приложениями через Imputer API. Подробнее о гибридном синтезе от Just AI Украинский язык Мы продолжаем расширять число языков, которые могут понимать боты на JAICP, и добавили в CAILA поддержку украинского языка. Проекты на украинском языке поддерживают NLU через паттерны и интенты, а также системные сущности Duckling. Дополнительно поддерживаются метод $caila.inflect и исправление орфографии. Стикеры в Telegram Теперь в сценариях для канала Telegram вы можете обрабатывать событие stickerEvent, которое наступает, когда клиент отправляет стикер в чат с ботом. В стейте для обработки события через $request.data.eventData доступны метаданные стикера: размер, анимированность, соответствующий эмодзи и другая информация. Обновления документации Как обучать интенты В статье Как обучать интенты мы собрали практические рекомендации по построению классификатора интентов через NLU-сервис CAILA.', 'Релиз JAICP 1.11.3 Синтез речи с переменными. Входящий канал LiveTex. Новые требования для кнопок в WhatsApp от i-Digital. Синтез речи с переменными Теперь JAICP поддерживает технологию синтеза речи с переменными, которая позволяет заменить несколько слов в аудиозаписи, сделанной диктором. Заменяет слова специальная модель синтеза речи, которая обучена на аудиозаписях, сделанных тем же диктором. Такая модель способна «подстраиваться» под интонации диктора, благодаря чему переменные звучат естественно и бесшовно вклеиваются в аудиозапись. Данная возможность находится в раннем доступе. Оставьте заявку на адрес client@just-ai.com, чтобы получить подробную информацию. LiveTex Помимо операторского канала и суфлера LiveTex вы можете также подключить входящий канал LiveTex. В него уже будут включены возможности операторского канала. Подробнее о входящем канале LiveTex Обновления документации В канале WhatsApp от i-Digital изменились требования к регистрации текстовых и инлайн-кнопок.', 'SpeechKit Brand Voice Adaptive от Яндекса Яндекс поддерживает синтез речи с переменными на базе технологии Yandex SpeechKit Brand Voice Adaptive. Возможность интеграции с Yandex SpeechKit Brand Voice Adaptive через JAICP находится в раннем доступе. Оставьте заявку на адрес client@just-ai.com для получения подробной информации. Использование Чтобы использовать технологию в проектах на JAICP, необходимы следующие действия. Подготовка входных данных. Подготовьте корпус шаблонов и записей диктора для обучения модели. Следуйте всем требованиям, предъявляемым к качеству данных. Данные будут переданы в Яндекс. Подробнее о требованиях к формату входных данных в документации Yandex SpeechKit Подготовка модели синтеза. Яндекс обучает модель. Цикл обучения занимает порядка календарного месяца. Размещение модели синтеза. Яндекс размещает обученную модель в Yandex.Cloud и выдает ID модели, который можно использовать в проекте. Настройка синтеза в JAICP. В параметрах телефонного канала заполните настройки синтеза. В качестве голоса укажите полученный ID модели: Заполнение настроек синтеза для телефонного подключения Далее вы можете использовать в сценарии синтез речи с переменными для генерации ответов бота. Для этого вам потребуется метод $reactions.ttsWithVariables. Just AI — партнер Yandex SpeechKit. Мы можем помочь вам с регистрацией аккаунта, созданием проекта и подготовкой данных. При необходимости оставьте комментарий к заявке.', 'Удалять дубликаты Алгоритмы Classic ML и Deep Learning чувствительны к дубликатам тренировочных фраз в интентах. Вы можете убедиться в этом следующим образом: Создайте новый проект, в настройках проекта выберите классификатор Deep Learning. Перейдите в меню CAILA → Интенты и выберите интент привет. В нем одна тренировочная фраза привет. Нажмите Тестировать и введите запрос с похожим смыслом, например всем привет. Закройте тестовый виджет, добавьте в интент еще одну тренировочную фразу привет и повторите шаг 3. После того как вы добавили дубликат, вес совпадения одного и того же запроса увеличился. В ситуации, когда у фразы достаточно высокий вес совпадения с несколькими интентами, вес неправильного интента может оказаться выше остальных только за счет дубликатов. Алгоритмы STS и Transformer вычисляют семантическую близость запроса с каждой тренировочной фразой по отдельности. Если вы проделаете тот же эксперимент с проектом на STS или Transformer, то убедитесь, что они нечувствительны к дубликатам и не добавляют вес совпадения интентам с дублированными фразами. Однако лучше избегать их. Избегать слишком похожих фраз При формировании выборки важно избегать не только фраз, полностью совпадающих друг с другом, но и различающихся только одним-двумя словами или порядком слов.', 'Если true, используется TF-IDF. Он вычисляет значимость слова или выражения в контексте всех тренировочных фраз. Рекомендуется для проектов с небольшой выборкой, чтобы повысить качество распознавания интентов. Векторизация будет проходить медленнее, чем при значении false, но ее качество будет выше. Если false, используется CountVectorizer. Он вычисляет, как часто слова или выражения встречаются в интенте. Рекомендуется для проектов со средней или большой выборкой. Векторизация будет проходить быстрее, но при работе с небольшой выборкой точность алгоритма будет снижаться. min_document_frequency — минимальная частота, с которой слово должно встречаться в тренировочных фразах, чтобы оно учитывалось при векторизации и классификации. Значение по умолчанию — 1. Если вы работаете со средней или большой выборкой, повысьте значение параметра, чтобы ускорить обучение классификатора. Слова, которые редко встречаются в выборке, не будут учитываться. Если вы работаете с небольшой выборкой, менять значение по умолчанию не рекомендуется. Deep Learning Параметры для классификатора Deep Learning: kernel_sizes — список размеров сверточных ядер. Сверточное ядро — размер контекстного окна, на которое классификатор будет обращать внимание. Например, ""kernel_sizes"": \\[3] означает, что модель будет находить признаки в тексте, основываясь на всех тройках соседних слов. Для одной модели может быть задано несколько сверточных ядер. n_filters — количество фильтров.', 'ECMAScript 6 В среде исполнения ECMAScript 6 для запуска кода в JAICP используется платформа Node.js, поэтому вы можете использовать в нем асинхронные операции. Однако у асинхронного кода в JAICP есть важное ограничение: чтобы использовать его результат для ответа пользователю через встроенный сервис $reactions, его всегда нужно дожидаться при помощи ключевого слова await. Это связано с тем, что методы $reactions являются синхронными и работают только во время обработки запроса. Методы сервиса $conversationApi в среде исполнения ECMAScript 6 также отправляют ответ в канал мгновенно, но кроме того, они делают это асинхронно и не привязаны к обработке запроса пользователя. Поэтому вы можете вызывать их из функций обратного вызова, не дожидаясь, пока они будут вызваны. Использование в сценарии В следующем фрагменте сценария бот отвечает на вопрос пользователя о востребованных профессиях с помощью ChatGPT. Для этого: В теге script вызывается встроенный метод $gpt.createChatCompletion. В теге scriptEs6 бот обращается напрямую к OpenAI API. Для этого к боту подключается специализированный npm-пакет. Пока модель генерирует ответ, бот предупреждает пользователя о том, что нужно немного подождать, а затем, когда ответ готов, выводит список востребованных профессий в канал. Пример в ECMAScript 5 Пример в ECMAScript 6 Мы также подготовили более сложный пример бота-переводчика c использованием методов $conversationApi в ECMAScript 6.', 'Распознавание и синтез речи В ботах, которые совершают и принимают звонки, используется распознавание и синтез речи: Automatic Speech Recognition (ASR) или распознавание речи — процесс преобразования речи в текст. Text-To-Speech (TTS) или синтез речи — процесс генерации речи по печатному тексту. При создании телефонного канала вы можете: Выбрать одного из провайдеров ASR/TTS, предоставляемых Just AI. В этом случае из интерфейса JAICP вы можете задать настройки синтеза и распознавания речи: например, выбрать модель распознавания, голос для синтеза и другие параметры. Создать подключение с использованием собственного аккаунта одного из провайдеров ASR/TTS. Если для ASR/TTS вы используете собственное подключение, использование минут ASR/TTS Just AI для вас не тарифицируется. Затем для формирования ответов из сценария вам нужно будет использовать тег a или метод $reactions.answer. Разметка синтеза речи Чтобы сделать речь бота более выразительной, вы можете использовать разметку синтеза речи. JAICP поддерживает специальный язык разметки синтеза речи (SSML), который позволяет настраивать тон, произношение, скорость, громкость речи и пр. Подробнее см. в разделе Разметка синтеза речи. Синтез речи с переменными Вы также можете использовать синтез речи с переменными, если хотите, чтобы бот озвучивал в диалоге переменные значения, зависящие от контекста. Подробнее см. в разделе Синтез речи с переменными.', '$caila.inflect Преобразует слова и словосочетания в нужную грамматическую форму. Метод $caila.inflect поддержан для русского и украинского языков. Синтаксис Принимаемые аргументы Метод принимает 2 обязательных аргумента. Если к одному и тому же слову нужно применить несколько тегов, то они отделяются друг от друга запятой. Возвращаемое значение Метод возвращает слова и словосочетания в требуемой грамматической форме. Пример вызова Грамматические теги Метод $caila.inflect использует библиотеку pymorphy2. В качестве грамматических тегов в pymorphy2 используются теги, принятые в словаре OpenCorpora. Падеж Число Род Лицо Время Ознакомиться с полным списком тегов вы можете на сайте OpenCorpora. Версии словаря В словаре OpenCorpora могут встречаться ошибки преобразования слов. Если результат $caila.inflect не соответствует ожидаемому, вы можете использовать метод $caila.inflectWithDictVersion. Метод $caila.inflectWithDictVersion также использует библиотеку pymorphy2, но он позволяет выбрать другую версию словаря. Метод принимает 3 обязательных аргумента. Пример Методы $caila.inflectWithDictVersion с версией словаря v1 и $caila.inflect возвращают одинаковый результат. Если результат обоих методов не соответствуют ожидаемому, то обратитесь в нашу техническую поддержку. Использование в сценарии', 'Синтез по API Aimyvoice предоставляет HTTP API для синтеза речи голосом из каталога. Так вы можете использовать голоса в сторонних приложениях — например, интегрировать их в голосовых ассистентов. Запрос Адрес POST https&#x3A;//aimyvoice.com/api/v1/synthesize Заголовки Content-Type — application/x-www-form-urlencoded. api-key — токен для доступа к голосу. Чтобы получить токен, выберите нужный голос в каталоге и нажмите Подключить по API. Тело В теле запроса передайте параметр text — текст на русском языке, который вы хотите озвучить. В тексте вы можете использовать разметку синтеза речи, чтобы управлять его звучанием: задавать паузы, ударения, тон и другие особенности произношения. Требования к тексту: Текст должен быть на русском языке. Отдельные слова и словосочетания могут быть на латинице. Ограничение на длину: от 1 до 250 символов без учета разметки. Допустимые спецсимволы: € £ ₽ $ % № # & - — – + \\* = . , ! ? ; : "" \\` \' ° \\\\ / ( ) &lt; > « » ± ^. Примеры При отправке запроса текст должен быть закодирован как URL (через percent-encoding). Ответ Если синтез прошел успешно, в ответ придет строка с бинарными данными. Сохраните содержимое строки в файл с расширением .wav.', 'Чем различаются алгоритмы классификатора Требования к обучающей выборке различаются в зависимости от того, какой алгоритм классификатора выбран в настройках проекта. Чтобы изменить алгоритм классификатора для проекта, нажмите в правом верхнем углу , выберите Свойства проекта и перейдите на вкладку Классификатор. STS STS (Semantic Textual Similarity) — алгоритм, который сравнивает семантическую близость слов. Он учитывает инверсию, словарные формы слов, их синонимы и другую информацию. Преимущества STS: Хорошо проявляет себя на небольших выборках: даже если каждый интент содержит всего одну тренировочную фразу, алгоритм будет работать. Позволяет использовать сущности в тренировочных фразах. Не чувствителен к неравномерному распределению фраз по интентам. Различает семантически близкие интенты лучше, чем Classic ML. Обладает самыми гибкими и интерпретируемыми настройками. Используйте расширенные настройки NLU, чтобы адаптировать алгоритм под ваш проект. Например, настройте параметр synonymMatch, чтобы отрегулировать вес совпадений по синонимам. Слишком тонкие настройки NLU могут уменьшить качество классификации при добавлении новых тренировочных фраз. Кроме того, настройки, адаптированные под один проект, могут не подойти для другого. Classic ML Classic ML — стандартный алгоритм машинного обучения для распознавания интентов на основе логистической регрессии. Преимущества Classic ML: Сохраняет хорошую скорость работы при высоких нагрузках на бота.']"	Документация не содержит информации о доступности синтеза речи с динамическими параметрами от Тинькофф в JAICP.	1.0	0.9420712479080061	0.0
Мне надо подложить звук под голос бота, чтобы не было тишины	"[""'Для телефонного канала вы можете подключить шум контактного центра как фоновый. Как подключить фоновый шум? 1) Обратитесь к вашему аккаунт-менеджеру с запросом на активацию опции использования фонового шума для обзвонов. 2) Перейдите в настройки телефонного канала. Переведите переключатель Использовать шум контактного центра в активное положение. 3) Фоновый шум контактного центра будет применен ко всем обзвонам, которые осуществляются с использованием этого телефонного канала. При переводе на оператора фоновый шум будет отключен.'""]"	['Для этого введите название голоса в поле Голос вручную.', 'Вы можете менять голос бота из сценария в зависимости от характеристик пользователя (например, пола или возраста) или по его желанию.', 'При переводе на оператора фоновый шум будет отключен.', 'Укажите желаемое звучание в атрибуте alias.', 'Тогда ваш бот сможет принимать входящие звонки из Asterisk и переводить их обратно на оператора.', 'В таком случае вы можете составить сценарий так, чтобы бот известил клиента, что все операторы заняты, и предложил оставить номер для связи.', 'tone Тон голоса.', 'После этого должен начаться диалог с ботом.', 'Например, если на экране бот должен вывести текст, а потом перейти на экран, где есть главное меню.', 'Пример Рассмотрим пример создания и отмены будильника.']	Вам необходимо указать желаемое звучание в атрибуте alias. Это позволит подложить звук под голос бота и избежать тишины.	0.33333333333333337	0.9125606385422923	0.0
привет! при каких статусах поле isOk принимает значение true в ответе на $http.query?	"[""'>=200 && < 300'""]"	"['Такая необходимость связана с особенностями языка JavaScript. Математические операции В блоке Условия вы можете совершать математические операции. В JavaScript складывать можно не только числа, но и строки (текст). Например, здесь в результате сложения строковых переменных $answer1 и $answer2 будет выведено ab: Сравнение Вы можете использовать оператор === для сравнения. Данное условие будет отрабатывать, если $score равен пяти. В отличие от оператора ==, который приводит данные к одному типу, оператор === также проверяет тип данных. Подробнее о различиях == и === в JavaScript Выполнение нескольких операций в одной строке Объединять в одной строке несколько операций можно при помощи операторов || или &&. Проверка нескольких условий Одно из условий верно Оператор || говорит о том, что из всех условий одно должно быть истинно. Такое условие будет отрабатывать, если $choice равен или «да», или «может быть». Так как нажатие кнопки равносильно текстовому вводу, после нажатия кнопки «да» значение «да» будет помещено в переменную $choice, затем будет выполнено условие. Оба условия верны Оператор && означает, что каждое из указанных условий должно быть истинно. Условие будет отрабатывать, если $kids равно 2, 3 или 4. То есть, $kids больше или равно 2 и при этом меньше или равно 4.', 'Отправка файлов $http.query позволяет отправлять файлы на внешний сервис. Для этого укажите в настройках запроса поля fileUrl и опционально fileName. Такому запросу автоматически устанавливается заголовок Content-Type со значением multipart/form-data. Запрос отправляется как HTML-форма с полем file, где закодировано содержимое файла в бинарном виде. Если fileName не указан, но fileUrl содержит название файла с расширением, будет взято оно. В противном случае именем файла будет случайный UUID. Типы данных запроса и ответа Чтобы указать тип данных, которые содержатся в запросе и ожидаются в ответе, используйте поле dataType. Обратите внимание на то, как оно взаимодействует с передаваемым HTTP-заголовком Content-Type. Возвращаемое значение Метод возвращает объект со следующими полями: Пример использования В следующем примере выполняется запрос к API сервиса OpenWeather, чтобы получить информацию о текущей погоде в запрашиваемом городе. Пример предполагает, что вы получили собственный ключ к API OpenWeather и сохранили его в проекте как токен OPENWEATHER_API_KEY. $http.query выполняет HTTP-запросы синхронно. Обработка запроса пользователя приостанавливается до тех пор, пока HTTP-запрос не вернет ответ. Во время обработки одного запроса можно выполнить не более 15 вызовов $http.query. При превышении этого лимита метод возвращает ответ со статусом -1 и ошибкой Callback limit reached.', '&lt;mockData> Описание Тег &lt;mockData> позволяет задать заглушки ответов (мок-объекты) на HTTP-запросы из сценария бота. Когда при выполнении тестов в сценарии вызывается метод $http.query или его аналоги (например, $http.get), система проверяет, предусмотрен ли в тесте соответствующий тег &lt;mockData> с такими же параметрами и телом, с какими выполняется HTTP-запрос. Если такой тег существует и указанные в нем URL и тело запроса в точности совпадают с ожидаемыми, то система использует ответ, указанный в &lt;mockData>, в качестве тела HTTP-ответа, полученного в результате вызова метода. Если в сценарии есть вызов $http, для которого в тесте нет подходящего элемента &lt;mockData>, HTTP-запрос будет принят за неудачный и не вернет данных в ответе. Из-за этого тест, вероятнее всего, будет провален. Реальные HTTP-запросы при выполнении автоматических тестов не выполняются. Это поведение можно переопределить. Передайте с тегом &lt;test> или &lt;test-case> атрибут integration=""true"", чтобы при запуске теста или тест-кейса выполнялись HTTP-запросы. В таком случае &lt;mockData> можно не указывать. Если вы используете атрибут integration=""true"" и достаточно часто запускаете автоматические тесты, то реальные запросы могут быстро исчерпать квоты на использование или иметь другие нежелательные побочные эффекты во внешних системах.', 'От варианта Завершен успешно создайте блок Условия. Делаем условие $items.next(), которое возьмет вопрос из массива $items Назовем этот экран ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС От экрана ""ВЫВОДИМ СЛЕДУЮЩИЙ ВОПРОС"" делаем связь на экран ""ВЫВОДИМ ВОПРОС"": Добавляем действие на случай, если есть история о пользователе Теперь нужно сделать так, чтобы на следующей сессии (например, при следующем запуске навыка в Алисе) мы узнавали пользователей и возвращали их на то место, где они остановились в последний раз. Вернемся в начало сценария. На экране ""ЕСТЬ ЛИ ИСТОРИЯ?"" от варианта Завершен успешно создайте новый блок Текст: С возвращением! В прошлый раз мы дошли до уровня $history.level. Твой счет: $history.score. Продолжим? Назовем этот экран ЕСЛИ ЕСТЬ ИСТОРИЯ Добавим на экран ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" блок Интенты. Добавим варианты реакций пользователя - готовые интенты Согласие и Отказ: :size=200 :size=200 Получаем неотвеченные вопросы От интента Отказ экрана ""ЕСЛИ ЕСТЬ ИСТОРИЯ"" создадим блок http-запрос. Здесь нам снова нужно получить данные из Google Таблицы, как обычно. метод GET URL может быть таким же, как в блоке HTTP-запрос ""Получаем вопрос"" :size=200 :size=200 на вкладке RESPONSE нажмите на + и в поле Имя переменной вставьте: items, а в поле Значение вставьте: $httpResponse.slice(parseInt($history.level)) Давайте разберемся, что значит это выражение в блоке Значение: slice - возвращает новый массив, содержащий копию части исходного массива, parseInt - преобразует строку в число.', 'Для тега можно задать необязательные атрибуты: strictMatch — строгость сопоставления мок-объекта телу запроса. Значение по умолчанию: false. При нестрогом сопоставлении (false) проверяется, что все значения полей, указанные в теге &lt;body>, равны соответствующим значениям полей из тела запроса. При строгом сопоставлении (значение true) проверяется полное совпадение объекта в теге &lt;body> и тела запроса. field — JsonPath-выражение, указывающее на поле для сопоставления. Если атрибут указан, сопоставление производится не по всему объекту из тела запроса, а только по его части. Ответ &lt;response> — описание ответа, который вернет мок-объект в качестве ответа сервера. Обязательный элемент. В теле элемента указывается строка с ответом. Возвращаемое значение метода $http.query помимо HTTP-ответа в поле data содержит ряд служебных полей: isOk, status и другие. Данные поля не следует помещать в &lt;response>. Указывайте только ответ от сервера — то, что приходит в поле data. Возможные атрибуты для тега: status — код ответа на HTTP-запрос, по умолчанию 200. type — тип ответа, по умолчанию json. Если тип ответа json или xml, ответ парсится и возвращается в сценарий в виде JS-объекта. В противном случае ответ передается в виде строки. Если формат тела &lt;response> не соответствует указанному типу, при публикации бота возникнет синтаксическая ошибка.', 'Например, если у вас есть столбец name, то в блокноте у вас получится:$rawRequest.originateData.payload.name Ниже пример таблицы и значений $rawRequest: :size=400 Системную переменную с названием нужной колонки используйте в блоке Текст: :size=400 В данном случае при звонке на номер 79105555555 бот скажет: ""Здравствуйте, Саша!"". А при звонке на номер 79995555555 бот скажет ""Здравствуйте, Алекс!"" Почему при тестировании возникает ошибка? После того, как вы используете перечисленные выше значения $rawRequest в сценарии, при тестировании в тестовом виджете вы будете получать ошибку, так как информацию из таблицы можно доставать только из телефонного канала. :size=400 Поэтому мы рекомендуем добавлять значения $rawRequest для вывода имени тогда, когда вы уже готовы запустить обзвон. Извлекать имя пользователя и другую информацию из таблицы с номерами можно только в процессе обзвона. В тестовом виджете это работать не будет. Если вы в данный момент находитесь в процессе тестирования сценария и вам нужно тестировать стороннюю функциональность, отложите использование $rawRequest до того этапа, когда сможете запускать обзвон и тестировать в телефонном канале. Примеры содержания $rawRequest В текущей таблице переменная $rawRequest содержит следующие данные: После ответа пользователя $rawRequest будет также содержать текст сообщения пользователя:', 'Возможные значения: readDataFromCells writeDataToCells writeDataToLine deleteRowOrColumn clearCellData customRequest &lt;parameters> — список аргументов, передача которых ожидается при вызове метода. Содержит вложенные элементы, теги которых соответствуют названиям аргументов. Например, метод readDataFromCells принимает аргументы integrationId, spreadsheetId, sheetName и cells, поэтому элемент &lt;parameters> может быть заполнен так: &lt;response> — ответ в формате JSON, который будет принят за ответ от метода при выполнении теста. Пример Рассмотрим следующий фрагмент сценария. Бот принимает время и произвольный текст, которые он записывает в новую строку таблицы через метод writeDataToLine. Работу такого стейта можно проверить при помощи теста, приведенного ниже. Поскольку в примере используется сущность @duckling.time, для тест-кейса необходимо переопределить текущее время через тег &lt;dateTime>. В значении &lt;response> указаны не все поля, которые возвращает интеграция: достаточно перечислить лишь те поля, которые используются в коде сценария.', 'HttpRequest Действие HttpRequest позволяет боту выполнять HTTP-запросы, чтобы получать данные от внешних ресурсов и сохранять их в переменные. Если вы хотите выполнять HTTP-запросы без тегов действий, но из вставок JavaScript-кода, используйте встроенный сервис $http. Параметры Сохранение данных в переменные С помощью параметра vars вы можете сохранить данные из ответа на успешный HTTP-запрос. JAICP сохраняет ответ от сервера в локальную переменную $httpResponse. К этой переменной можно обращаться только внутри тега HttpRequest. Ответ также сохраняется в сессионные данные как $session.httpResponse. Обращайтесь к этому полю, если хотите использовать данные из ответа в другом стейте. При каждом вызове тега HttpRequest значение поля перезаписывается. В значении параметра vars укажите массив объектов с полями name и value, где: name — имя переменной. Вычисленное значение value будет сохранено в $session.&lt;name>. value — выражение с использованием переменной $httpResponse для доступа к нужным полям ответа. В значении name используйте символы Aa–Zz, \\_, 0–9. Первым символом в имени должна быть буква. Нельзя использовать зарезервированные слова JavaScript.', 'Тут мы берем первый элемент массива $result\\[$index] и проверяем дату $date. Если ячейка в нашей таблице пустая, функция должна вернуть false. От этого условия создаем новый экран с блоком Текст. Если условие сработает, мы можем вывести номер столика и время: Столик: $result\\[$index].tableВремя: $result\\[$index].time На этот же экран добавляем блок Переход: От блока Переход создаем новый экран с блоком Условие. В этом условии мы увеличим нашу переменную $index на 1. Тем самым мы сможем взять следующий элемент массива:$index = $index + 1 После того как мы увеличили $index, нужно проверить, есть ли в нашем массиве элемент под таким индексом. Поэтому снова создаем Условие и пишем:$index &lt; $result.length Если условие сработает, то делаем переход на экран, где мы проверяли свободную дату. Теперь у нас получился цикл. Сделаем связь от else в блоке Условие. То есть, если такая дата и время заняты, берем следующий элемент для проверки. Также делаем связь от данного условия, если массив закончился и больше нет элементов. От else создаем блок Текст, в нем пишем: Введите номер столика, который желаете забронировать. Добавьте на этот экран блок Интенты и впишите интент: $NUMBER Добавляем кнопку Выбрать другое время. Далее, от системной сущности $NUMBER делаем связь на новый экран с блоком Условие: $res = \\_.findWhere($result, {""number"":$NUMBER}) Тут мы по номеру, который ввел пользователь, проверяем, есть ли такой столик.', 'Например, если в сценарии указано: А в тест-кейсе вы указываете: А затем: То в итоге значения полей для объекта $client будут такими: Пример Рассмотрим сценарий: Тест-кейс для проверки ответа пользователя может выглядеть так: Более подробный пример использования тега &lt;context> в разделе Тестирование сценария с переменными.']"	В документации не указано, что поле isOk принимает значение true при определенных статусах. Поэтому можно сделать вывод, что поле isOk не зависит от статуса и может принимать как true, так и false в ответе на $http.query.	1.0	0.8289360161376177	0.0
1) наше NLU, к какому PTM поколению можно отнести наши классификаторы (и можно ли)? Вопрос про каждый классификатор 2) к какому типу нейронок можно отнести наши классификаторы (если можно)? Вопрос про каждый классификатор	"['\'У нас доступны разные модели для разных потребностей пользователя:  - Transformer (самая модная архитектура) позволяет понимать смысл текста и обучен на огромных объемах данных на разных языках, хорошо подходит для небольших датасетов - модель класса сверточных нейросетей (""Deep learning""), которая тоже использует информацию о смысле слов, но в меньшей степени, чем Transformer - модель еще более классической архитектуры машинного обучения на основе библиотеки sklearn (""Classic ML""), которая строит текстовые признаки только по данным, которые загружает пользователь\'']"	['Пример запроса Ответ на запрос — массив идентификаторов всех созданных заданий на обзвон.', 'Пример запроса Ответ на запрос — массив идентификаторов всех созданных заданий на обзвон.', 'Блок Синтез речи', 'Статусы заданий на обзвон', 'Статусы заданий на обзвон', 'Мнение и оценка Субъекты и местоимения Вопросы и просьбы Управление звуком Числительные Вспомогательные паттерны', 'Настройка проекта CAILA — NLU-ядро для разработки на базе JAICP разговорных ботов и ассистентов, понимающих естественный язык. Чтобы создать новый проект CAILA и настроить его: Создайте проект любым удобным вам способом. Нажмите в карточке проекта → Настройки проекта. Заполните поля на вкладке Классификатор: Алгоритм классификатора — выберите алгоритм классификатора: STS (Semantic Textual Similarity) — алгоритм, который сравнивает семантическую близость слов. Он учитывает инверсию, словарные формы слов, их синонимы и другую информацию. Рекомендуется использовать при обучении бота на незначительном наборе данных: 5–7 тренировочных фраз на интент, но не более 1 000 фраз во всей выборке. Classic ML — стандартный алгоритм машинного обучения для распознавания интентов на основе логистической регрессии. Он классифицирует данные по исходным словам, словарным формам и основам слов без учета семантической информации. Рекомендуется использовать при выборке объемом не менее 20 тренировочных фраз на интент. Deep Learning — алгоритм на основе сверточных нейронных сетей. Учитывает семантику слов при формировании гипотез. Рекомендуется использовать при значительном наборе данных: не менее 50 тренировочных фраз на интент. Transformer — мультиязычный алгоритм. Он оценивает семантическое сходство запроса клиента со всеми тренировочными фразами из интента. Рекомендуется использовать при выборке объемом не менее 10 тренировочных фраз на интент.', 'Расширенные настройки NLU При редактировании настроек проекта вы можете задать новые параметры для настройки NLU. Параметры передаются в виде JSON-объекта. Общие настройки К общим настройкам относятся параметры, не зависящие от алгоритма классификатора в проекте: patternsEnabled — при активном параметре в тренировочных фразах доступно использование паттернов. tokenizerEngine — токенизатор, который будет выполнять токенизацию и лемматизацию текста. dictionaryAutogeneration — при активном параметре пользовательский словарь заполняется согласно содержимому сущностей. tokenizerEngine Для разных языков NLU доступны разные движки токенизации. STS Параметры для классификатора STS по умолчанию: allowedPatterns — список сущностей, для которых включен параметр Автоматически расширять интенты. exactMatch — коэффициент, на который умножается вес слова при полном совпадении слов в запросе клиента и в одной из тренировочных фраз. Например, дом и дом. lemmaMatch — коэффициент, на который умножается вес слова при совпадении слов по словарным формам (леммам). Например, дома и дом. jaccardMatch — коэффициент, на который умножается вес слова при совпадении слов по мере Жаккара. jaccardMatch срабатывает, если: Слова совпадают по символам, но символы расположены в разном порядке. Например, дома и мода. Слова почти совпадают по символам, а их мера сходства больше или равна jaccardMatchThreshold. Например, компьютер и компютер. jaccardMatchThreshold — минимальное значение меры Жаккара.', 'Правила классификации', 'Например:']	К сожалению, из предоставленной документации не ясно, к какому PTM поколению относятся классификаторы NLU. Также не указано, к какому типу нейронных сетей можно отнести эти классификаторы. Пожалуйста, уточните ваш вопрос или переформулируйте его.	0.6666666666666667	0.9190611296009176	0.14285714284285714
"Всем привет! В классификаторе STS в тестовом виджете ""четыре"" является синонимом ""хорошо"" или ""лучше"".  В проекте AL ловится интентом smsofferagreement как синоним ""хорошо"" Подскажите, так и должно быть?"	"['\'Да, в системе ""четыре"" может распознаваться как синоним ""хорошо"" или ""лучше"". Это связано с тем, что в некоторых контекстах число ""четыре"" может использоваться как выражение одобрения или согласия, что схоже с значениями слов ""хорошо"" и ""лучше"". Вес синонимичных слов может быть настроено в классификаторе STS через параметр synonymMatch\'']"	"['Предположим, что был распознан интент /KnowledgeBase/FAQ.Курсы/Цена: Сработает стейт PriceInt, потому что в нем есть тег intent! и он получит наибольший приоритет. Приоритет стейта FAQ.Courses будет меньше, потому что он может сработать только по тегу intentGroup!. Стейт AllFaqs получит наименьший приоритет, поскольку активируется по самой общей группе. Стейт Price не сработает вообще: /KnowledgeBase/FAQ.Курсы/Цена — это родительский интент. Если запрос с одинаковым весом попадает и в стейт с intent, и в стейт с intentGroup, то у стейта, который активирует тег intent, будет приоритет. Запрос пользователя Когда начинается курс? может попасть в оба стейта, но активируется стейт с intent — у него больший приоритет. Бот ответит более специфичным ответом, а не ответом-заглушкой. Значение nlp.considerContextDepthInStateSelectionV2 в chatbot.yaml может повлиять на порядок срабатывания стейтов. При значении true бот учитывает расстояние до стейта, поэтому у intentGroup во вложенном стейте возникает преимущество перед другими интентами: Бот находится в стейте Start. Запрос Как сразу оплатить курс? имеет вес 1 для интента /Оплата полностью/Как оплатить сразу? и 0,3 для интента /Оплата в рассрочку/Как оплатить в рассрочку?. Если указано значение true, будет активирован вложенный стейт PayInInstallments, и бот объяснит, как купить курс в рассрочку.', 'Хочешь еще раз? и совершит переход в стейт /Правила/Согласен?. Подсказки Если введенное число меньше, то бот посредством функции $reactions.answer() выдаст соответствующую фразу из массива selectRandomArg(). Например: Попробуй число больше. Функция selectRandomArg() предназначена для случайного выбора ответов из предложенных вариантов. Чтобы воспользоваться этой функцией, подключите JS-файлы common.js посредством require в начале файла main.sc. Затем перечислите в selectRandomArg() через запятую возможные варианты ответов. Например: Если введенное число не подошло под первые два условия, то сработает последний else и бот напишет случайно одно из сообщений массива. Таким образом, пользователь будет находиться в стейте Проверка до тех пор, пока не отгадает загаданное число. NoMatch Управление контекстом Стоит помнить, что люди могут ошибаться, набирая команды, и присылать боту текст, отличающийся от всех учтенных вариантов. Для этого используется стейт NoMatch, который обрабатывает конец сценария в случае, когда сообщение пользователя не подходит ни под один описанный стейт. Предположим, что пользователь ввел следующее сообщение Сегодня солнечно. Такое сообщение не попадет ни под один интент, поэтому активируется событие noMatch, указанное под глобальным тегом event! в стейте NoMatch. Если мы попадем в этот стейт, например, из стейта Правила, и пользователь затем введет сообщение хочу, то бот отправит сообщение я вас не понял.', 'Такая необходимость связана с особенностями языка JavaScript. Математические операции В блоке Условия вы можете совершать математические операции. В JavaScript складывать можно не только числа, но и строки (текст). Например, здесь в результате сложения строковых переменных $answer1 и $answer2 будет выведено ab: Сравнение Вы можете использовать оператор === для сравнения. Данное условие будет отрабатывать, если $score равен пяти. В отличие от оператора ==, который приводит данные к одному типу, оператор === также проверяет тип данных. Подробнее о различиях == и === в JavaScript Выполнение нескольких операций в одной строке Объединять в одной строке несколько операций можно при помощи операторов || или &&. Проверка нескольких условий Одно из условий верно Оператор || говорит о том, что из всех условий одно должно быть истинно. Такое условие будет отрабатывать, если $choice равен или «да», или «может быть». Так как нажатие кнопки равносильно текстовому вводу, после нажатия кнопки «да» значение «да» будет помещено в переменную $choice, затем будет выполнено условие. Оба условия верны Оператор && означает, что каждое из указанных условий должно быть истинно. Условие будет отрабатывать, если $kids равно 2, 3 или 4. То есть, $kids больше или равно 2 и при этом меньше или равно 4.', 'На wordSequence3 умножается вес третьего слова в последовательности. Четвертое и последующие слова также будут умножаться на значение wordSequence3. Рекомендуется варьировать эти параметры в промежутке от 0 не включительно до 1 включительно. Сохраняйте соотношение wordSequence1 &lt; wordSequence2 &lt; wordSequence3. Например, в интенте есть тренировочная фраза Хочу купить курс по очень выгодной цене. Пользователь пишет боту Решил вот купить курс у вас по очень выгодной цене. Алгоритм находит совпадающие последовательности: idfShift и idfMultiplier — параметры, которые влияют на расчет веса слова через IDF. Не рекомендуется менять их значения. namedEntitiesRequired — при активном параметре в запросе пользователя должна быть найдена системная сущность, чтобы запрос попал в интент. Например, в интент была добавлена фраза с системной сущностью Мне нужно @duckling.number яблок. При активном параметре запрос пользователя Мне нужно яблок не попадет в интент, так как в запросе нет системной сущности. Classic ML Параметры для классификатора Classic ML: C — коэффициент регуляризации, с помощью которого можно контролировать переобучение модели. Используется при работе с большими значениями коэффициентов целевой функции, штрафует их на величину параметра. Принимает следующие значения: 0.01, 0.1, 1, 10. word_ngrams — количество слов, которые будут объединены в словосочетания. При значении ""word_ngrams"": \\[2, 3] будут использованы словосочетания из двух и трех слов.', 'Ошибки 400 и 404 Если вы видите ошибку 404, HTTP-запрос оформлен неправильно. Если вы видите ошибку 400, вы также неправильно оформили HTTP-запрос. Обратите внимание на вкладку BODY и синтаксис вашего JSON. Например, ошибка может возникнуть, если в теле запроса вы используете и одинарные \' \', и двойные "" "" кавычки. Вы можете проверить валидность своего JSON при помощи какого-либо сервиса для проверки JSON. Например, JSON Formatter. Ошибка 400 также может возникать, если в вашем тексте есть разрывы. IFTTT может передавать только одну строку, поэтому текст клиента должен быть введен в одну строку. Вы можете использовать JavaScript-выражения в блоке Условия, чтобы устранять разрывы во введенном клиентом тексте. Изменения не поступили в сценарий Если вы отредактировали сценарий и продолжаете его тестировать, но строка все еще не добавляется в Google Таблицу, значит, в ваш сценарий не поступили изменения. Остановите тестирование в тестовом виджете и снова нажмите Тестировать, чтобы изменения применились. Не рекомендуется тестировать одновременно несколько сценариев на разных вкладках. Некорректное название события Если у вас все еще не получается записать данные в строку Google Таблицы, проверьте, что в URL запроса верно указано название вашего события. Проверьте название вашего события на странице апплетов IFTTT. Название события указывается в названии апплета в кавычках после «If Maker Event…». В URL запроса название события нужно указывать без кавычек и скобок.', 'По умолчанию параметр jaccardMatch учитывает совпадение двух слов, если их мера сходства больше или равна 0.82. acronymMatch — коэффициент, на который умножается вес словосочетания при совпадении словосочетания и его аббревиатуры. Аббревиатуры определяются с помощью регулярного выражения. Например, Московский государственный университет и МГУ. synonymMatch — коэффициент, на который умножается вес слова при совпадении по синониму. Готовый словарь синонимов встроен в CAILA и поддерживается только для русского языка. synonymContextWeight — коэффициент, на который штрафуется вес синонима: При ""synonymContextWeight"": 0.0 синоним не штрафуется. При ""synonymContextWeight"": 1.0 вес синонима существенно снижается. patternMatch — коэффициент, на который умножается вес слова при совпадении по сущности, указанной в тренировочной фразе. Например, в интенте есть фраза Позови @agent. Сущность @agent содержит синонимы консультант, специалист и оператор. Если пользователь напишет боту Позови оператора, слово оператор распознается как сущность, и его вес будет умножен на значение patternMatch. throughPatternMatch — коэффициент, на который умножается вес слова при совпадении по сущности, указанной в allowedPatterns. Коэффициенты, на которые умножается вес слова, если во фразе встречается совпадающая последовательность слов: На wordSequence1 умножается вес первого слова в последовательности. На wordSequence2 умножается вес второго слова в последовательности.', 'Исключение составляют тест-кейсы, в которых выполняется несколько одинаковых HTTP-запросов. Если все такие запросы предполагают одинаковые ответы, для них достаточно одного мок-объекта. Можно ли проверить разные ответы на одинаковые запросы? В одном тест-кейсе можно проверить выполнение одинаковых HTTP-запросов с разными ответами. При этом на каждый тег &lt;q> должен быть написан свой мок-объект. Если одному тегу &lt;q> предшествуют несколько подходящих тегов &lt;mockData>, то будет использован ответ из последнего тега, а все остальные будут проигнорированы. Рассмотрим пример простого стейта и тест-кейса: Примеры использования Проверка параметров запроса Следующий пример взят из пошагового сценария бота с обращением к API. В нем использован мок-объект для проверки стейта, где бот передает прогноз погоды. Проверка тела запроса Пример ниже иллюстрирует различные варианты того, как тело запроса может сопоставляться с содержимым тега &lt;body>.', 'В дальнейшем, когда будем настраивать заполнение слотов, именно столько фраз будет использовано в поле Вопросы. stopOnAnyIntent — параметр прерывания процесса слот-филлинга по интенту. Если stopOnAnyIntent: true, то интент будет прерван тогда, когда пользователь захочет обработать другой интент. В нашем сценарии не предусмотрены случаи, когда нужно прервать интент со слот-филлингом по другому интенту. Поэтому установим stopOnAnyIntent: false. stopOnAnyIntentThreshold — параметр соответствия, задающий минимально необходимую похожесть фразы на один из классов. Является параметром прерывания процесса слот-филлинга по интенту. В ходе разработки NLU-сервиса было эмпирически определено, что оптимальное значение этого параметра 0.2. Теперь перейдем к работе с HTTP-запросом.', '$reactions.random Метод возвращает случайное целое число в заданном диапазоне. Синтаксис Метод принимает один аргумент — целочисленное значение max: Метод возвращает случайное целое число в диапазоне от 0 до max (не включая max). Особенности Значения, которые возвращает метод, могут быть переопределены в XML-тестах при помощи тега &lt;random>, чтобы тесты проходили стабильно. Для встроенного JavaScript-метода Math.random переопределить возвращаемые значения нельзя. Поэтому использовать его в сценариях JAICP не рекомендуется. Возвращаемые значения могут быть переопределены в сценарии при помощи модификации объекта $request.data.smartRandom. Все возвращаемые значения записываются в $response и могут быть использованы для повторного выполнения сценария с такими же результатами. Метод гарантирует, что возвращаемые случайные числа не повторяются чаще, чем через max / 2 последовательных вызовов метода. Пример использования Напишем стейт, который эмулирует игру в кости и выдает сумму двух случайных чисел от 1 до 6:', 'На второй версии диалогового движка поле является обязательным. Пороговые значения классификатора Поля phrases и patterns в секции nlp.intentNoMatchThresholds задают пороговые значения для классификатора интентов CAILA и его гипотез. Гипотеза — это результат работы классификатора. Во время формирования гипотезы классификатор определяет, насколько запрос пользователя соответствует тому или иному интенту. Так классификатор выражает степень своей уверенности в том, что этот интент действительно содержит фразу или паттерн из запроса пользователя. Рассмотрим поведение классификатора интентов: Пользователь отправляет запрос боту. При формировании гипотез классификатор сравнивает запрос с паттернами и тренировочными фразами по отдельности. Он вычисляет вероятность для каждой из гипотез. Если вероятность гипотезы меньше, чем порог у phrases или patterns, эта гипотеза не учитывается при дальнейшей обработке запроса и определении стейта в сценарии. Таким образом, intentNoMatchThresholds задает минимальную похожесть запроса на фразы или паттерны. Чем ближе значение к 1, тем строже классификатор и тем более точные требуются совпадения. Значение phrases и patterns по умолчанию — 0.2. Это значение используется, если не задать другое для любого из полей. В старых проектах вместо nlp использовалась секция caila. Она содержит поле noMatchThreshold, которое задает общее пороговое значение и для фраз, и для паттернов.']"	"Да, в классификаторе STS в тестовом виджете ""четыре"" может быть синонимом ""хорошо"" или ""лучше"". В проекте AL интент smsofferagreement может ловиться как синоним ""хорошо"". Это может быть связано с настройками классификатора и заданными синонимами в проекте."	0.0	0.9630116131097548	0.0
Пользователь интересуется про расширенные настройки NLU, можете плиз рассказать подробнее, за что отвечает wordSequence? Что такое длина 1? Чем отличаются wordSequence1 от wordSequence2? что за параметры idfShift и idfMultiplier?	"[""'Коэффициенты, на которые умножается вес слова, если во фразе встречается совпадающая последовательность слов: - На wordSequence1 умножается вес первого слова в последовательности. - На wordSequence2 умножается вес второго слова в последовательности. - На wordSequence3 умножается вес третьего слова в последовательности.  idfShift и idfMultiplier — параметры, которые влияют на расчет веса слова через IDF. Не рекомендуется менять их значения.'""]"	"['Расширенные настройки NLU При редактировании настроек проекта вы можете задать новые параметры для настройки NLU. Параметры передаются в виде JSON-объекта. Общие настройки К общим настройкам относятся параметры, не зависящие от алгоритма классификатора в проекте: patternsEnabled — при активном параметре в тренировочных фразах доступно использование паттернов. tokenizerEngine — токенизатор, который будет выполнять токенизацию и лемматизацию текста. dictionaryAutogeneration — при активном параметре пользовательский словарь заполняется согласно содержимому сущностей. tokenizerEngine Для разных языков NLU доступны разные движки токенизации. STS Параметры для классификатора STS по умолчанию: allowedPatterns — список сущностей, для которых включен параметр Автоматически расширять интенты. exactMatch — коэффициент, на который умножается вес слова при полном совпадении слов в запросе клиента и в одной из тренировочных фраз. Например, дом и дом. lemmaMatch — коэффициент, на который умножается вес слова при совпадении слов по словарным формам (леммам). Например, дома и дом. jaccardMatch — коэффициент, на который умножается вес слова при совпадении слов по мере Жаккара. jaccardMatch срабатывает, если: Слова совпадают по символам, но символы расположены в разном порядке. Например, дома и мода. Слова почти совпадают по символам, а их мера сходства больше или равна jaccardMatchThreshold. Например, компьютер и компютер. jaccardMatchThreshold — минимальное значение меры Жаккара.', 'На wordSequence3 умножается вес третьего слова в последовательности. Четвертое и последующие слова также будут умножаться на значение wordSequence3. Рекомендуется варьировать эти параметры в промежутке от 0 не включительно до 1 включительно. Сохраняйте соотношение wordSequence1 &lt; wordSequence2 &lt; wordSequence3. Например, в интенте есть тренировочная фраза Хочу купить курс по очень выгодной цене. Пользователь пишет боту Решил вот купить курс у вас по очень выгодной цене. Алгоритм находит совпадающие последовательности: idfShift и idfMultiplier — параметры, которые влияют на расчет веса слова через IDF. Не рекомендуется менять их значения. namedEntitiesRequired — при активном параметре в запросе пользователя должна быть найдена системная сущность, чтобы запрос попал в интент. Например, в интент была добавлена фраза с системной сущностью Мне нужно @duckling.number яблок. При активном параметре запрос пользователя Мне нужно яблок не попадет в интент, так как в запросе нет системной сущности. Classic ML Параметры для классификатора Classic ML: C — коэффициент регуляризации, с помощью которого можно контролировать переобучение модели. Используется при работе с большими значениями коэффициентов целевой функции, штрафует их на величину параметра. Принимает следующие значения: 0.01, 0.1, 1, 10. word_ngrams — количество слов, которые будут объединены в словосочетания. При значении ""word_ngrams"": \\[2, 3] будут использованы словосочетания из двух и трех слов.', 'CAILA NLU CAILA (Conversational AI Linguistic Assistant) — NLU-ядро для разработки на базе платформы JAICP разговорных чат-ботов и ассистентов, понимающих естественный язык. При разработке бота на CAILA вам будут доступны следующие функциональные возможности: Расширенные настройки NLU. Вы можете задать новые параметры для настройки NLU, уникальные для отдельного проекта. Распознавание интентов пользователей. Интент — ключевая единица NLU-сервиса, объединяющая в себе набор фраз, намерение пользователя и другую метаинформацию. Системные и пользовательские сущности. Сущность — единица NLU-ядра CAILA. Представляет собой последовательность слов, объединенных некоторым смыслом или правилом. Например: имена, дата и время, местоположение и пр. Клиентские сущности — сущности, которые может персонализировать сам клиент во время диалога с ботом. При этом содержание сущности будет доступно только для самого клиента. Клиентские сущности используются для решения задач, в которых необходима персонализация для распознавания интентов. Слот-филлинг (slot filling) — процесс дозапроса информации для выполнения запроса клиента. Полученные данные в ходе дозапроса доступны для использования в сценарии. Разметка логов (Data Labeling) — инструмент, позволяющий выявлять тематику сообщений из загруженных данных, на которые будет реагировать бот. CAILA API позволяет использовать обученный классификатор в сторонних приложениях.', '$caila.checkVocabulary Проверяет каждое слово из массива аргументов на вхождение в словарь указанного движка NLU. Синтаксис Метод принимает в качестве аргумента массив объектов со следующими полями: Движок pymorphy поддерживает только русский язык. Использование в сценарии Метод целесообразно использовать, например, чтобы проверить, содержат ли нераспознанные запросы от пользователя хотя бы одно словарное слово. Если таких слов нет, запросы можно расценивать как спам.', 'Отвечать на вопросы на узкоспециальные темы: например, о финансовых услугах вашей компании. В будущих версиях в базе знаний появится поддержка модулей, которые смогут запускать внутри бота отдельные сценарии: например, устанавливать по запросу пользователя будильник и запускать его в нужное время. Ключевая составляющая любого модуля — понимание естественного языка (NLU), благодаря которому бот, к которому подключен модуль, способен понимать запросы пользователей. NLU-составляющая модулей FAQ в базе знаний реализована через CAILA — NLU-ядро JAICP. Если функциональности базы знаний недостаточно для ваших задач, вы всегда можете переключиться в CAILA и продолжить работу в интерфейсе интентов. Для этого перейдите в меню CAILA → Интенты и найдите в дереве интентов интент KnowledgeBase. Каждый из его вложенных интентов соответствует одному из модулей текущего проекта. Тестирование модулей Во время работы над базой знаний вы можете проверить, правильно ли распознается вопрос в той или иной фразе. Для этого справа сверху нажмите: Применить и тестировать — все последние изменения в базе знаний будут применены, затем откроется тестовый виджет. Эта опция может пригодиться, если вам нужно проверить поведение старой версии базы знаний уже после того, как вы внесли в нее изменения. Тестовый виджет У базы знаний и CAILA общий тестовый виджет, поэтому результаты тестирования включают в себя все интенты (в том числе вопросы из модулей FAQ) и сущности, которые распознаются в данном проекте.', 'В новых проектах для корректного определения паттернов рекомендуется использовать вместо нее секцию nlp, поскольку у классификатора и алгоритма, который вычисляет вес паттернов, могут быть разные шкалы. Длина $context.nBest Поля семейства nlp.nbest задают число правил активации, к которым можно получить доступ из сценария через объект $context. Поле nbest задает длину $context.nBest — массива сработавших для запроса правил активации всех типов: паттернов, интентов и примеров. Значение по умолчанию — 1. Поле nbestPatterns задает длину $context.nBestPatterns — массива правил активации, сработавших только при помощи паттернов. Если поле не указано, то этот массив недоступен. nbestIntents и nbestExamples работают аналогично для интентов и примеров. Подробнее об использовании $context.nBest Ограничения при обработке запроса Ограничение на длину запроса Секция nlp.lengthLimit задает ограничение на длину запросов, которые принимает бот: enabled включает или выключает проверку. symbols — максимальное количество символов в запросе. words — максимальное количество слов в запросе. Если указано -1, эта проверка не производится. По умолчанию включено ограничение на 400 символов, ограничение на количество слов отключено. Если запрос превысит одно из ограничений, в сценарии возникнет событие lengthLimit. Ограничение на время обработки запроса Секция nlp.timeLimit задает ограничение на общее время, в течение которого будет обработан запрос: enabled включает или выключает проверку.', 'Если CAILA распознает вопрос, на который должен сработать один из модулей FAQ, этот вопрос отображается как интент. Каждому распознанному интенту соответствует значение от 0 до 1 — степень уверенности в том, что он содержится во фразе. Если во фразе есть вопрос, на который есть ответ в CDQA, виджет покажет этот ответ над списком интентов. Нажмите на него, чтобы узнать подробную информацию о том, как модель обработала вопрос: степень уверенности и список других возможных ответов с меньшим весом. Результат распознавания вопроса «Где у вас офисы?» в тестовом виджете — список подходящих интентов с различными весами. Результат распознавания вопроса «Что такое база знаний?» в тестовом виджете — карточка с ответом от CDQA. Применение изменений Чтобы применить все последние изменения в базе знаний, нажмите Применить и тестировать или → Применить изменения (в этом случае тестовый виджет не откроется). После того как вы применяете изменения, они сразу становятся доступны во всех каналах, где опубликован бот. Во время активной разработки рекомендуется тестировать модули в отдельном проекте, а затем импортировать их в основной. Пополнение модулей В JAICP встроены инструменты, которые помогут вам пополнить базу знаний и подготовить ее для обучения бота. Бот обучается на содержании модулей FAQ. Они составляют вашу обучающую выборку.', 'Конфигурационный файл chatbot.yaml chatbot.yaml — конфигурационный файл чат-бота. Файл содержит основную информацию о конфигурации проекта, например: имя главного файла сценария; данные о подключаемых зависимостях; конфигурацию NLU; перечень файлов с тестами. В данном разделе перечислены настройки, которые можно задать в chatbot.yaml, и их назначение. Подробнее о синтаксисе YAML Точка входа в сценарий Поле используется для указания файла, с которого начинается загрузка сценария чат-бота при публикации. Файл должен находиться в папке src и обычно называется main.sc или entryPoint.sc. Если код сценария состоит из нескольких файлов, все необходимые файлы должны быть прямо или опосредованно импортированы в основной файл. Для этого используйте тег require. entryPoint — обязательное поле. Имя бота Поле задает имя бота, которое будет использовано, например, в сообщениях о публикации бота в канал. Если поле отсутствует, в качестве имени используется системное название проекта. Настройки NLU Диалоговый движок Поле задает версию диалогового движка бота. Движок второй версии v2 позволяет использовать для понимания естественного языка (NLU) сервис CAILA. Это рекомендуемое значение поля для всех новых проектов. Если поле отсутствует или значение поля отличается от v2, будет использован движок первой версии v1. NLU на этом движке возможен только при помощи паттернов. Язык бота Поле задает язык, на котором общается бот. Значение поля должно быть ISO-кодом нужного языка.', 'require Описание require — тег служит для загрузки зависимых файлов и, по сути, является альтернативой указанию всех зависимых файлов в chatbot.yaml. Тип значения string — задает имя подключаемого файла Параметры type (string) — опциональный параметр, определяет тип файла; по умолчанию определяется из расширения. from (string) — имя модуля, из которого импортируется файл; версия и репозиторий модуля указываются в chatbot.yml. rootTheme (string) — базовая тема для всех состояний, определенных в подключаемом файле. provide (multiline json) — набор параметров, передаваемый подключаемому модулю. name (string) — имя паттерна для справочников сущностей. var (string) — определяет имя js-переменной с данными из справочника. injector (string) — через объект $injector в скрипт могут передаваться метапараметры. module (string) — имя модуля, из которого загружается файл. Имя модуля либо задается в секции dependecies конфигурационного файла chatbot.yaml, либо соответствует имени папки в папке системных модулях. Подробнее о работе с module Вложенные данные named parametrs Примеры использования параметр varName; параметры from, rootTheme, provide; параметры type, patternName; параметр injector; параметр module; в значениях параметров возможны подстановки.', 'Конфигурационный файл CAILA NLU проекта nlu.json — конфигурационный файл проекта, который содержит настройки CAILA NLU. Файл содержит настройки проекта, параметры сущностей и интентов. Например: В ранее созданных проектах конфигурационный файл CAILA NLU называется caila_import.json, новые проекты по умолчанию создаются с файлом nlu.json. Работа с файлом Файл nlu.json доступен в архиве при скачивании проекта, а также при размещении проекта в удаленном репозитории. В редакторе сценария файл не отображается. Файл формируется и обновляется при публикации проекта. Не рекомендуется вносить изменения в файл nlu.json — это может вызвать конфликты, если над проектом работает несколько человек. Вы можете работать с параметрами CAILA NLU через веб-интерфейс Just AI.']"	Параметр wordSequence отвечает за умножение веса слов в последовательности. Длина 1 означает, что только первое слово будет умножаться на значение wordSequence1. Параметры wordSequence1 и wordSequence2 отличаются своими значениями. Параметры idfShift и idfMultiplier влияют на расчет веса слова через IDF.	0.25	0.9100839787483422	0.49999999995
всем привет! может кто в курсе, есть ли возможность подключить Mattermost как канал в JAICP?	"[""'нет, доступны только WhatsApp, Slack, Telegram, Viber, WeChat'""]"	['Как подключить канал Aimychat', 'Wazzup как входящий канал Wazzup — сервис, с помощью которого можно подключить такие каналы, как Telegram и WhatsApp, а также настроить интеграцию с CRM-системами, например Битрикс24 или AmoCRM. Чтобы настроить канал и подключить бота: Настройте интеграцию в Wazzup. Подключите канал в JAICP. Протестируйте бота. Шаг 1. Настройте интеграцию в Wazzup Зарегистрируйтесь или войдите в личный кабинет Wazzup. Перейдите в раздел Каналы и нажмите Добавить канал. Выберите канал. Выполните нужные действия для выбранного канала. Перейдите в раздел Интеграция с CRM → API. Вам будет предложено добавить интеграцию по API. Нажмите Подключить. В появившемся окне скопируйте ключ API. Он понадобится для настройки канала в JAICP. Затем вы сможете найти ключ API на вкладке Интеграция с CRM → Дополнительно. Вы можете подробнее узнать, как подключить один из доступных мессенджеров, в документации Wazzup. Шаг 2. Подключите канал в JAICP Откройте проект вашего бота в JAICP. В меню слева нажмите Каналы, затем Подключить канал в разделе Входящие. В разделе Мессенджеры и соцсети выберите Wazzup. Укажите настройки: Название — название канала. Токен — ключ API, полученный в Wazzup. Ветка — ветка проекта, которую вы хотите развернуть в канал, по умолчанию master. Вы также можете выбрать Git-тег или ввести хеш конкретного коммита. Оператор — операторский канал, если вы хотите, чтобы бот мог переводить диалог на оператора. Операторский канал должен быть настроен и подключен к вашему проекту.', 'Wazzup Wazzup — сервис, с помощью которого можно подключить такие каналы, как Telegram и WhatsApp, а также настроить интеграцию с CRM-системами, например Битрикс24 или AmoCRM. Чтобы настроить канал и подключить бота: Настройте интеграцию в Wazzup. Подключите канал в Aimylogic. Протестируйте бота. Шаг 1. Настройте интеграцию в Wazzup Зарегистрируйтесь или войдите в личный кабинет Wazzup. Перейдите в раздел Каналы и нажмите Добавить канал. Выберите канал. Выполните нужные действия для выбранного канала. Перейдите в раздел Интеграция с CRM > API. Вам будет предложено добавить интеграцию по API. Нажмите Подключить. В появившемся окне скопируйте ключ API. Он понадобится для настройки канала в Aimylogic. Затем вы сможете найти ключ API на вкладке Интеграция с CRM > Дополнительно. Вы можете подробнее узнать, как подключить один из доступных мессенджеров, в документации Wazzup. Шаг 2. Подключите канал в Aimylogic Откройте проект вашего бота в Aimylogic. В меню слева нажмите Каналы. В разделе Мессенджеры, соцсети и API выберите Wazzup. В поле Токен вставьте ключ API, полученный в Wazzup. Нажмите Подключить. Дождитесь всплывающего окна с результатом публикации. Шаг 3. Протестируйте бота Откройте канал, к которому вы подключили бота. Отправьте ему приветственную/активационную фразу, предусмотренную вашим сценарием. После этого должен начаться ваш диалог с ботом. Особенности Wazzup В Wazzup вы можете подключить одновременно несколько входящих каналов.', 'Microsoft Teams как входящий канал Microsoft Teams — корпоративная платформа, объединяющая в рабочем пространстве чат для работы над проектами, хаб для командной работы, заметки и вложения. Чтобы подключить Microsoft Teams как входящий канал: Создайте канал в JAICP. Настройте Azure Bot Service. Настройте канал в JAICP. Протестируйте бота. Создание канала в JAICP Перейдите в JAICP, нажмите на панели управления Каналы → Входящие → Подключить канал. В разделе Другие выберите Azure Bot. Заполните поля: Название — укажите название для канала или оставьте по умолчанию. Токен — оставьте пустым. Microsoft App ID — оставьте пустым. Пароль — оставьте пустым. Ветка — укажите ветку проекта, которую вы хотите развернуть в канал, по умолчанию master. Вы также можете выбрать Git-тег или ввести хеш конкретного коммита. Оператор — выберите операторский канал или оставьте пустым. Публикация — автоматически (после каждого сохранения внесенных в проект изменений) или вручную (с помощью кнопки Опубликовать в строке с описанием канала). Публикацию сценария нужно выполнять перед запуском бота. На этом этапе происходит сборка бота, проверка синтаксиса сценариев и скриптов, а также проверка прохождения тестов. Нажмите Создать. Под названием созданного канала нажмите Получить вебхук, он будет скопирован в буфр обмена. Скопированный вебхук необходим для настройки Azure Bot Service. Azure Bot Service Для подключения бота в Microsoft Teams к JAICP используется служба Azure Bot Service.', 'Вы можете просмотреть его исходный код на GitHub, а оттуда же сразу создать проект в JAICP.', 'Вы можете просмотреть его исходный код на GitHub, а оттуда же сразу создать проект в JAICP.', 'Подключение Slack для проекта на JAICF Чтобы подключить Slack для проекта на JAICF: Подготовьте проект. Подключите канал. Протестируйте бота. Подготовка проекта Перед подключением канала предварительно подготовьте проект JAICF: Укажите в файле build.gradle.kts в зависимостях настройки: Замените $jaicfVersion последней версией фреймворка. Сконфигурируйте в зависимости от способа подключения к платформе: long polling — бот будет сам подключаться к серверу Just AI при взаимодействии с платформой. Простое решение, подходит для локальной разработки и отладки. Для этого способа укажите в файле JaicpPoller.kt канал SlackChannel: webhook — по указанной ссылке бот будет принимать сообщения платформы. Необходимо конфигурировать для подключения в JAICP Cloud. Для этого способа укажите в файле JaicpServer.kt канал SlackChannel: Подключение канала Для подключения канала используйте инструкцию. Тестирование бота Перейдите в окно диалога с ботом в Slack, выбрав своего бота из списка в подразделе Apps в рабочем пространстве. Отправьте в диалог приветственную/активационную фразу, предусмотренную вашим сценарием. После этого должен начаться ваш диалог с ботом. Нативные возможности канала Использование данных из запроса В канале Slack можно получить из запроса дополнительные данные. Для этого приведите тип запроса в блоке action к SlackBotRequest: Нативные реакции JAICF предоставляет универсальные реакции, доступные во всех каналах, а также реакции, уникальные для Slack.', 'Разместите его в директории src или по пути, который вы задали самостоятельно как параметр npmRcFile в chatbot.yaml. Например, вы можете использовать не только пакеты из публичного реестра https&#x3A;//registry.npmjs.org/, но и из приватного. Для этого в файле .npmrc укажите адрес реестра и токен для авторизации: Использование встроенного JS API JAICP предоставляет встроенный JS API — набор глобальных переменных, функций и сервисов, которые доступны из любой точки сценария. С помощью него можно реализовать часто используемую функциональность, актуальную для самых разных проектов: Переменные $session и $client предоставляют нативное хранилище данных о сессии и клиенте без необходимости подключать к боту свою базу данных. Сервис $http дает возможность интегрировать бота практически с любой внешней системой, к которой можно обратиться по HTTP API. Сервисы $analytics, $imputer, $pushgate и ряд других позволяют вызывать из сценария различные специализированные подсистемы самой JAICP. На данный момент внутри тегов scriptEs6 и зависимостей на ES6 вы можете использовать ограниченное подмножество JS API — не все возможности перенесены в новую среду исполнения. Список доступных возможностей приведен ниже и постепенно будет расширяться. Если нужная функциональность напрямую не связана с JAICP, используйте внешние зависимости, чтобы компенсировать ее недостаток. Например, вместо $http отлично подойдет HTTP-клиент Axios.', 'Подключение чат-виджета для проекта на JAICF Чтобы подключить чат-виджет для проекта на JAICF: Подготовьте проект. Подключите канал. Подготовка проекта Перед подключением канала предварительно подготовьте проект JAICF: Укажите в файле build.gradle.kts в зависимостях настройки: Замените $jaicfVersion последней версией фреймворка. Сконфигурируйте в зависимости от способа подключения к платформе: long polling — бот будет сам подключаться к серверу Just AI при взаимодействии с платформой. Простое решение, подходит для локальной разработки и отладки. Для этого способа укажите в файле JaicpPoller.kt канал ChatWidgetChannel: webhook — по указанной ссылке бот будет принимать сообщения платформы. Необходимо конфигурировать для подключения в JAICP Cloud. Для этого способа укажите в файле JaicpServer.kt канал ChatWidgetChannel: Подключение канала Для подключения канала используйте инструкцию. Нативные возможности канала Использование данных из запроса В чат-виджете можно получить из запроса дополнительные данные. Для этого приведите тип запроса в блоке action к ChatWidgetBotRequest: Нативные реакции JAICF предоставляет универсальные реакции, доступные во всех каналах, а также реакции, уникальные для чат-виджета и JaicpNativeChannel. Конфигурация канала При создании канала вы можете задать список событий, которые будут игнорироваться ботом при их возникновении в канале.', 'Подключение Алисы для проекта на JAICF Чтобы подключить Алису для проекта на JAICF: Подготовьте проект. Подключите канал. Подготовка проекта Перед подключением канала предварительно подготовьте проект JAICF: Укажите в файле build.gradle.kts в зависимостях настройки: Замените $jaicfVersion последней версией фреймворка. Сконфигурируйте в зависимости от способа подключения к платформе: long polling — бот будет сам подключаться к серверу Just AI при взаимодействии с платформой. Простое решение, подходит для локальной разработки и отладки. Для этого способа укажите в файле JaicpPoller.kt канал AliceChannel: webhook — по указанной ссылке бот будет принимать сообщения платформы. Необходимо конфигурировать для подключения в JAICP Cloud. Для этого способа укажите в файле JaicpServer.kt канал AliceChannel: Подключение канала Для подключения канала используйте инструкцию. Нативные возможности канала Хранение пользовательского контекста Алиса предоставляет собственный менеджер контекста для хранения пользовательских данных. Чтобы включить его, передайте параметр useDataStorage при указании канала: Запросы, приходящие от Алисы, будут содержать контекст пользователя. Использование данных из запроса В канале Алиса можно получить из запроса дополнительные данные. Для этого приведите тип запроса в блоке action к AliceBotRequest: Нативные реакции JAICF предоставляет универсальные реакции, доступные во всех каналах, а также реакции, уникальные для Алисы.']	К сожалению, документация не содержит информации о подключении Mattermost как канала в JAICP. Пожалуйста, уточните другие доступные каналы для подключения или задайте вопрос с более конкретными параметрами.	0.33333333333333337	0.9268111269349045	0.0
